<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Computational Issue with the Current Implementation One of the major computational challenge we saw in the algorithm presented in the project report was that we always have to visit the whole space of the &ldquo;subquery entailment instance&#34;s, whose size is doubly-exponential in the maximum arity $K$ and exponential in some other factors."><title>Optimized Reasoning with Guarded Logic</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic//icon.png><link href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/styles.9f7dae4c97607d27bafbfe52e36037c6.min.css rel=stylesheet><link href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/darkmode.bae5edc96f36c4f69e23354ae416a6c2.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/popover.c8d16a5ec626f5ddffabfe05fcc7dbd7.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/",fetchData=Promise.all([fetch("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/indices/linkIndex.5e4c7d1f257398184e3d9eeb0f3ca520.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/indices/contentIndex.2840513a3865f962440e41de544ad565.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=()=>{addCopyButtons(),addTitleToCodeBlocks(),MathJax.typeset()}</script><script type=module>
    import { attachSPARouting } from "https:\/\/kory33.github.io\/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/>Optimized Reasoning with Guarded Logic</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Jul 28, 2023
<a href=https://github.com/kory33/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/tree/master/content/thoughts/2023-07-28%20Applying%20Backward%20Reachability%20Test%20to%20Stratified%20State%20Space%20of%20Query-Chase%20Tree%20Automaton.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#computational-issue-with-the-current-implementation>Computational Issue with the Current Implementation</a></li><li><a href=#revisiting-the-intuition-of-tree-automaton-for-bcq-evaluation>Revisiting the Intuition of Tree Automaton for BCQ Evaluation</a></li><li><a href=#how-about-using-backward-reachability-tests-then>How about Using Backward Reachability Tests, then?</a></li></ol></nav></details></aside><div>$$
\newcommand\isDefinedAt[2]{{#1 \downarrow #2}}
\def\domain{{\operatorname{dom}}}
\def\elems{{\operatorname{elems}}}
\def\concat{{^\frown}}
\def\head{{\operatorname{head}}}
\def\ConnComp{{\operatorname{ConnComp}}}
\def\Vars{{\mathrm{Vars}}}
\def\Nulls{{\mathrm{Nulls}}}
\def\Consts{{\mathrm{Consts}}}
\def\Predicates{{\mathrm{Predicates}}}
\def\Arity{{\operatorname{Arity}}}
\def\FactualTerms{{\mathrm{FactualTerms}}}
\def\Terms{{\mathrm{Terms}}}
\def\NullableTerms{{\mathrm{NullableTerms}}}
\def\Atoms{{\mathrm{Atoms}}}
\def\Formulae{{\mathrm{Formulae}}}
\def\GTGDFormulae{{\mathrm{GTGDFormulae}}}
\def\FactualSubstitutions{{\mathrm{FactualSubstitutions}}}
\def\QueryAnswers{{\operatorname{QueryAnswers}}}
\def\Facts{{\mathrm{Facts}}}
\def\BaseFacts{{\mathrm{BaseFacts}}}
\def\Instances{{\mathrm{Instances}}}
\def\exlift{{\operatorname{Lift}_\exists}}
\def\Sat{{\operatorname{Sat}}}
\def\FullSat{{\operatorname{FullSat}}}
\def\TreeFacts{{\operatorname{TreeFacts}}}
\def\consts{{\operatorname{consts}}}
\def\vars{{\operatorname{vars}}}
\def\chase{{\operatorname{chase}}}
\def\chaseHead{{\operatorname{chaseHead}}}
\def\rew{{\operatorname{rew}}}
\def\Instance{{\operatorname{Instance}}}
\def\Intro{{\operatorname{Intro}}}
\def\exports{{\operatorname{exports}}}
\def\ChaseStepDir{{\operatorname{ChaseStepDir}}}
\def\SatTree{{\operatorname{SatTree}}}
\def\touchDowners{{\operatorname{touchDowners}}}
\def\Glue{{\operatorname{Glue}}}
\def\Frag{{\operatorname{Frag}}}
\def\Tentacle{{\operatorname{Tentacle}}}
\def\Abst{{\operatorname{Abst}}}
\def\GenConst{{\operatorname{GenConst}}}
\def\GenInst{{\operatorname{GenInst}}}
$$</div><a href=#computational-issue-with-the-current-implementation><h2 id=computational-issue-with-the-current-implementation><span class=hanchor arialabel=Anchor># </span>Computational Issue with the Current Implementation</h2></a><p>One of the major computational challenge we saw in the algorithm presented in the
<a href=https://kory33.github.io/guarded-queries/report.pdf rel=noopener>project report</a> was that we <em>always</em> have to visit the whole space of the &ldquo;subquery entailment instance"s, whose size is doubly-exponential in the maximum arity $K$ and exponential in some other factors. To be more precise, the upper bound for the number of such instances we gave in the paper (Remark 4.18) was $$2^{|\text{sig}|(K + |\mathrm{Consts}|(\Sigma))^K + \mathrm{Vars}(Q)} \times (K + |\mathrm{Consts}|(\Sigma))^{\mathrm{Vars}(Q)},$$where $Q$ is the conjunctive query, $\Sigma$ is the GTGD rule set, $\mathrm{sig}$ is the set of predicate symbols and $K$ is the maximum arity of symbols in $\mathrm{sig}$.</p><p>We identified that we may be able to exponentially cut down the search space by considering subsumptions: for instance, suppose that we concluded that a local instance $\mathcal{I}_0$ is sufficient to entail a subquery $Q$, then for any local renaming $\sigma$ (that does not remap local names that are already bound to variables in the subquery) and any local instance $\tilde{\mathcal{I}}$ with $\sigma(\mathcal{I}_0) \subseteq \tilde{\mathcal{I}}$, $\tilde{\mathcal{I}}$ is sufficient to entail $Q$. Such reasonings allow us to, for instance, skip all subquery entailment tests for local instances such as ${ P(1, 1) }, { P(1, 3) }, { P(2, 1) }, { P(1, 2), S(1) }, &mldr;$ once we know that a minimal instance ${P(1, 2)}$ is sufficient to entail the subquery in question.</p><p>This optimization sounds plausible, but the difficulty lies in &ldquo;finding the next interesting subquery entailment instance&rdquo; given the set of all &ldquo;minimal&rdquo; query-entailing instances. One naive approach is simply to iterate through every possible subquery entailment instances and filter out instances that are subsumed by minimal instances found previously: however, this still requires us to go through doubly exponentially many local instances, and we estimated that such implementation cannot drastically improve the overall runtime (in fact it may even be slower due to running subsumption tests every time we visit a new subquery entailment instance). There may actually be a good algorithm for efficiently enumerating &ldquo;next interesting&rdquo; point in the space of instances partially ordered by subsumption relation, but we could not come up with one.</p><a href=#revisiting-the-intuition-of-tree-automaton-for-bcq-evaluation><h2 id=revisiting-the-intuition-of-tree-automaton-for-bcq-evaluation><span class=hanchor arialabel=Anchor># </span>Revisiting the Intuition of Tree Automaton for BCQ Evaluation</h2></a><p>Stepping back, our idea to the algorithm was the following (only some of which appeared in the
<a href=https://kory33.github.io/guarded-queries/report.pdf rel=noopener>project report</a>):</p><ul><li>We have <em>shortcutting chase trees</em> as tree-like universal models which can be semicomputed (i.e. computed upto a certain depth) without backtracking. $\mathrm{GSat}$ is an important underlying step here as it essentially <em>precomputes by resolution</em> all backtracking steps required to perform chase proofs.</li><li>As the shortcutting chase tree is tree-like, we can construct tree automatons that recognize (the implicit-equality-coded tree-code of) finite subgraphs of the shortcutting chase tree. In fact, we can decide if a local instance (with some partial binding from query variables to active local names) entails a (<em>connected</em>) subquery by checking whether the language $L(\mathcal{A}_\mathrm{query} \times \mathcal{A}_\mathrm{chase})$ is nonempty (since any $T \in L(\mathcal{A}_\mathrm{query} \times \mathcal{A}_\mathrm{chase})$ corresponds to a valid chase proof from the root instance to the query), where<ul><li>$\mathcal{A}_\mathrm{query}$ is the <em>query automaton</em>, which is a (top-down-)nondeterministic tree automaton where a state is a triple of<ul><li>a yet-to-be-satisfied part of the subquery,</li><li>the current local instance (i.e. the local instance that the automaton last saw as it is descending the tree), and</li><li>the local name bindings from free-variables of the subquery to local names active in the current local instance.
The automaton</li><li>requires (by falling into the sink state if the condition is not met) that no local name bound by a variable is &ldquo;dropped&rdquo; (i.e. <em>stop appearing</em> in the local instance) during the chase step, and</li><li>nondeterministically <em>commits</em> a nonempty subset of existentially quantified variables (that are not yet bound to local names) to the active local names at the current node, subject to conditions that:<ul><li>all <em>newly fully-committed atoms</em> must appear in the current local instance,<ul><li>where an atom $A_i$ is <em>newly fully-committed</em> in the subquery $Q = \exists \vec{z}. \bigwedge_{j \in J} A_i$ (where each $A_j$ contains at least one bound variable) upon a commit $\sigma: (\mathrm{Vars}(Q) \setminus \mathrm{FV}(Q)) \rightharpoonup \mathrm{ActiveLocalNames}(\mathcal{I})$ if $\mathrm{Vars}(A_i) \setminus \mathrm{FV}(Q) \subseteq \mathrm{dom}(\sigma)$.</li></ul></li><li>after the commit has been made, the query in the state is split into queries induced by connected components of yet-to-be-bound quantified variables, and each component is nondeterministically allocated a subtree of the input tree to further check subquery entailment.</li></ul></li></ul></li><li>$\mathcal{A}_\mathrm{chase}$ is the <em>chase automaton</em>, which is a (bottom-up-)deterministic tree automaton that checks whether the input tree is a fragment of the shortcutting chase tree of the root instance. More precisely, $\mathcal{A}_\mathrm{chase}$ has the current instance (as in $\mathcal{A}_\mathrm{query}$) as a state, and</li><li>$\mathcal{A}_\mathrm{query} \times \mathcal{A}_\mathrm{chase}$ is the product automaton.</li></ul></li></ul><p>The important observation is that the state space of $\mathcal{A}_\mathrm{query}$ is partially ordered (by reachability) and is well-founded: a subquery in the state of $\mathcal{A}_\mathrm{query}$ either remains the same (when $\mathcal{A}_\mathrm{query}$ thinks that no commit should happen), or is split into multiple smaller subqueries whenever $\mathcal{A}_\mathrm{query}$ decides to commit a nonempty subset of bound variables in the original subquery.</p><p>This partial order carries over to the product automaton $\mathcal{A}_\mathrm{query} \times \mathcal{A}_\mathrm{chase}$ as a preorder (again, by reachability) that is &ldquo;fintely stratified&rdquo; by the partial and well-founded ordering of states from $\mathcal{A}_\mathrm{query}$.</p><p>Our first implementation was based on the idea that we can keep running the foward-reachability test from the &ldquo;bottom layer&rdquo; of $\mathcal{A}_\mathrm{query}$, thereby first enumerating all &ldquo;good&rdquo; instances with respect to smaller subqueries, and then inductively going up the layer (which corresponds to increasing the subquery size) to find all good instances with respect to all subqueries. When a subquery is fixed, we only need to decide the set of instances that can be chased down to a &ldquo;splitting point&rdquo;, so the problem is more like deciding the set of letters within the alphabet that leads to an accepting state of a deterministic word automaton (because $\mathcal{A}_\mathrm{chase}$ is a deterministic automaton, and while $\mathcal{A}_\mathrm{query}$ <em>stays</em> at a particular state, the product automaton is constrained to only accept a linear tree, therefore under this setting, $\mathcal{A}_\mathrm{chase}$ <em>really does behave like</em> a deterministic word automaton).</p><a href=#how-about-using-backward-reachability-tests-then><h2 id=how-about-using-backward-reachability-tests-then><span class=hanchor arialabel=Anchor># </span>How about Using Backward Reachability Tests, then?</h2></a><p>(TODO; write on why we initially rejected the idea, why the forward reachability approach workded to a certain extend and finally write how we could possibly exploit the stratified structure of $\mathcal{A}_\mathrm{query}$ to perform the backward reachability test, similar to how we exploited the structure in the forward reachability test)</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Ryosuke Kondo using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2023</p><ul><li><a href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/>Home</a></li><li><a href=https://twitter.com/Kory__3>Twitter</a></li><li><a href=https://github.com/kory33>Github</a></li></ul></footer></div></div></body></html>