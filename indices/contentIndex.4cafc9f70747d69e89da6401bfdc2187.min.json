{"/":{"title":"Optimized Reasoning with Guarded Logic","content":"\nThis is the personal vault of Ryosuke Kondo filled with both random and organized notes concerning my fourth year project `\"Optimized Reasoning with Guarded Logic\"`.\n\n## About the Project\n\nThe aim of the project is to solve the \"open world querying problem\" in case of existential conjunctive queries together with a finite collection of Guarded Tuple Generating Dependencies (GTGDs) set as axioms.\n\nThe problem in the case of atomic queries has been solved by [`Rewriting the Infinite Chase`](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf) by means of rewriting the given set of GTGD rules to Datalog rules. This project tries to extend this result to binary (or possibly, general) conjunctive queries.\n\nSee [[Rewriting, Existential Lifting and Saturation]] for concepts involved.\n\n## Internal Links\n\n### References\n\n - [[Papers]] (summarises papers that I think will be useful at some point)\n\n### Thoughts\n\nSome random thoughts regarding the project.\n\n - [[2022-11-01 About template constraints]]\n\n### Notes\n\nA collection of more structured notes.\n\n - Definitions:\n\t - Every other notes (should) depend on definitions given in this folder. The definition are organized into a DAG that starts from [[General Notations]].\n - [[Decomposing the Larger Problem into Smaller Subproblems]]\n\n## External Links\n\n - [Project Handbook 2022](https://www.cs.ox.ac.uk/teaching/courses/projects/handbook/Project%20Handbook%202022.pdf)\n\n## Meta Information\n\nContents of this repository is mainly authored on Kondo's machine using [Obsidian](https://obsidian.md), git-managed and then synchronized to a git repository [hosted on GitHub](https://github.com/kory33/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic).\n","lastmodified":"2022-11-09T05:34:06.081442759Z","tags":null},"/notes/Decomposing-the-Larger-Problem-into-Smaller-Subproblems":{"title":"Decomposing the Larger Problem into Smaller Subproblems","content":"\n\u003e We shall build on definitions given in [[Chase-Like Trees and Saturated Chase-Like Trees]].\n\nWe first make the following claim:\n\nClaim 1(Completeness and Soundness of saturated chase-like trees). For any finite set of GTGDs $\\Sigma$, a base instance $I$ and a conjunctive query $Q$, $$I \\wedge \\Sigma \\models Q\\Longleftrightarrow \\TreeFacts(\\SatTree_\\Sigma(I)) \\text{ witnesses } Q.$$\n","lastmodified":"2022-11-09T05:34:06.081442759Z","tags":null},"/notes/definitions/Chase-Like-Trees-and-Saturated-Chase-Like-Trees":{"title":"Chase-Like Trees and Saturated Chase-Like Trees","content":"\n\u003e This note builds on [[Rewriting, Existential Lifting and Saturation]]\n\nWe shall define a tree structure that \"stems from a base instance $I$ and witnesses every possible conclusion that can be $\\Sigma$-deduced from $I$\". To make this precise, we define a few concepts in this section. So fix a finite set $\\Sigma$ of head-normal GTGDs.\n\nWe say that _a set $G$ of factual terms is $\\Sigma$-guarded by a set of factual terms $\\vec{t}$_ when $G \\subseteq \\consts(\\Sigma) \\cup \\vec{t}$ .\n\nInjective functions of the form $\\nu: \\mathbb{N} \\rightarrow \\Nulls$ will be referred to as *null-picking functions*. For a null-picking function $\\nu$, a vector $\\vec{y} = (y_1, \\ldots, y_n)$ of variables and a factual substitution $\\sigma$ whose domain is disjoint from $\\vec{y}$, we define *the factual substitution $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls]$* with domain $\\domain(\\sigma) + \\elems(\\vec{y})$ that substitutes each $y_i$ to distinct nulls (chosen by $\\nu$) and follows $\\sigma$ elsewhere: $$\n\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](x)=\n\\begin{cases}\n    n_{\\nu(i)} \u0026 \\text{if $x = y_i$} \\\\\n    \\sigma(x) \u0026 \\text{if $x \\in \\domain(\\sigma)$}\n\\end{cases}$$\n\nFor a TGD $D = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$, an instance $I$ and a factual substitution $\\sigma$ that covers $\\vec{x}$, we say that *$I$ can be $D$-chased with $\\sigma$* when $\\sigma(\\beta) \\subseteq I$. Intuitively, this means that the premise $\\beta$ is witnessed by some facts in $I$, and $\\sigma$ specifies which constant or null appearing in $I$ is witnessing each variable in $\\vec{x}$.\n\nWe shall describe how an instance can be \"extended\" by applying a GTGD. (*Question: this is not a proper extension of $I$ because we are only taking along $\\Sigma$-guarded facts to the \"extension\". Is there any intuition why we should we do this, or is this just a technical trick that is used to bound the size of tree-like chase proofs so as to make the decision procedure decidable? Will I get an insight about the intuition behind this limitation if I read the proof of chase-proof completeness?*) Given a null-picking function $\\nu$, a GTGD $D = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ and an instance $I$ that can be $D$-chased with a factual substitution $\\sigma$, we define\n - *the chase head $\\chaseHead_\\nu(D, \\sigma)$* to be the fact $$\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta).$$ Intuitively, this is a new fact generated from $I$ by applying the rule $D$.\n - *the one-step chase $\\chase_\\nu(I; D, \\sigma)$ of $I$ with $(D, \\sigma)$ (through $\\nu$)* to be an instance defined by  $$\\set{\\chaseHead_\\nu(D, \\sigma)} \\cup \\set{\\ F \\in I\\ |\\ F \\text{ is } \\Sigma \\text{-guarded by }\\chaseHead_\\nu(D, \\sigma) \\ }.$$\n\nA *chase-like tree $T$ on an instance* is a directed rooted tree $(T_0, v_r)$ together with the *instance assignment* $\\operatorname{Instance}_T: V(T_0) \\rightarrow \\Instances$ of instances to vertices.\n\nFor a chase-like tree $T$ with the instance assignment $\\operatorname{Instance}_T$, we define the instance $\\TreeFacts(T)$ as the union $\\bigcup \\mathrm{im} \\operatorname{Instance}_T$ of image of the instance assignment.\n\n\nWe shall call a pair $(D, \\sigma) \\in \\Sigma \\times \\FactualSubstitutions$ a *chase-step direction*, and write $\\ChaseStepDir$ for the set $\\Sigma \\times \\FactualSubstitutions$ of all chase-step directions. We call a finite (resp. infinite) sequence of chase-step directions a *finite (resp. infinite) chase-path*.\n\n---\nTODO: we also need to encode \"the choice of facts that we take along $(D, \\sigma)$ when applying the chase step\", otherwise (I think) we can't quite argue about what we are trying to.\n\n---\n\nFix a coding function (hence a computable injection into $\\mathbb{N}$) $$\\#: \\ChaseStepDir^{\u003c \\omega} \\times \\mathbb{N} \\rightarrow \\mathbb{N}$$ on pairs of a finite chase-path and a natural. Precompose $\\#$ to the canonical null-picking function $\\nu_{\\mathrm{id}}(i \\in \\mathbb{N}) = n_i$ and curry to obtain a $\\ChaseStepDir^{\u003c \\omega}$-indexed family $\\set{ \\widehat{\\#_\\vec{d}}}_{\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}}$ of null-picking functions: More explicitly, for each $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, we have $$\n\\begin{align}\n\\widehat{\\#_{\\vec{d}}} : \\mathbb{N} \u0026 \\rightarrow \\Nulls\\\\\n                                   i \u0026 \\mapsto n_{\\#(\\vec{d}, i)}\n\\end{align}\n$$\nThis family of null-picking functions will be used in the following definition to formally ensure that no null introduced in one branch is brought to its sibling branches.\n\nGiven a base instance $I$, define, by induction on finite chase-paths $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, the *canonical completion $\\operatorname{CC}_\\vec{d}(I)$ of $I$ along $\\vec{d}$* by $$\n\\begin{align}\n  \\operatorname{CC}_{()}(I) \u0026= \\FullSat_\\Sigma(I) \\\\\n  \\operatorname{CC}_{\\vec{d} \\concat (D, \\sigma)}(I) \u0026=\n    \\begin{cases}\n      \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{CC}_\\vec{d}(I); D, \\sigma)) \u0026 \\text{if $\\operatorname{CC}_\\vec{d}(I)$ can be $D$-chased with $\\sigma$} \\\\\n      \\emptyset \u0026 \\text{otherwise}\n    \\end{cases}\n\\end{align}\n$$\nFor a base instance $I$ and a finite chase-path $\\vec{d}$, we say that $\\vec{d}$ is *a valid chase-path on $I$* if either $\\operatorname{CC}_\\vec{d}(I) \\neq \\emptyset$ or both $I$ and $\\vec{d}$ are empty.\n\nNow define the *$\\Sigma$-saturated chase-like tree $\\SatTree_\\Sigma(I)$ of a base instance $I$* with:\n - the set $(\\ChaseStepDir^{\u003c \\omega})_{\\mathrm{valid}}$ of *all* valid chase-paths on $I$ as the vertex set\n - (labelled) edges of the form $\\vec{p} \\xrightarrow{d} \\vec{p} \\concat (d)$ for each pair of vertices (hence valid chase-paths) $\\vec{p}$ and $\\vec{p} \\concat (d)$\n - the instance assignment function defined by $$\n\\begin{array}{c c}\n\\operatorname{Instance}_{\\SatTree_\\Sigma(I)}:\n  \u0026(\\ChaseStepDir^{\u003c \\omega})_{\\mathrm{valid}} \u0026 \\longrightarrow \u0026\\Instances \\\\\n  \u0026\\vec{d} \u0026\\longmapsto \u0026\\operatorname{CC}_\\vec{d}(I)\n\\end{array}\n$$\n","lastmodified":"2022-11-09T05:34:06.081442759Z","tags":null},"/notes/definitions/General-Notations":{"title":"General Notations","content":"\nMathJax macros: $$\\def\\elems{{\\operatorname{elems}}}$$\n\n\u003e This section defines general notations used throughout the notes.\n\nFor a formal finite sequence $(X_1, \\ldots, X_n)$ of same sorts, we abbriviate it as $\\vec{X}$. The set $\\set{\\ X_1, \\ldots, X_n\\ }$ will then be denoted as $\\elems(\\vec{X})$. We write $\\vec{X'} \\triangleleft \\vec{X}$ to mean that $\\vec{X'}$ is an initial segment of $\\vec{X}$, $\\vec{X'} \\leq \\vec{X}$ to mean that $\\vec{X'}$ is a subsequence of $\\vec{X}$ and $X' \\subseteq X$ to mean $\\elems(\\vec{X'}) \\subseteq \\elems(\\vec{X})$.\n\nFor two formal finite sequences $\\vec{X}$ and $\\vec{Y}$, we denote by $\\vec{X} \\concat \\vec{Y}$ the concatenation of $\\vec{X}$ and $\\vec{Y}$.\n\nA pair $(T, v_r)$ of a directed acyclic graph $T$ and a vertex $v_r \\in V(T)$ is called a *directed tree rooted at $v_r$* if the underlying undirected graph of $T$ is a tree and every $v \\in V(T) \\setminus \\set{v_r}$ has precisely one vertex $p_v \\in V(T)$ such that there is an edge $(p_v, v) \\in E(T)$. We shall often call $T$ a *rooted tree*.\n\nWe write $f: A \\rightharpoonup B$ to mean that $f$ is a partial function from $A$ to $B$. We denote by $\\domain(f)$ to mean the domain of $f$, and write $\\isDefinedAt{f}{x}$ to mean that $x \\in dom(f) \\subseteq A$, i.e. $f$ is defined at $x \\in A$.","lastmodified":"2022-11-09T05:34:06.081442759Z","tags":null},"/notes/definitions/Logic-Preliminaries":{"title":"Logic Preliminaries","content":"\n\u003e This note builds on [[General Notations]].\n\nThis note mainly pulls definitions from [Rewriting the Infinite Chase](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf), but with quite a lot of modifications.\n\nWe assume the countably infinite collection $\\Vars = \\set{x_1, x_2, x_3, \\ldots}$ of variables, the ordered set $\\Nulls = \\set{\\ n_i \\mid i \\in \\mathbb{N}\\ }$ of *labelled nulls* and some given fixed (at most countable) set $\\Consts = \\set{c_1, c_2, \\ldots}$ of constants.\n\nGiven a finite collection $\\Predicates = \\set{P_1, P_2, \\ldots, P_N}$ of predicates with finite arities $\\Arity(P_i)$ associated to each of them (both of which we will not explicitly write from now on), we define:\n - *the set $\\Terms$ of (non-null) terms* as $\\Vars \\cup \\Consts$\n - *the set $\\NullableTerms$ of nullable terms* as $\\Vars \\cup \\Consts \\cup \\Nulls$\n - _the set $\\FactualTerms$ of factual terms_ as $\\Nulls \\cup \\Consts$\n - _the set $\\Atoms$ of atomic formulae (resp. the set $\\Facts$ of facts)_ to be a set of formal expression $P(t_1, t_2, \\ldots, t_{\\Arity(P)})$ with $P \\in \\Predicates$, $t_i \\in \\Terms$ (resp. $\\FactualTerms$) for each $1 \\leq i \\leq \\Arity(P)$\n - *the set $\\Formulae$ of (first-order) formulas under the sigunature $(\\Predicates, \\Consts)$* to be a set of formal expressions inductively built up from $\\Atoms$ using unary connective $\\neg$, binary connectives $\\wedge, \\vee, \\rightarrow$ and quantifiers $\\exists x.$ and $\\forall x.$ (where $x \\in \\Vars$)\n\nSemantics (interpretation, logical-consequence relation and truth) of formulae is defined using the standard terminology. We also follow standard conventions concerning variables being *bound* and *free*.\n\nFor brevity, we adopt the following notational conventions:\n  - for a an atomic formula $P(t_1, \\ldots, t_{\\Arity(P)})$, we simply write it as $P(\\vec{t})$ with an intention that $\\vec{t} = (t_1, \\ldots, t_{\\Arity(P)})$.\n  - for a formula of a form $\\exists x_1. \\exists x_2. \\ldots \\exists x_n. \\phi$, we simply write it as $\\exists \\vec{x}. \\phi$ with an intention that $\\vec{x} = (x_1, \\ldots, x_n)$.\n\nFor conjunctions $F = \\bigwedge_{1 \\leq i \\leq n} F_i$ and $G = \\bigwedge_{1 \\leq j \\leq m} G_j$ of formulae, we write $F \\subseteq G$ when for each $1 \\leq i \\leq n$, $F_i$ appears in $G$. That is, for each $1 \\leq i \\leq n$, there exists $1 \\leq j \\leq m$ with $F_i = G_j$.\n\nWe now define subclasses of objects defined above:\n  - a fact $P(\\vec{t})$ is *a base fact* if $\\vec{t}$ contains only constants (hence no nulls). We write $\\BaseFacts$ for the set of base facts.\n  - *an instance* is a finite set of facts. We write $\\Instances$ for the set $\\mathcal{P}_{\u003c \\omega}(\\Facts)$.\n  - an instance $I$ is *a base instance* if each fact in $I$ is a base fact.\n  - a formula is *a rectified formula* if no variable is bound twice, and no variable occurs both bound and free. By a standard renaming argument, any first-order formula is equivalent to a rectified formula. Hence from now on we will assume all formulae to be rectified.\n  - a formula is closed when every occurence of variable is bound.\n  - a closed formula is a *Tuple-Generating Dependency (or TGD)* if it is of the form $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ where $\\beta$ and $\\eta$ are conjunctions of atoms with $\\eta$ nonempty. In such a formula, $\\beta$ is referred to as the *body* and $\\eta$ is referred to as the *head* of this TGD.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is *a full TGD* if $\\vec{y}$ is empty, i.e. it is of the form $\\forall \\vec{x}. \\beta \\rightarrow \\eta$.\n  - a full TGD is *a Datalog rule* if its head contains exactly one atom. A finite set of Datalog rules is is called *a Datalog program*.\n  - a TGD is in a head-normal form if it is either a *Datalog rule*, or each atom in the head contains at least one existentially quantified variable.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is a *guarded-TGD (or GTGD)* if $\\beta$ contains an atom $P(\\vec{t})$ such that $\\vec{t} \\supseteq \\vec{x}$.\n  - a Conjunctive Query (CQ) is a formula of the form $\\exists \\vec{x}. \\bigwedge_i A_i$ where each $A_i$ is an atomic formula.\n\nWe say that a Datalog program $\\Sigma_\\rew$ is a *Datalog rewriting* of a finite collection $\\Sigma$ of GTDGs when for every base instance $I$ and a base fact $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_\\rew \\models F.$$\nA *factual substitution* is a partial function $\\sigma: \\Vars \\rightharpoonup \\FactualTerms$ with a finite domain. A factual substitution canonically extends to a partial function $\\Atoms \\rightharpoonup \\Facts$ that is defined on atoms all of whose variables are in the domain of $\\sigma$. We identity this extension of $\\sigma$ with $\\sigma$ by an abuse of notation. We write $\\FactualSubstitutions = (\\Vars \\rightharpoonup \\FactualTerms)_{\u003c \\omega}$ for the countable set of all factual substitutions.\n\nWe say that a factual substitution $\\sigma$ *covers* a set $\\vec{y}$ of variables when $\\elems(\\vec{y}) \\subseteq \\domain(\\sigma)$, and that $\\sigma$ *covers* an atom $A$ (resp. a vector of atoms $\\vec{A}$) when $\\sigma$ covers the set $\\vars(A)$ (resp. $\\vars(\\vec{A})$) of variables in $A$ (resp. $\\vec{A}$).\n\nWe say that a (potentially infinite) set $\\mathcal{F}$ of facts *witnesses a closed conjunctive query $\\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$* if there exists a factual substitution $\\sigma$ covering $\\vec{A}$ such that $$\\set{\\ \\sigma(A_i) \\mid 1 \\leq i \\leq n \\ } \\subseteq \\mathcal{F}.$$","lastmodified":"2022-11-09T05:34:06.081442759Z","tags":null},"/notes/definitions/Rewriting-Existential-Lifting-and-Saturation":{"title":"Rewriting, Existential Lifting and Saturation","content":"\n\u003e This note builds on [[Logic Preliminaries]]\n\nGiven a set $\\Sigma$ of TGDs, a Datalog program $\\Sigma_{\\text{rew}}$ is *a rule-rewriting of $\\Sigma$* if for every base instance $I$, $\\Sigma$ and $\\Sigma_{\\text{rew}}$ generate the same set of consequences, i.e. for every __base fact__ $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_{\\text{rew}} \\models F.$$\n\nIf we also have a conjunctive query $Q$, we say that a Datalog program $\\Sigma^Q_\\rew$ together with a fresh *0-ary goal predicate* $\\mathrm{Goal^Q}()$ is a *query-rule-rewriting of $(\\Sigma, Q)$* if for every base instance $I$, $$I \\wedge \\Sigma \\models Q \\Longleftrightarrow I \\wedge \\Sigma^Q_\\rew \\models \\mathrm{Goal^Q}() $$\n\nGiven a fact $R(\\vec{f})$, the *existential lifting $\\exlift(R(\\vec{f}))$ of $R(\\vec{f})$* is defined as the formula $$\\exlift(R(\\vec{f})) := \\exists \\vec{\\nu}. R(\\vec{f}[\\ \\vec{n} \\leftarrow \\vec{\\nu}\\ ])$$\nwhere\n - $\\vec{\\nu}$ are variables corresponding to nulls in $\\vec{f}$,\n - $\\vec{f}[\\ \\vec{n} \\leftarrow \\vec{\\nu}\\ ]$ is $\\vec{f}$ with nulls replaced by their corresponding variables in $\\vec{\\nu}$. \n\nThe *existential lifting $\\exlift(I)$ of an instance $I$* is a set $\\set{\\ \\exlift(F) \\mid F \\in I\\ }$ of formulae.\n\nGiven a Datalog program $\\Sigma$ and an instance $I$, we define the *$k$-th partial Datalog-saturation $\\Sat^k_\\Sigma(I)$ of $I$ by $\\Sigma$* by induction on $k \\in \\mathbb{N}$, by $$\\begin{align}\n  \\Sat^0_\\Sigma(I) \u0026= I \\\\\n  \\Sat^{k + 1}_\\Sigma(I) \u0026= \\Sat^k_\\Sigma(I) \\cup \\set{\\ \\sigma(\\eta) \\mid (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma, \\sigma \\text{ covers } \\vec{x}, \\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)\\ }\n\\end{align}$$\nWe define the *Datalog saturation $\\Sat_\\Sigma(I)$ of $I$ by a Datalog program $\\Sigma$* as $$\\Sat_\\Sigma(I) = \\bigcup_{k \\in \\mathbb{N}} \\Sat^k_\\Sigma(I)$$\nMore generally, for an arbitrary finite collection $\\Sigma$ of GTDGs and an instance $I$, we define *the full saturation $\\FullSat_\\Sigma(I)$ of $I$ by $\\Sigma$* as $$\\FullSat_\\Sigma(I) = \\Sat_{\\Sigma_\\rew}(I)$$ for *some* rule-rewriting $\\Sigma_\\rew$ of $\\Sigma$. This definition is well-defined, since any two Datalog rewritings produce the same Datalog saturation by definition. ","lastmodified":"2022-11-09T05:34:06.081442759Z","tags":null},"/references/Papers":{"title":"Papers","content":"\n## `Rewriting the Infinite Chase`\n\nLink: [latest version on GitHub pages](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf)\n\nTODO: write down the ideas that are explored in this paper\n\n## `A general Datalog-based framework for tractable query answering over ontologies`\n\nLink: [ScienceDirect](https://www.sciencedirect.com/science/article/pii/S1570826812000388)\n\nTODO: write down the ideas that are explored in this paper\n","lastmodified":"2022-11-09T05:34:06.081442759Z","tags":null},"/thoughts/2022-11-01-About-template-constraints":{"title":"2022-11-01 About template constraints","content":"\n## Constraints on Partitioning Imposed by the Query\n\nSuppose that the following query is given as $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$.\n\nThere are a few ways this query could be witnessed by nulls in an infinite branch of the tree-like chase (a.k.a. \"tentacles\") or by constants in the collection of input or saturated facts (a.k.a. \"squid head\"). The following is an exhaustive list of all possible combinations:\n - 0 variable in the squid head\n\t - all of $x, y, z$ get witnessed in the same tentacle\n - 1 variable in the squid head\n\t - $x$ gets witnessed in the head and $y, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in different tentacles\n\t - $z$ gets witnessed in the head and $x, y$ get witnessed in the same tentacle\n - 2 variables in the squid head\n\t - $x$ and $y$ get witnessed in the head and $z$ gets witnessed in a tentacle\n\t - $x$ and $z$ get witnessed in the head and $y$ gets witnessed in a tentacle\n\t - $y$ and $z$ get witnessed in the head and $x$ gets witnessed in a tentacle\n - 3 variables in the squid head\n\t - All of $x, y, z$ get witnessed in the squid head\n\nThere are two impossible combinations, namely:\n\n - `x` gets witnessed in the head and $y$ and $z$ get witnessed in _different_ tentacles\n - `z` gets witnessed in the head and $y$ and $x$ get witnessed in _different_ tentacles\n\nTo see why, suppose $y$ and $z$ are instantiated as nulls $n_1$ and $n_2$ in _different tentacles_. Then there is nowhere in the infinite tree-like chase structure that proves $R(n_1, n_2)$, which uses $n_1$ and $n_2$ at the same time. So we conclude that: _if_ $y$ and $z$ are to be instantiated with nulls, _then_ that must be happen on the same tentacle.\n\nGeneralising the example above, we can see that: if the query contains an atom $P(\\vec{u})$ within the existential, then every vector witnessing $\\vec{u}$ in $P(\\vec{u})$ always have all the nulls appear in the single tentacle.\n\nSo we can deduce to a certain extent how the instantiation of variables may be distributed to different tentacles by just looking at the query.\n\n## Constraints Imposed by the Reasoning Rules\n\nIn this section, we shall write $\\Sigma$ for the generic set of rules.\n\nWhen a pseudoquery is proven in a tentacle of the infinite chase, one might imagine the following situation:\n\n![[Pasted image 20221101171150.png]]\n\nHowever, this diagram needs a slight modification: we will always get a set different from $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$ in the $i$-th step of this short-cut proof. This is because we cannot salvage atoms that are not facts (i.e. ones containing nulls) from branches steming from $I_i$. So on top of $I_i$, we are only going to add ***base facts*** that are derived from $I_i$ using $\\Sigma$ (my guess is that this is in general not even a subset of $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$; is this true?). So we wrill write fact-saturated sets of $I_i$ with $\\Sigma$ as $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_i)$.\n\nAlso, by splitting the pseudoquery we can assume that a pseudoquery is realized in $I_n$ as oppsed to $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_n)$, since if we are assuming all variables in an atom $F(\\vec{t})$ to be realized in the squid head, we may treat $F(\\vec{t})$ as a separate query (TODO: this is really hand-wavy!).\n\nIn fact we will have something like the following:\n\n![[Pasted image 20221101171906.png]]\n\n","lastmodified":"2022-11-09T05:34:06.081442759Z","tags":null},"/thoughts/2022-11-09-Head-Tentacle-Partitions-and-Pseudo-Witnesses":{"title":"","content":"We explorered before in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]] a few possibility on how the entire query can be witnessed by nulls in different tentacles.\n\nLet us be more precise and formal.\n\n**Definition**. For a vector $\\vec{x}$ of distinct variables, we say that a pair $(H, \\mathcal{T})$ is a _head-tentacle partition of $\\vec{x}$_ when\n - $H \\subseteq \\elems(\\vec{x})$ and $\\mathcal{T} \\subseteq \\mathcal{P}(\\elems(\\vec{x}))$\n - $H \\not\\in \\mathcal{T}$\n - Either\n\t - $H = \\emptyset$ and $\\mathcal{T}$ is a partition (i.e. a cover of disjoint nonempty sets) of $\\elems(\\vec{x})$\n\t - $\\set{H} \\cup \\mathcal{T}$ is a partition of $\\elems(\\vec{x})$\n\n**Definition**. For a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$, define the corresponding _compatible cover_ $(H, \\mathcal{T})_\\text{cover}$ as the set $\\set{ H \\cup T \\mid T \\in \\mathcal{T} }$.\n\n**Definition**. Given a boolean conjunctive query $$Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i(\\vec{v_i})$$ we say that a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$ is _compatible with $Q$_ if, for every $1 \\leq i \\leq n$ and every $x_1, x_2 \\in \\elems(\\vec{v_i})$, there exists $C \\in (H, \\mathcal{T})_\\text{cover}$ such that $\\set{x_1, x_2} \\subseteq C$.\n\n**Definition**. For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$, the _witness pattern $\\mathrm{Pat}_\\sigma$ of $\\sigma$_ is the head-tentacle paritition $(H, \\mathcal{T})$ defined by $$\\begin{align}\nH \u0026= \\set{ x \\in \\elems(\\vec{x}) \\mid \\sigma(x) \\text{ is a constant}} \\\\\nT \u0026= (\\elems(\\vec{x}) \\setminus H) / \\sim\n\\end{align}$$ where $\\sim$ is the equivalence relation given by $x_1 \\sim x_2$ iff $\\sigma(x_1)$ and $\\sigma(x_2)$ appear in the same tentacle (TODO: define this precisely; it should be easy thanks to the explicit construction of $\\SatTree_\\Sigma(I)$).\n\n**Claim**:  For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$ (TODO: define notions so that this statement can be shortened), $\\mathrm{Pat}_\\sigma$ is compatible with $Q$.\n\n---\nNow that we defined notions, we can say the same thing as in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]], but more concisely:\n\nFor a query $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$, the following are the only head-tentacle partitions compatible with $Q$:\n - $(\\emptyset, \\set{\\set{x, y, z}})$\n - $(\\set{x}, \\set{\\set{y, z}})$\n - $(\\set{y}, \\set{\\set{x, z}})$\n - $(\\set{y}, \\set{\\set{x}, \\set{z}})$\n - $(\\set{z}, \\set{x, y})$\n - $(\\set{x, y}, \\set{\\set{z}})$\n - $(\\set{x, z}, \\set{\\set{y}})$\n - $(\\set{y, z}, \\set{\\set{x}})$\n - $(\\set{x, y, z}, \\emptyset)$\n\nLet us tinker with this example.\n\n**Question.** Given a finite set $\\Sigma$ of GTGDs, is $$\n\\left(\n\\Sigma \\cup \\left\\{\n  \\begin{aligned}\n  \u0026 \\forall u, v. R(u, v) \\rightarrow \\mathrm{Subgoal}_\\mathrm{left}(v), \\\\\n  \u0026 \\forall v, w. R(v, w) \\rightarrow \\mathrm{Subgoal}_\\mathrm{right}(v), \\\\\n  \u0026 \\forall v. \\mathrm{Subgoal}_\\mathrm{left}(v) \\wedge \\mathrm{Subgoal}_\\mathrm{right}(v) \\rightarrow \\mathrm{Goal}^Q() \\\\\n\\end{aligned}\n\\right\\}\n\\right)_\\mathrm{rew}\n$$ a query-rule-rewriting of $(\\Sigma, Q)$?\n\n**Answer**: For each possible head-tentacle partition, we can \"enrich\" the $\\SatTree$ by added rules and see if $\\mathrm{Goal}^Q()$ can be derived using chase steps.","lastmodified":"2022-11-09T05:34:06.081442759Z","tags":null}}