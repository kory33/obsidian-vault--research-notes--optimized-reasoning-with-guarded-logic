{"/":{"title":"Optimized Reasoning with Guarded Logic","content":"\nThis is the personal vault of Ryosuke Kondo filled with both random and organized notes concerning my fourth year project `\"Optimized Reasoning with Guarded Logic\"`.\n\n## About the Project\n\nThe aim of the project is to solve the \"open world querying problem\" in case of existential conjunctive queries together with a finite collection of Guarded Tuple Generating Dependencies (GTGDs) set as axioms.\n\nThe problem in the case of atomic queries has been solved by [`Rewriting the Infinite Chase`](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf) by means of rewriting the given set of GTGD rules to Datalog rules. This project tries to extend this result to binary (or possibly, general) conjunctive queries.\n\nSee [[Rewriting, Existential Lifting and Saturation]] for concepts involved.\n\n## Internal Links\n\n### References\n\n - [[Papers]] (summarises papers that I think will be useful at some point)\n\n### Thoughts\n\nSome random thoughts regarding the project.\n\n - [[2022-11-01 About template constraints]]\n\n### Notes\n\nA collection of more structured notes.\n\n - Definitions:\n\t - Every other notes (should) depend on definitions given in this folder. The definition are organized into a DAG that starts from [[General Notations]].\n - [[Decomposing the Larger Problem into Smaller Subproblems]]\n\n## External Links\n\n - [Project Handbook 2022](https://www.cs.ox.ac.uk/teaching/courses/projects/handbook/Project%20Handbook%202022.pdf)\n\n## Meta Information\n\nContents of this repository is mainly authored on Kondo's machine using [Obsidian](https://obsidian.md), git-managed and then synchronized to a git repository [hosted on GitHub](https://github.com/kory33/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic).\n","lastmodified":"2022-11-17T05:56:35.094850503Z","tags":null},"/notes/Decomposing-the-Larger-Problem-into-Smaller-Subproblems":{"title":"Decomposing the Larger Problem into Smaller Subproblems","content":"\n\u003e We shall build on definitions given in [[Chase-Like Trees and Saturated Chase-Like Trees]]. We will also rely on the results in [[Preliminary Results about Saturated Chase-Like Trees]].\n\nWe start with the following claim, which we leave a detailed proof to some other part of the notes:\n\n\u003e **Claim 1(Universality of $\\SatTree$s)**. For any finite set of GTGDs $\\Sigma$, a base instance $I$ and a binary conjunctive query $Q$, $$I \\wedge \\Sigma \\models Q\\Longleftrightarrow \\TreeFacts(\\SatTree_\\Sigma(I)) \\text{ witnesses } Q$$\n\nFrom now on we shall write `AnswerQuery(I, Σ, Q)` for the problem of deciding where $I \\wedge \\Sigma \\models Q$ holds. We shall also consider the problem `WitnessedUnderSubTree(τ, σ, I, Σ, Q')`, which decides whether a binary conjunctive query `Q'` is witnessed on a subtree under the node $((\\tau, \\sigma))$ in $\\SatTree_\\Sigma(I)$.\n\nSuppose for now that $Q$ is given in a form $\\exists \\vec{x}. \\wedge_i Q_i(\\vec{x'}_i)$, where $\\vec{x'}_i \\subseteq \\vec{x}$ for each $i$.\n\nBy Claim 1, we can answer $I \\wedge \\Sigma \\models Q$ by finding a witness $(\\sigma, \\SatTree_\\Sigma(I))$ (or proving that none exists) for $Q$. Due to constraints on $\\sigma$ as described in [[Preliminary Results about Saturated Chase-Like Trees#^a87015]]), we can nondeterministically guess $\\consts(\\sigma)$ and how $\\sigma$ sends each connected component of $\\mathcal{H}(Q - \\consts(\\sigma))$ to different tentacles, and then verify that our guess was right by using the oracle for `WitnessedUnderSubTree(-, -, -, -, -)`.\n\nThis yields a nondeterministic algorithm [^1], which we shall refer to as `AnswerQueryNonDet1`, that reduces `AnswerQuery(I, Σ, Q)` to instances of `WitnessedUnderSubTree(τ, σ, I, Σ, Q')`:\n\n```\nAnswerQueryNonDet1(I, Σ, Q):\n  TODO\n```\n\n[^1]: In a sense of an algorithm running on nondeterministic turing machines, so `ACCEPT`s if *any* nondeterministic branch `ACCEPT`s, and `REJECT`s if *no* nondeterministic branch `ACCEPT`s.","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null},"/notes/Preliminary-Results-about-Saturated-Chase-Like-Trees":{"title":"Preliminary Results about Saturated Chase-Like Trees","content":"\n\u003e **Definition.** For chase-like tree $T$ and its vertex $v \\in T_0$, we say that $v$ *mentions* a factual term $t$ if $\\Instance_T(v)$ contains a fact $P(\\vec{t'})$ such that $t \\in \\elems(\\vec{t'})$.\n\n\u003e **Definition.** For a chase-like tree $T$ and a factual term $t$, the _subgraph of $T$ mentioning $t$_, denoted $T \\upharpoonright t$, is the subgraph of $T$ induced by the vertex set $V_t = \\set{v \\in T \\mid v \\text{ mentions } t }$ together with the instance assignment restricted to $V_t$, i.e. $\\Instance_{T \\upharpoonright t} = \\Instance_T \\upharpoonright V_t$ .\n\nWe can see that the subgraph of a $\\SatTree$ mentioning $t$ really is then a subtree sitting in the $\\SatTree$ as seen in the following proposition:\n\n\u003e **Proposition**. For a finite set $\\Sigma$ of GTGDs, a base instance $I$ and any factual term $t$, $\\SatTree_\\Sigma(I) \\upharpoonright t$ is connected. In particular, if $t$ is mentioned in $\\TreeFacts(\\SatTree_\\Sigma(I))$, then $\\SatTree_\\Sigma(I) \\upharpoonright t$ is a rooted subtree of $\\SatTree_\\Sigma(I)$.\n\u003e \n\u003e _Proof (sketch)_. By construction of $\\SatTree_\\Sigma(I)$, we have that\n\u003e  - a factual term not already mentioned in $I$ is never introduced by any chase-step direction from any node\n\u003e  - a null introduced at a node $\\vec{d}$ is never introduced anywhere else in the tree\n\nNow, for each factual term $t$ mentioned somewhere in the $\\SatTree$, we can identify where $t$ has been \"introduced\" in the tree:\n\n\u003e **Definition.** For a factual term $t$ mentioned in $\\TreeFacts(\\SatTree_\\Sigma(I))$, the *introduction point $\\Intro(t)$ of $t$* is the root node of the subtree $\\SatTree_\\Sigma(I) \\upharpoonright t$.\n\nClearly, $\\Intro(t)$ is the root node $()$ if and only if $t$ is a constant.\n\n\u003e **Proposition**. For a node $n$ of $\\SatTree_\\Sigma(I)$, its ancestor node $a$ and a fact $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(n)$, if $\\Intro(t) \\geq a$ for all $t \\in \\elems(\\vec{t})$, then $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(a)$.\n\u003e \n\u003e _Proof (sketch)_. TODO (is this even necessary? we'll see later)\n\n### Witness Decomposition\n\n^d79951\n\nNow, we shall see how a witness on $\\SatTree$ for a CQ is constrained. We begin with some preliminary definitions.\n\n\u003e **Definition**. For a boolean conjunctive query $Q$ and its witness $(\\sigma, \\mathcal{F})$, the *set of touchdowners* $\\touchDowners(\\sigma)$ of $\\sigma$ is the set $\\sigma^{-1}[\\consts(\\mathcal{F})]$ of variables that get sent to constants in $\\mathcal{F}$.\n\u003e \n\u003e **Examples**: ![[Pasted image 20221116200624.png]]![[Pasted image 20221116200657.png]] \n\n\u003e **Definition**. For a valid generative chase-path $((\\tau, \\sigma))$ on $I$, we define the *tentacle of $\\SatTree_\\Sigma(I)$ hanging from $(\\tau, \\sigma)$* to be the subtree of $\\SatTree_\\Sigma(I)$ induced by all descendants of the node $((\\tau, \\sigma))$.\n\n\u003e **Definition**. For a binary conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_i Q_i(\\vec{x'}_i)$, the *query structure hypergraph $\\mathcal{H}(Q)$* of $Q$ is the labelled hypergraph defined with\n\u003e  - the vertex set $V_Q = \\elems(\\vec{x})$\n\u003e  - for each $i$, a hyperedge named $Q_i$ that spans $\\elems(\\vec{x'}_i) \\subseteq V_Q$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_i Q_i(\\vec{x'}_i)$ and a subset $X$ of $\\elems(\\vec{x})$, the *$X$-blind query structure hypergraph*, denoted $\\mathcal{H}(Q-X)$, is the hypergraph obtained by weak-deleting [^1] all vertices in $X$.\n\nFirst we have the following proposition, which states that \"vertices adjacent in $\\mathcal{H}(Q - \\touchDowners(\\sigma))$ must be sent to nulls lying the same chase-path\":\n\n\u003e **Proposition**. For a binary conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$ and a witness $(\\sigma, \\SatTree_\\Sigma(I))$, if two variables $x_1$ and $x_2$ appear in a single atom $Q_j(\\vec{x'}_j)$ for some $j \\in J$, then $\\Intro(\\sigma(x_1))$ and $\\Intro(\\sigma(x_2))$ are $\\leq$-comparable.\n\u003e \n\u003e \u003e *Proof*. By assumption on $\\sigma$, there exists a node (i.e. a valid chase-path on $I$) $\\vec{d}$ such that $Q_j(\\sigma(\\vec{x'}_j)) \\in \\Instance_{\\SatTree_\\Sigma(I)}(n)$. Since both $\\SatTree_\\Sigma(I) \\upharpoonright \\sigma(x_1)$ and $\\SatTree_\\Sigma(I) \\upharpoonright \\sigma(x_2)$ are rooted subtrees containing $n$, both $\\Intro(\\sigma(x_1))$ and $\\Intro(\\sigma(x_2))$ are ancestors of $n$, so all of $\\set{ n, \\Intro(\\sigma(x_1)), \\Intro(\\sigma(x_2)) }$ lie on the same path in $\\SatTree_\\Sigma(I)$.\n\n^809307\n\nFrom this proposition, we can now deduce the *witness decomposition*, as described in the following lemma:\n\n\u003e **Lemma (Witness Decomposition)**. For a binary conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, a witness $(\\sigma, \\SatTree_\\Sigma(I))$ and a connected component $V$ of $\\mathcal{H}(Q - \\touchDowners(\\sigma))$, $\\sigma$ sends variables in $V$ to nulls whose introduction points all lie in the same tentacle of $\\SatTree_\\Sigma(I)$. ^a87015\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e The [previous proposition][[#^809307]] implies that, if two variables $x_1$ and $x_2$ are adjacent in $\\mathcal{H}(Q - \\touchDowners(\\sigma))$, then in particular they lie in the same tentacle.\n\u003e \u003e \n\u003e \u003e So take any two variables $x_1, x_2$ in $V \\in \\ConnComp(\\mathcal{H}(Q - \\touchDowners(\\sigma)))$. By connectedness of $V$, there exists a path $x_1 E_0 y_0 \\ldots y_{k-1} E_K x_2$ from $x_1$ to $x_2$. By induction on $k$, all of $y_0, \\ldots, y_{k-1}$ lie in the same tentacle in which $x_1$ is introduced, so $x_1$ and $x_2$ are introduced in the same tentacle.\n\n### Witness Gluing\n\nThe previous section on [Witness Decomposition][[#^d79951]] described how we can decompose a witness on $\\SatTree$s. In this section, we shall see the inverse operation that \"glues several fragmented witnesses\" into a single witness for a query.\n\nWe start with some definitions.\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ is *a base-factual substitution* if $\\operatorname{im} \\sigma \\subseteq \\Consts$, and that it is a *null-factual substitution* if $\\operatorname{im} \\sigma \\subseteq \\Nulls$.\n\n\u003e **Definition**. Given a finite set $\\Sigma$ of GTGDs, a base instance $I$ and a boolean conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, a *$(\\Sigma, I)$-fragmented substitution for $Q$* is a pair $(\\sigma_b, \\set{ \\sigma'_V }_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b))})$ such that\n\u003e  - $\\sigma_b$ is a base-factual substitution such that $\\domain(\\sigma_b) \\subseteq \\elems(\\vec{x})$\n\u003e  - for each $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$, $\\sigma'_V$ is a null-factual substitution with $\\domain(\\sigma'_V) = V$.\n\u003e\n\u003e We will often omit the indexing set of the family $\\set{\\sigma'_V}$.\n\n\u003e **Definition**. A $(\\Sigma, I)$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$ for $Q$ is said to be a *$(\\Sigma, I)$-fragmented witness for $Q$* if\n\u003e  - TODO (require that atoms contained in $\\touchDowners(\\sigma)$ are witnessed in the root of $\\SatTree$)\n\u003e  - TODO (require that each $\\sigma'_V$ takes $V$ to nulls whose tentacle witnesses all atoms contained in $V$)\n\n\u003e **Remark**. By construction, $(\\Sigma, I)$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$ for $Q$ is a *collection of compatible factual substitutions*, in a sense that $\\sigma_b \\not\\in \\set{\\sigma'_V}_V$, and for each pair $\\sigma_1, \\sigma_2$ of factual substitutions in the set $\\set{ \\sigma_b } \\cup \\set{ \\sigma'_V }_V$, $\\domain(\\sigma_1) \\cup \\domain(\\sigma_2) \\neq \\emptyset \\Longrightarrow \\sigma_1 = \\sigma_2$.\n\n\u003e **Definition**. By the previous remark, for a $(\\Sigma, I)$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$ for $Q$, the set-theoretic union $\\bigcup(\\set{ \\sigma_b } \\cup \\set{ \\sigma'_V }_V)$ is a well-defined factual substitution. We shall call this union the *gluing of $(\\sigma_b, \\set{\\sigma'_V}_V)$*, and denote it by $\\Glue(\\sigma_b, \\set{\\sigma'_V}_V)$.\n\n\u003e **Lemma (Witness Gluing)**. Suppose $(\\sigma_b, \\set{\\sigma'_V})$ is a $(\\Sigma, I)$-fragmented witness for $Q$. Then $(\\Glue(\\sigma_b, \\set{\\sigma'_V}_V), \\SatTree_\\Sigma(I))$ is a witness for $Q$.\n\u003e \n\u003e \u003e *Proof*. TODO; should be a routine.\n\n[^1]: see Ch. 7, [[Books#^327283]] for details","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null},"/notes/definitions/Chase-Like-Trees-and-Saturated-Chase-Like-Trees":{"title":"Chase-Like Trees and Saturated Chase-Like Trees","content":"\n\u003e This note builds on [[Rewriting, Existential Lifting and Saturation]]\n\nWe shall define a tree structure that \"stems from a base instance $I$ and witnesses every possible conclusion that can be $\\Sigma$-deduced from $I$\". To make this precise, we define a few concepts in this section. So fix a finite set $\\Sigma$ of head-normal GTGDs.\n\nWe say that _a set $G$ of factual terms is $\\Sigma$-guarded by a set of factual terms $\\vec{t}$_ when $G \\subseteq \\consts(\\Sigma) \\cup \\vec{t}$ .\n\nInjective functions of the form $\\nu: \\mathbb{N} \\rightarrow \\Nulls$ will be referred to as *null-picking functions*. For a null-picking function $\\nu$, a vector $\\vec{y} = (y_1, \\ldots, y_n)$ of variables and a factual substitution $\\sigma$ whose domain is disjoint from $\\vec{y}$, we define *the factual substitution $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls]$* with domain $\\domain(\\sigma) + \\elems(\\vec{y})$ that substitutes each $y_i$ to distinct nulls (chosen by $\\nu$) and follows $\\sigma$ elsewhere: $$\n\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](x)=\n\\begin{cases}\n    n_{\\nu(i)} \u0026 \\text{if $x = y_i$} \\\\\n    \\sigma(x) \u0026 \\text{if $x \\in \\domain(\\sigma)$}\n\\end{cases}$$\n\nFor a TGD $D = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$, an instance $I$ and a factual substitution $\\sigma$ that covers $\\vec{x}$, we say that *$I$ can be $D$-chased with $\\sigma$* when $\\sigma(\\beta) \\subseteq I$. Intuitively, this means that the premise $\\beta$ is witnessed by some facts in $I$, and $\\sigma$ specifies which constant or null appearing in $I$ is witnessing each variable in $\\vec{x}$.\n\nWe shall describe how an instance can be \"extended\" by applying a GTGD. (*Question: this is not a proper extension of $I$ because we are only taking along $\\Sigma$-guarded facts to the \"extension\". Is there any intuition why we should we do this, or is this just a technical trick that is used to bound the size of tree-like chase proofs so as to make the decision procedure decidable? Will I get an insight about the intuition behind this limitation if I read the proof of chase-proof completeness?*) Given a null-picking function $\\nu$, a GTGD $D = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ and an instance $I$ that can be $D$-chased with a factual substitution $\\sigma$, we define\n - *the chase head $\\chaseHead_\\nu(D, \\sigma)$* to be the fact $$\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta).$$ Intuitively, this is a new fact generated from $I$ by applying the rule $D$.\n - *the one-step chase $\\chase_\\nu(I; D, \\sigma)$ of $I$ with $(D, \\sigma)$ (through $\\nu$)* to be an instance defined by  $$\\set{\\chaseHead_\\nu(D, \\sigma)} \\cup \\set{\\ F \\in I\\ |\\ F \\text{ is } \\Sigma \\text{-guarded by }\\chaseHead_\\nu(D, \\sigma) \\ }.$$\n\nA *chase-like tree $T$ on an instance* is a directed rooted tree $(T_0, v_r)$ together with the *instance assignment* $\\operatorname{Instance}_T: V(T_0) \\rightarrow \\Instances$ of instances to vertices.\n\nFor a chase-like tree $T$ with the instance assignment $\\operatorname{Instance}_T$, we define the instance $\\TreeFacts(T)$ as the union $\\bigcup \\mathrm{im} \\operatorname{Instance}_T$ of image of the instance assignment.\n\n\nWe shall call a pair $(\\tau, \\sigma) \\in \\Sigma \\times \\FactualSubstitutions$ a *chase-step direction*, and write $\\ChaseStepDir$ for the set $\\Sigma \\times \\FactualSubstitutions$ of all chase-step directions. We call a finite (resp. infinite) sequence of chase-step directions a *finite (resp. infinite) chase-path*.\n\nWe say that a chase-step direction $(\\tau, \\sigma)$ is *generative* if $\\tau$ is a non-full rule, and that a chase-path $\\vec{d}$ is *generative* if each $(\\tau, \\sigma) \\in \\elems(\\vec{d})$ is generative.\n\nFix a coding function (hence a computable injection into $\\mathbb{N}$) $$\\#: \\ChaseStepDir^{\u003c \\omega} \\times \\mathbb{N} \\rightarrow \\mathbb{N}$$ on pairs of a finite chase-path and a natural. Precompose $\\#$ to the canonical null-picking function $\\nu_{\\mathrm{id}}(i \\in \\mathbb{N}) = n_i$ and curry to obtain a $\\ChaseStepDir^{\u003c \\omega}$-indexed family $\\set{ \\widehat{\\#_\\vec{d}}}_{\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}}$ of null-picking functions: More explicitly, for each $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, we have $$\n\\begin{align}\n\\widehat{\\#_{\\vec{d}}} : \\mathbb{N} \u0026 \\rightarrow \\Nulls\\\\\n                                   i \u0026 \\mapsto n_{\\#(\\vec{d}, i)}\n\\end{align}\n$$\nThis family of null-picking functions will be used in the following definition to formally ensure that no null introduced in one branch is brought to its sibling branches.\n\nGiven a base instance $I$, define, by induction on finite chase-paths $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, the *shortcut chase $\\operatorname{SC}_\\vec{d}(I)$ of $I$ along $\\vec{d}$* by $$\n\\begin{align}\n  \\operatorname{SC}_{()}(I) \u0026= \\FullSat_\\Sigma(I) \\\\\n  \\operatorname{SC}_{\\vec{d} \\concat (D, \\sigma)}(I) \u0026=\n    \\begin{cases}\n      \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{SC}_\\vec{d}(I); D, \\sigma)) \u0026 \\text{if $\\operatorname{SC}_\\vec{d}(I)$ can be $D$-chased with $\\sigma$} \\\\\n      \\emptyset \u0026 \\text{otherwise}\n    \\end{cases}\n\\end{align}\n$$\nFor a base instance $I$ and a finite chase-path $\\vec{d}$, we say that $\\vec{d}$ is *a valid chase-path on $I$* if either $\\operatorname{SC}_\\vec{d}(I) \\neq \\emptyset$ or both $I$ and $\\vec{d}$ are empty.\n\nNow define the *$\\Sigma$-saturated chase-like tree $\\SatTree_\\Sigma(I)$ of a base instance $I$* with:\n - the set $(\\ChaseStepDir^{\u003c \\omega})_{\\mathrm{valid, gen}}$ of *all* valid generative chase-paths on $I$ as the vertex set\n - (labelled) edges of the form $\\vec{p} \\xrightarrow{d} \\vec{p} \\concat (d)$ for each pair of vertices (hence valid , generative chase-paths) $\\vec{p}$ and $\\vec{p} \\concat (d)$\n - the instance assignment function defined by $$\n\\begin{array}{c c}\n\\operatorname{Instance}_{\\SatTree_\\Sigma(I)}:\n  \u0026(\\ChaseStepDir^{\u003c \\omega})_{\\mathrm{valid, gen}} \u0026 \\longrightarrow \u0026\\Instances \\\\\n  \u0026\\vec{d} \u0026\\longmapsto \u0026\\operatorname{SC}_\\vec{d}(I)\n\\end{array}\n$$\n","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null},"/notes/definitions/General-Notations":{"title":"General Notations","content":"\n\u003e This section defines general notations used throughout the notes.\n\nFor a formal finite sequence $(X_1, \\ldots, X_n)$ of same sorts, we abbriviate it as $\\vec{X}$. The set $\\set{\\ X_1, \\ldots, X_n\\ }$ will then be denoted as $\\elems(\\vec{X})$. We write $\\vec{X'} \\triangleleft \\vec{X}$ to mean that $\\vec{X'}$ is an initial segment of $\\vec{X}$, $\\vec{X'} \\leq \\vec{X}$ to mean that $\\vec{X'}$ is a subsequence of $\\vec{X}$ and $X' \\subseteq X$ to mean $\\elems(\\vec{X'}) \\subseteq \\elems(\\vec{X})$.\n\nFor two formal finite sequences $\\vec{X}$ and $\\vec{Y}$, we denote by $\\vec{X} \\concat \\vec{Y}$ the concatenation of $\\vec{X}$ and $\\vec{Y}$. For a nonempty (possibly infinite) sequence $(x) \\concat \\vec{X}$, we write $\\head((x) \\concat \\vec{X})$ to mean the first element $x$ of the sequence.\n\nA pair $(T, v_r)$ of a directed acyclic graph $T$ and a vertex $v_r \\in V(T)$ is called a *directed tree rooted at $v_r$* if the underlying undirected graph of $T$ is a tree and every $v \\in V(T) \\setminus \\set{v_r}$ has precisely one vertex $p_v \\in V(T)$ such that there is an edge $(p_v, v) \\in E(T)$. We shall often call $T$ a *rooted tree*.\n\nFor a directed tree $T$, we say that a node $u$ is a _descendant_ of $v$, written $u \u003c v$, when there is a (directed) path from $v$ to $u$.\n\nFor a hypergraph $\\mathcal{H} = (V, \\mathcal{E})$, we write $\\ConnComp(\\mathcal{H})$ for the set of connected components (i.e. the quotient of $V$ under the smallest equivalence relation $\\sim$ containing $x_1 \\sim x_2$ for each $x_1, x_2$ such that there is a hyperedge $E \\in \\mathcal{E}$ that spans both $x_1$ and $x_2$).\n\nWe write $f: A \\rightharpoonup B$ to mean that $f$ is a partial function from $A$ to $B$. We denote by $\\domain(f)$ to mean the domain of $f$, and write $\\isDefinedAt{f}{x}$ to mean that $x \\in \\domain(f) \\subseteq A$, i.e. $f$ is defined at $x \\in A$.","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null},"/notes/definitions/Logic-Preliminaries":{"title":"Logic Preliminaries","content":"\n\u003e This note builds on [[General Notations]].\n\nThis note mainly pulls definitions from [Rewriting the Infinite Chase](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf), but with quite a lot of modifications.\n\nWe assume the countably infinite collection $\\Vars = \\set{x_1, x_2, x_3, \\ldots}$ of variables, the ordered set $\\Nulls = \\set{\\ n_i \\mid i \\in \\mathbb{N}\\ }$ of *labelled nulls* and some given fixed (at most countable) set $\\Consts = \\set{c_1, c_2, \\ldots}$ of constants.\n\nGiven a finite collection $\\Predicates = \\set{P_1, P_2, \\ldots, P_N}$ of predicate symbols with finite arities $\\Arity(P_i) \\in \\mathbb{N}$ associated to each of them, we say that a tuple $(\\Vars, \\Nulls, \\Consts, \\Predicates, \\set{\\Arity(P_i)}_{1 \\leq i \\leq N})$, is a *first-order language*. For a first order language $\\mathcal{L} = (\\Vars_\\mathcal{L}, \\Nulls_\\mathcal{L}, \\Consts_\\mathcal{L}, \\Predicates_\\mathcal{L}, \\set{\\Arity_\\mathcal{L}(P_i)}_{1 \\leq i \\leq N})$, we define:\n - *the set $\\Terms_\\mathcal{L}$ of (non-null) terms* as $\\Vars_\\mathcal{L} \\cup \\Consts_\\mathcal{L}$\n - *the set $\\NullableTerms_\\mathcal{L}$ of nullable terms* as $\\Vars_\\mathcal{L} \\cup \\Consts_\\mathcal{L} \\cup \\Nulls_\\mathcal{L}$\n - _the set $\\FactualTerms_\\mathcal{L}$ of factual terms_ as $\\Nulls_\\mathcal{L} \\cup \\Consts_\\mathcal{L}$\n - _the set $\\Atoms_\\mathcal{L}$ of atomic formulae (resp. the set $\\Facts_\\mathcal{L}$ of facts)_ to be a set of formal expression $P(t_1, t_2, \\ldots, t_{\\Arity_\\mathcal{L}(P)})$ with $P \\in \\Predicates_\\mathcal{L}$, $t_i \\in \\Terms_\\mathcal{L}$ (resp. $\\FactualTerms_\\mathcal{L}$) for each $1 \\leq i \\leq \\Arity_\\mathcal{L}(P)$\n - *the set $\\Formulae_\\mathcal{L}$ of (first-order) formulas under the sigunature $(\\Predicates_\\mathcal{L}, \\Consts_\\mathcal{L})$* to be a set of formal expressions inductively built up from $\\Atoms_\\mathcal{L}$ using unary connective $\\neg$, binary connectives $\\wedge, \\vee, \\rightarrow$ and quantifiers $\\exists x.$ and $\\forall x.$ (where $x \\in \\Vars_\\mathcal{L}$)\n\nFor most of the following definitions, we will assume some fixed first-order language $\\mathcal{L}$ and omit the subscript $_\\mathcal{L}$ unless it becomes necessary to specify the language.\n\nSemantics (interpretation, logical-consequence relation and truth) of formulae is defined using the standard terminology. We also follow standard conventions concerning variables being *bound* and *free*.\n\nFor brevity, we adopt the following notational conventions:\n  - for a an atomic formula $P(t_1, \\ldots, t_{\\Arity(P)})$, we simply write it as $P(\\vec{t})$ with an intention that $\\vec{t} = (t_1, \\ldots, t_{\\Arity(P)})$.\n  - for a formula of a form $\\exists x_1. \\exists x_2. \\ldots \\exists x_n. \\phi$, we simply write it as $\\exists \\vec{x}. \\phi$ with an intention that $\\vec{x} = (x_1, \\ldots, x_n)$.\n\nFor conjunctions $F = \\bigwedge_{1 \\leq i \\leq n} F_i$ and $G = \\bigwedge_{1 \\leq j \\leq m} G_j$ of formulae, we write $F \\subseteq G$ when for each $1 \\leq i \\leq n$, $F_i$ appears in $G$. That is, for each $1 \\leq i \\leq n$, there exists $1 \\leq j \\leq m$ with $F_i = G_j$.\n\nWe now define subclasses of objects defined above:\n  - a fact $P(\\vec{t})$ is *a base fact* if $\\vec{t}$ contains only constants (hence no nulls). We write $\\BaseFacts$ for the set of base facts.\n  - *an instance* is a finite set of facts. We write $\\Instances$ for the set $\\mathcal{P}_{\u003c \\omega}(\\Facts)$.\n  - an instance $I$ is *a base instance* if each fact in $I$ is a base fact.\n  - a formula is *a rectified formula* if no variable is bound twice, and no variable occurs both bound and free. By a standard renaming argument, any first-order formula is equivalent to a rectified formula. Hence from now on we will assume all formulae to be rectified.\n  - a formula is closed when every occurence of variable is bound.\n  - a closed formula is a *Tuple-Generating Dependency (or TGD)* if it is of the form $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ where $\\beta$ and $\\eta$ are conjunctions of atoms with $\\eta$ nonempty. In such a formula, $\\beta$ is referred to as the *body* and $\\eta$ is referred to as the *head* of this TGD.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is *a full TGD* if $\\vec{y}$ is empty, i.e. it is of the form $\\forall \\vec{x}. \\beta \\rightarrow \\eta$.\n  - a full TGD is *a Datalog rule* if its head contains exactly one atom. A finite set of Datalog rules is is called *a Datalog program*.\n  - a TGD is in a head-normal form if it is either a *Datalog rule*, or each atom in the head contains at least one existentially quantified variable.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is a *guarded-TGD (or GTGD)* if $\\beta$ contains an atom $P(\\vec{t})$ such that $\\vec{t} \\supseteq \\vec{x}$.\n  - a Conjunctive Query (CQ) is a formula of the form $\\exists \\vec{x}. \\bigwedge_i A_i$ where each $A_i$ is an atomic formula.\n\nWe say that a Datalog program $\\Sigma_\\rew$ is a *Datalog rewriting* of a finite collection $\\Sigma$ of GTDGs when for every base instance $I$ and a base fact $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_\\rew \\models F.$$\nA *factual substitution* is a partial function $\\sigma: \\Vars \\rightharpoonup \\FactualTerms$ with a finite domain. A factual substitution canonically extends to a partial function $\\Atoms \\rightharpoonup \\Facts$ that is defined on atoms all of whose variables are in the domain of $\\sigma$. We identity this extension of $\\sigma$ with $\\sigma$ by an abuse of notation. We write $\\FactualSubstitutions = (\\Vars \\rightharpoonup \\FactualTerms)_{\u003c \\omega}$ for the countable set of all factual substitutions.\n\nWe say that a factual substitution $\\sigma$ *covers* a set $\\vec{y}$ of variables when $\\elems(\\vec{y}) \\subseteq \\domain(\\sigma)$, and say that $\\sigma$ *exactly covers $\\vec{y}$* if $\\elems(\\vec{y}) = \\domain(\\sigma)$.\n\nWe say that a factual substitution $\\sigma$ together with a (potentially infinite) set $\\mathcal{F}$ of facts *witness a boolean conjunctive query $\\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$* if $\\sigma$ exactly covers $\\vec{x}$ and $$\\set{\\ \\sigma(A_i) \\mid 1 \\leq i \\leq n \\ } \\subseteq \\mathcal{F}.$$","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null},"/notes/definitions/Rewriting-Existential-Lifting-and-Saturation":{"title":"Rewriting, Existential Lifting and Saturation","content":"\n\u003e This note builds on [[Logic Preliminaries]]\n\nGiven a set $\\Sigma$ of TGDs, a Datalog program $\\Sigma_{\\text{rew}}$ is *a rule-rewriting of $\\Sigma$* if for every base instance $I$, $\\Sigma$ and $\\Sigma_{\\text{rew}}$ generate the same set of consequences, i.e. for every __base fact__ $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_{\\text{rew}} \\models F.$$\n\nIf we also have a conjunctive query $Q$, we say that a Datalog program $\\Sigma^Q_\\rew$ together with a fresh *0-ary goal predicate* $\\mathrm{Goal^Q}()$ is a *query-rule-rewriting of $(\\Sigma, Q)$* if for every base instance $I$, $$I \\wedge \\Sigma \\models Q \\Longleftrightarrow I \\wedge \\Sigma^Q_\\rew \\models \\mathrm{Goal^Q}() $$\n\nGiven a fact $R(\\vec{f})$, the *existential lifting $\\exlift(R(\\vec{f}))$ of $R(\\vec{f})$* is defined as the formula $$\\exlift(R(\\vec{f})) := \\exists \\vec{\\nu}. R(\\vec{f}[\\ \\vec{n} \\leftarrow \\vec{\\nu}\\ ])$$\nwhere\n - $\\vec{\\nu}$ are variables corresponding to nulls in $\\vec{f}$,\n - $\\vec{f}[\\ \\vec{n} \\leftarrow \\vec{\\nu}\\ ]$ is $\\vec{f}$ with nulls replaced by their corresponding variables in $\\vec{\\nu}$. \n\nThe *existential lifting $\\exlift(I)$ of an instance $I$* is a set $\\set{\\ \\exlift(F) \\mid F \\in I\\ }$ of formulae.\n\nGiven a Datalog program $\\Sigma$ and an instance $I$, we define the *$k$-th partial Datalog-saturation $\\Sat^k_\\Sigma(I)$ of $I$ by $\\Sigma$* by induction on $k \\in \\mathbb{N}$, by $$\\begin{align}\n  \\Sat^0_\\Sigma(I) \u0026= I \\\\\n  \\Sat^{k + 1}_\\Sigma(I) \u0026= \\Sat^k_\\Sigma(I) \\cup \\set{\\ \\sigma(\\eta) \\mid (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma, \\sigma \\text{ covers } \\vec{x}, \\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)\\ }\n\\end{align}$$\nWe define the *Datalog saturation $\\Sat_\\Sigma(I)$ of $I$ by a Datalog program $\\Sigma$* as $$\\Sat_\\Sigma(I) = \\bigcup_{k \\in \\mathbb{N}} \\Sat^k_\\Sigma(I)$$\nMore generally, for an arbitrary finite collection $\\Sigma$ of GTDGs and an instance $I$, we define *the full saturation $\\FullSat_\\Sigma(I)$ of $I$ by $\\Sigma$* as $$\\FullSat_\\Sigma(I) = \\Sat_{\\Sigma_\\rew}(I)$$ for *some* rule-rewriting $\\Sigma_\\rew$ of $\\Sigma$. This definition is well-defined, since any two Datalog rewritings produce the same Datalog saturation by definition. ","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null},"/references/Books":{"title":"Books","content":"\n## `Introduction to Graph and Hypergraph Theory`\n\n^327283\n\n[SOLO permalink](https://solo.bodleian.ox.ac.uk/permalink/f/89vilt/oxfaleph000591771), EBook ISBN: `9781614701125`\n\nI used a few terminologies from this book to describe/define notions about hypergraphs.","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null},"/references/Papers":{"title":"Papers","content":"\n## `Rewriting the Infinite Chase`\n\nLink: [latest version on GitHub pages](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf)\n\nTODO: write down the ideas that are explored in this paper\n\n## `A general Datalog-based framework for tractable query answering over ontologies`\n\nLink: [ScienceDirect](https://www.sciencedirect.com/science/article/pii/S1570826812000388)\n\nTODO: write down the ideas that are explored in this paper\n","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null},"/thoughts/2022-11-01-About-template-constraints":{"title":"2022-11-01 About template constraints","content":"\n## Constraints on Partitioning Imposed by the Query\n\nSuppose that the following query is given as $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$.\n\nThere are a few ways this query could be witnessed by nulls in an infinite branch of the tree-like chase (a.k.a. \"tentacles\") or by constants in the collection of input or saturated facts (a.k.a. \"squid head\"). The following is an exhaustive list of all possible combinations:\n - 0 variable in the squid head\n\t - all of $x, y, z$ get witnessed in the same tentacle\n - 1 variable in the squid head\n\t - $x$ gets witnessed in the head and $y, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in different tentacles\n\t - $z$ gets witnessed in the head and $x, y$ get witnessed in the same tentacle\n - 2 variables in the squid head\n\t - $x$ and $y$ get witnessed in the head and $z$ gets witnessed in a tentacle\n\t - $x$ and $z$ get witnessed in the head and $y$ gets witnessed in a tentacle\n\t - $y$ and $z$ get witnessed in the head and $x$ gets witnessed in a tentacle\n - 3 variables in the squid head\n\t - All of $x, y, z$ get witnessed in the squid head\n\nThere are two impossible combinations, namely:\n\n - `x` gets witnessed in the head and $y$ and $z$ get witnessed in _different_ tentacles\n - `z` gets witnessed in the head and $y$ and $x$ get witnessed in _different_ tentacles\n\nTo see why, suppose $y$ and $z$ are instantiated as nulls $n_1$ and $n_2$ in _different tentacles_. Then there is nowhere in the infinite tree-like chase structure that proves $R(n_1, n_2)$, which uses $n_1$ and $n_2$ at the same time. So we conclude that: _if_ $y$ and $z$ are to be instantiated with nulls, _then_ that must be happen on the same tentacle.\n\nGeneralising the example above, we can see that: if the query contains an atom $P(\\vec{u})$ within the existential, then every vector witnessing $\\vec{u}$ in $P(\\vec{u})$ always have all the nulls appear in the single tentacle.\n\nSo we can deduce to a certain extent how the instantiation of variables may be distributed to different tentacles by just looking at the query.\n\n## Constraints Imposed by the Reasoning Rules\n\nIn this section, we shall write $\\Sigma$ for the generic set of rules.\n\nWhen a pseudoquery is proven in a tentacle of the infinite chase, one might imagine the following situation:\n\n![[Pasted image 20221101171150.png]]\n\nHowever, this diagram needs a slight modification: we will always get a set different from $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$ in the $i$-th step of this short-cut proof. This is because we cannot salvage atoms that are not facts (i.e. ones containing nulls) from branches steming from $I_i$. So on top of $I_i$, we are only going to add ***base facts*** that are derived from $I_i$ using $\\Sigma$ (my guess is that this is in general not even a subset of $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$; is this true?). So we wrill write fact-saturated sets of $I_i$ with $\\Sigma$ as $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_i)$.\n\nAlso, by splitting the pseudoquery we can assume that a pseudoquery is realized in $I_n$ as oppsed to $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_n)$, since if we are assuming all variables in an atom $F(\\vec{t})$ to be realized in the squid head, we may treat $F(\\vec{t})$ as a separate query (TODO: this is really hand-wavy!).\n\nIn fact we will have something like the following:\n\n![[Pasted image 20221101171906.png]]\n\n","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null},"/thoughts/2022-11-09-Head-Tentacle-Partitions-and-Pseudo-Witnesses":{"title":"2022-11-09 Head-Tentacle Partitions and Pseudo-Witnesses","content":"\nWe explorered before in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]] a few possibility on how the entire query can be witnessed by nulls in different tentacles.\n\nLet us be more precise and formal.\n\n**Definition**. For a vector $\\vec{x}$ of distinct variables, we say that a pair $(H, \\mathcal{T})$ is a _head-tentacle partition of $\\vec{x}$_ when\n - $H \\subseteq \\elems(\\vec{x})$ and $\\mathcal{T} \\subseteq \\mathcal{P}(\\elems(\\vec{x}))$\n - $H \\not\\in \\mathcal{T}$\n - Either\n\t - $H = \\emptyset$ and $\\mathcal{T}$ is a partition (i.e. a cover of disjoint nonempty sets) of $\\elems(\\vec{x})$\n\t - $\\set{H} \\cup \\mathcal{T}$ is a partition of $\\elems(\\vec{x})$\n\n**Definition**. For a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$, define the corresponding _compatible cover_ $(H, \\mathcal{T})_\\text{cover}$ as the set $\\set{ H \\cup T \\mid T \\in \\mathcal{T} }$.\n\n**Definition**. Given a boolean conjunctive query $$Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i(\\vec{v_i})$$ we say that a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$ is _compatible with $Q$_ if, for every $1 \\leq i \\leq n$ and every $x_1, x_2 \\in \\elems(\\vec{v_i})$, there exists $C \\in (H, \\mathcal{T})_\\text{cover}$ such that $\\set{x_1, x_2} \\subseteq C$.\n\n**Definition**. For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$, the _witness pattern $\\mathrm{Pat}_\\sigma$ of $\\sigma$_ is the head-tentacle paritition $(H, \\mathcal{T})$ defined by $$\\begin{align}\nH \u0026= \\set{ x \\in \\elems(\\vec{x}) \\mid \\sigma(x) \\text{ is a constant}} \\\\\nT \u0026= (\\elems(\\vec{x}) \\setminus H) / \\sim\n\\end{align}$$ where $\\sim$ is the equivalence relation given by $x_1 \\sim x_2$ iff $\\sigma(x_1)$ and $\\sigma(x_2)$ appear in the same tentacle (TODO: define this precisely; it should be easy thanks to the explicit construction of $\\SatTree_\\Sigma(I)$).\n\n**Claim**:  For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$ (TODO: define notions so that this statement can be shortened), $\\mathrm{Pat}_\\sigma$ is compatible with $Q$.\n\n---\nNow that we defined notions, we can say the same thing as in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]], but more concisely:\n\nFor a query $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$, the following are the only head-tentacle partitions compatible with $Q$:\n - $(\\emptyset, \\set{\\set{x, y, z}})$\n - $(\\set{x}, \\set{\\set{y, z}})$\n - $(\\set{y}, \\set{\\set{x, z}})$\n - $(\\set{y}, \\set{\\set{x}, \\set{z}})$\n - $(\\set{z}, \\set{x, y})$\n - $(\\set{x, y}, \\set{\\set{z}})$\n - $(\\set{x, z}, \\set{\\set{y}})$\n - $(\\set{y, z}, \\set{\\set{x}})$\n - $(\\set{x, y, z}, \\emptyset)$\n\nLet us tinker with this example.\n\n**Question.** Given a finite set $\\Sigma$ of GTGDs, is $$\n\\left(\n\\Sigma \\cup \\left\\lbrace\n  \\begin{aligned}\n  \u0026 \\forall u, v. R(u, v) \\rightarrow \\mathrm{Subgoal}_\\mathrm{left}(v), \\\\\n  \u0026 \\forall v, w. R(v, w) \\rightarrow \\mathrm{Subgoal}_\\mathrm{right}(v), \\\\\n  \u0026 \\forall v. \\mathrm{Subgoal}_\\mathrm{left}(v) \\wedge \\mathrm{Subgoal}_\\mathrm{right}(v) \\rightarrow \\mathrm{Goal}^Q() \\\\\n\\end{aligned}\n\\right\\rbrace\n\\right)_\\mathrm{rew}\n$$ a query-rule-rewriting of $(\\Sigma, Q)$?\n\n**Answer**: For each possible head-tentacle partition, we can \"enrich\" the $\\SatTree$ by added rules and see if $\\mathrm{Goal}^Q()$ can be derived using chase steps.","lastmodified":"2022-11-17T05:56:35.102850477Z","tags":null}}