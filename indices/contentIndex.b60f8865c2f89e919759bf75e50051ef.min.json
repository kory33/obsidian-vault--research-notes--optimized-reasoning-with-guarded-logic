{"/":{"title":"Optimized Reasoning with Guarded Logic","content":"\nThis is the personal vault of Ryosuke Kondo filled with both random and organized notes concerning my fourth year project `\"Optimized Reasoning with Guarded Logic\"`.\n\n## About the Project\n\nThe aim of the project is to solve the \"open world querying problem\" in case of existential conjunctive queries together with a finite collection of Guarded Tuple Generating Dependencies (GTGDs) set as axioms.\n\nThe problem in the case of atomic queries has been solved by [`Rewriting the Infinite Chase`](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf) by means of rewriting the given set of GTGD rules to Datalog rules. This project tries to extend this result to binary (or possibly, general) conjunctive queries.\n\nSee [[Saturations]] for concepts involved.\n\n## Internal Links\n\n### References\n\n - [[Papers]] (summarises papers that I think will be useful at some point)\n\n### Thoughts\n\nSome random thoughts regarding the project.\n\n - [[2022-11-01 About template constraints]]\n\n### Notes\n\nA collection of more structured notes.\n\n - Definitions:\n\t - Every other notes (should) depend on definitions given in this folder. The definition are organized into a DAG that starts from [[General Notations]].\n - [[Reducing Query-Rule-Rewriting Problem to BCQ Answerings]]\n\n## External Links\n\n - [Project Handbook 2022](https://www.cs.ox.ac.uk/teaching/courses/projects/handbook/Project%20Handbook%202022.pdf)\n\n## Meta Information\n\nContents of this repository is mainly authored on Kondo's machine using [Obsidian](https://obsidian.md), git-managed and then synchronized to a git repository [hosted on GitHub](https://github.com/kory33/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic).\n","lastmodified":"2023-01-13T11:39:02.381286769Z","tags":null},"/notes/Preliminary-Results-on-Saturated-Chase-Like-Trees":{"title":"Preliminary Results on Saturated Chase-Like Trees","content":"\n## General Definitions surrounding $\\SatTree$s\n\n\u003e **Definition.** For chase-like tree $T$ and its vertex $v \\in T_0$, we say that $v$ *mentions* a factual term $t$ if $\\Instance_T(v)$ contains a fact $P(\\vec{t'})$ such that $t \\in \\elems(\\vec{t'})$.\n\n\u003e **Definition.** For a chase-like tree $T$ and a factual term $t$, the _subgraph of $T$ mentioning $t$_, denoted $T \\upharpoonright t$, is the subgraph of $T$ induced by the vertex set $V_t = \\set{v \\in T \\mid v \\text{ mentions } t }$ together with the instance assignment restricted to $V_t$, i.e. $\\Instance_{T \\upharpoonright t} = \\Instance_T \\upharpoonright V_t$ .\n\nWe can see that the subgraph of a $\\SatTree$ mentioning $t$ really is then a subtree sitting in the $\\SatTree$ as seen in the following proposition:\n\n\u003e **Proposition**. For a finite set $\\Sigma$ of GTGDs, a base instance $I$ and any factual term $t$, $\\SatTree_\\Sigma(I) \\upharpoonright t$ is connected. In particular, if $t$ is mentioned in $\\TreeFacts(\\SatTree_\\Sigma(I))$, then $\\SatTree_\\Sigma(I) \\upharpoonright t$ is a rooted subtree of $\\SatTree_\\Sigma(I)$.\n\u003e \n\u003e \u003e _Proof_. By construction of $\\SatTree_\\Sigma(I)$, we have that\n\u003e \u003e - a factual term not already mentioned in $I$ is never introduced by any chase-step direction from any node\n\u003e \u003e - a null introduced at a node $\\vec{d}$ is never introduced anywhere else in the tree\n\nNow, for each factual term $t$ mentioned somewhere in the $\\SatTree$, we can identify where $t$ has been \"introduced\" in the tree:\n\n\u003e **Definition.** For a factual term $t$ mentioned in $\\TreeFacts(\\SatTree_\\Sigma(I))$, the *introduction point $\\Intro(t)$ of $t$* is the root node of the subtree $\\SatTree_\\Sigma(I) \\upharpoonright t$.\n\nClearly, $\\Intro(t)$ is the root node $()$ if and only if $t$ is a constant.\n\n## Fact Introduction Lemma\n\nWe have the following useful lemma:\n\n\u003e **Lemma (Fact Introduction)**. For a node $n$ of $\\SatTree_\\Sigma(I)$, its ancestor node $a$ and a fact $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(n)$, if $\\Intro(t) \\geq a$ for all $t \\in \\elems(\\vec{t})$, then $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(a)$.\n\u003e \n\u003e \u003e _Proof_. TODO (we would probably make a heavy use of this lemma when arguing validity of query reductions)\n\nAn immediate consequence of the lemma is the following:\n\n\u003e **Proposition**. If $P(\\vec{t}) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$ is a base fact, then $P(\\vec{t}) \\in \\Sat_\\Sigma(I)$. ^6bd969\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e By the assumption, $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(n)$ for some node $n \\in \\SatTree_\\Sigma(I)$.\n\u003e \u003e \n\u003e \u003e Now for all $t \\in \\elems(\\vec{t})$, $\\Intro(t)$ is the root node $()$, which is an ancestor of $n$. Therefore by the Fact Introduction lemma $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(()) = \\Sat_\\Sigma(I)$.\n\n## Acting Consts Translations on SatTrees\n\nWe now want to consider acting consts translations on $\\SatTree$s. To do so, we extend a const translation $t: \\Consts \\rightarrow \\Consts$ to a function $\\tilde{t}: \\Consts \\cup \\mathrm{im}(\\#) \\rightarrow \\Consts \\cup \\mathrm{im}(\\#)$ on the set of constants unioned with the image $\\mathrm{im}(\\#)$ of the global null-picking function $\\#$.\n\n\u003e **Definition**. Let $\\vec{d} = ((\\tau_1, \\sigma_1), \\ldots, (\\tau_n, \\sigma_n))$ be a finite generic chase path and $t: \\Consts \\rightarrow \\Consts$ a consts translation. We define *the finite generic chase path $\\mathrm{map}_t(\\vec{d})$ mapped by $t$* to be the finite generic chase path given by $$\\mathrm{map}_t(\\vec{d}) = ((\\tau_1, t \\circ \\sigma_1), \\ldots, (\\tau_n, t \\circ \\sigma_n)).$$\n\n\u003e **Definition**. Given a consts translation $t: \\Consts \\rightarrow \\Consts$, we define the *extension $\\tilde{t}: \\Consts \\cup \\mathrm{im}(\\#) \\rightarrow \\Consts \\cup \\mathrm{im}(\\#)$ of $t$ to introduced nulls* with $$\n\\tilde{t}(\\#(\\vec{d}, n)) := \\#(\\mathrm{map}_t(\\vec{d}), n),\n$$and by an abuse of notation we identify $\\tilde{t}$ with $t$.\n\nThe previous definition is motivated by the following series of propositions.\n\n\u003e **Definition**. For an endofunction $f: A \\rightarrow A$ and $S \\subseteq A$, we say that *$f$ fixes $S$* if for all $s \\in S$, $f(s) = s$.\n\n\u003e **Proposition**. Let $\\Sigma$ be a finite set of GTGDs, $I$ an instance and $t: \\Consts \\rightarrow \\Consts$ a consts translation that fixes $\\consts(\\Sigma)$. Then $t(\\FullSat_\\Sigma(I)) \\subseteq \\FullSat_\\Sigma(t(I))$.\n\u003e \n\u003e \u003e *Proof*. Choose a rewriting $\\Sigma_\\mathrm{rew}$ of $\\Sigma$, then $$\n\\begin{align}\n  t(\\FullSat_\\Sigma(I))\n   \u0026= t(\\Sat_{\\Sigma_\\mathrm{rew}}(I)) \\\\\n   \u0026= t(\\bigcup_{k \\in \\mathbb{N}} \\Sat^k_{\\Sigma_\\mathrm{rew}}(I)),\n\\end{align}\n$$and $$\n\\begin{align}\n  \\FullSat_\\Sigma(t(I))\n   \u0026= \\Sat_{\\Sigma_\\mathrm{rew}}(t(I)) \\\\\n   \u0026= \\bigcup_{k \\in \\mathbb{N}} \\Sat^k_{\\Sigma_\\mathrm{rew}}(t(I)).\n\\end{align}\n$$\n\u003e \u003e So it suffices to show that $t(\\Sat^k_{\\Sigma_\\mathrm{rew}}(I)) \\subseteq \\Sat^k_{\\Sigma_\\mathrm{rew}}(t(I))$ for all $k \\in \\mathbb{N}$. We proceed by induction on $k$. The base case is $t(\\Sat_{\\Sigma_\\mathrm{rew}}^0(I)) = t(I) = \\Sat_{\\Sigma_\\mathrm{rew}}^0(t(I))$. To see the inductive part, suppose $t(\\Sat^k_{\\Sigma_\\mathrm{rew}}(I)) \\subseteq \\Sat^k_{\\Sigma_\\mathrm{rew}}(t(I))$. Then $$\n\\begin{align}\n  t(\\Sat^{k+1}_{\\Sigma_\\mathrm{rew}}(I))\n    \u0026= t(\\Sat^k_{\\Sigma_\\mathrm{rew}}(I) \\cup \\set{\\ \\sigma(\\eta) \\mid (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in {\\Sigma_\\mathrm{rew}}, \\sigma \\text{ covers } \\vec{x}, \\sigma(\\beta) \\subseteq \\Sat^k_{\\Sigma_\\mathrm{rew}}(I)\\ }) \\\\\n    \u0026= t(\\Sat^k_{\\Sigma_\\mathrm{rew}}(I)) \\cup \\set{\\ (t \\circ \\sigma)(\\eta) \\mid (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in {\\Sigma_\\mathrm{rew}}, \\sigma \\text{ covers } \\vec{x}, \\sigma(\\beta) \\subseteq \\Sat^k_{\\Sigma_\\mathrm{rew}}(I)\\ } \\\\\n    \u0026\\subseteq \\Sat^k_{\\Sigma_\\mathrm{rew}}(t(I)) \\cup \\set{\\ \\sigma'(\\eta) \\mid (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in {\\Sigma_\\mathrm{rew}}, \\sigma' \\text{ covers } \\vec{x}, \\sigma'(\\beta) \\subseteq \\Sat^k_{\\Sigma_\\mathrm{rew}}(t(I))\\ } \\\\\n\t\u0026= \\Sat^{k+1}_{\\Sigma_\\mathrm{rew}}(t(I))\n\\end{align}\n$$where the third subset relation follows from the fact that if $\\sigma$ covers $\\vec{x} = \\mathrm{FV}(\\beta)$ and $\\sigma(\\beta) \\subseteq \\mathrm{Sat}^k_\\Sigma(I)$, then $t \\circ \\sigma$ is a factual substitution covering $\\vec{x}$ (as $t$ fixes $\\consts(\\Sigma) \\supseteq \\consts(\\beta) = \\consts(\\sigma(\\beta))$) and $(t \\circ \\sigma)(\\beta) \\subseteq t(\\Sat^k_\\Sigma(I)) \\subseteq \\Sat^k_\\Sigma(t(I))$ by induction hypothesis. \n\n\u003e **Proposition**. Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance and $t: \\Consts \\rightarrow \\Consts$ a consts translation that fixes $\\consts(\\Sigma)$.Then for any valid $\\Sigma$-chase path $\\vec{d} = ((\\tau_1, \\sigma_1), \\ldots, (\\tau_n, \\sigma_n))$ on $I$, $$t(\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})) \\subseteq \\Instance_{\\SatTree_\\Sigma(t(I))}(\\mathrm{map}_t(\\vec{d})).$$\n\u003e\n\u003e \u003e *Proof*. By induction on the length of $\\vec{d}$. The base case is proven in the preceding proposition.\n\u003e \u003e \n\u003e \u003e For the inductive part, take a valid $\\Sigma$-chase path $\\vec{d} = ((\\tau_1, \\sigma_1), \\ldots, (\\tau_{n-1}, \\sigma_{n-1}))$ on $I$, a chase-step direction $(\\tau_n, \\sigma_n)$ with $\\vec{d} \\concat (\\tau_n, \\sigma_n)$ being a valid $\\Sigma$-chase path on $I$, and suppose that $\\mathrm{map}_t(\\vec{d})$ is a valid $\\Sigma$-chase path on $t(I)$ with $$t(\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})) \\subseteq \\Instance_{\\SatTree_\\Sigma(t(I))}(\\mathrm{map}_t(\\vec{d})).$$\n\u003e \u003e Now $$\n\\begin{align}\n  t(\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d} \\concat (\\tau_n, \\sigma_n)))\n    \u0026= t(\\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{SC}_{\\Sigma, \\vec{d}}(I), (\\tau_n, \\sigma_n)))) \\\\\n    \u0026\\subseteq \\FullSat_\\Sigma(t(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{SC}_{\\Sigma, \\vec{d}}(I), (\\tau_n, \\sigma_n)))) \\\\\n    \u0026= \\FullSat_\\Sigma(\n      t(\n        \\chaseHead_{\\widehat{\\#_{\\vec{d}}}}(\\tau_n, \\sigma_n)\n      ) \\cup t(\n        \\exports_\\Sigma(\\operatorname{SC}_{\\Sigma, \\vec{d}}(I), (\\tau_n, \\sigma_n)\n      )\n    )) \\\\\n    \u0026= \\FullSat_\\Sigma(\n      \\chaseHead_{\\widehat{\\#_{\\mathrm{map}_t(\\vec{d})}}}(\\tau_n, t \\circ \\sigma_n)\n      \\cup t(\n        \\exports_\\Sigma(\\operatorname{SC}_{\\Sigma, \\vec{d}}(I), (\\tau_n, \\sigma_n)\n      )\n    )) \\\\\n    \u0026\\subseteq \\FullSat_\\Sigma(\n      \\chaseHead_{\\widehat{\\#_{\\mathrm{map}_t(\\vec{d})}}}(\\tau_n, t \\circ \\sigma_n)\n      \\cup\n        \\exports_\\Sigma(\\operatorname{SC}_{\\Sigma, \\mathrm{map}_t(\\vec{d})}(t(I)), (\\tau_n, t \\circ \\sigma_n)\n      )\n    )) \\\\\n    \u0026= \\Instance_{\\SatTree_\\Sigma(t(I))}(\\mathrm{map}_t(\\vec{d}) \\concat (\\tau_n, t \\circ \\sigma_n))).\n\\end{align}\n$$\n\n\u003e **Corollary (facts-translation inclusion).** Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance and $t: \\Consts \\rightarrow \\Consts$ a consts translation that fixes $\\consts(\\Sigma)$. Then $$t(\\TreeFacts(\\SatTree_\\Sigma(I))) \\subseteq \\TreeFacts(\\SatTree_\\Sigma(t(I))).$$\n\u003e \n\u003e \u003e *Proof*. Take $F \\in t(\\TreeFacts(\\SatTree_\\Sigma(I)))$. Then there is some $\\tilde{F} \\in \\TreeFacts(\\SatTree_\\Sigma(I))$ with $t(\\tilde{F}) = F$, and hence some valid $\\Sigma$-chase path $\\vec{d}$ on $I$ with $\\tilde{F} \\in \\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$. As $$\n\\begin{align}\n  F\n    \u0026= t(\\tilde{F}) \\\\\n    \u0026\\in t(\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})) \\\\\n    \u0026\\subseteq \\Instance_{\\SatTree_\\Sigma(t(I))}(\\mathrm{map}_t(\\vec{d})),\n\\end{align}\n$$$F \\in \\TreeFacts(\\SatTree_\\Sigma(t(I)))$.\n\n## Universality of SatTrees\n\n\u003e **Fact**. Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance and $Q = \\exists \\vec{z}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ a conjunctive query. Then $$I \\wedge \\Sigma \\models Q \\Longleftrightarrow \\TreeFacts(\\SatTree_\\Sigma(I)) \\text{ witnesses } Q.$$\n\n\u003e **Corollary (query entailment is preserved by $\\consts(\\Sigma)$-fixing consts translations)**. Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance, $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j$ a boolean conjunctive query and $t: \\Consts \\rightarrow \\Consts$ a consts translation that fixes $\\consts(\\Sigma)$.\n\u003e \n\u003e If $I \\wedge \\Sigma \\models Q$, then $t(I) \\wedge \\Sigma \\models t(Q)$.\n\u003e \n\u003e \u003e *Proof.* Suppose $I \\wedge \\Sigma \\models Q$. By the previous fact, there exists a factual substitution $\\sigma: \\elems(\\vec{x}) \\rightarrow \\Consts \\cup \\Nulls$ with $\\sigma(\\bigwedge_{j \\in J} A_j) \\subseteq \\TreeFacts(\\SatTree_\\Sigma(I))$. As $t$ fixes $\\consts(\\Sigma)$, by facts-translation inclusion $$\n\\begin{align}\n  (t \\circ \\sigma)\\left(\\bigwedge_{j \\in J} A_j\\right)\n    \u0026\\subseteq t(\\TreeFacts(\\SatTree_\\Sigma(I))) \\\\\n    \u0026\\subseteq \\TreeFacts(\\SatTree_\\Sigma(t(I)))\n\\end{align}\n$$Now, as $t \\circ \\sigma = (t \\upharpoonright \\Nulls) \\circ \\sigma \\circ t$, we have $$\n\\begin{align}\n  ((t \\upharpoonright \\Nulls) \\circ \\sigma \\circ t) \\left(\n    \\bigwedge_{j \\in J} A_j\n  \\right)\n    \u0026= (t \\circ \\sigma)\\left(\\bigwedge_{j \\in J} A_j\\right) \\\\\n    \u0026\\subseteq \\TreeFacts(\\SatTree_\\Sigma(t(I))).\n\\end{align}\n$$as $t(Q) = \\exists \\vec{z}. t \\left(\\bigwedge_{j \\in J} A_j \\right)$, we see that $\\TreeFacts(\\SatTree_\\Sigma(t(I)))$ witnesses $t(Q)$ with the factual substitution $(t \\upharpoonright \\Nulls) \\circ \\sigma$. \n\u003e \u003e\n\u003e \u003e By the previous fact, we conclude that $t(I) \\wedge \\Sigma \\models t(Q)$.\n","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/notes/Reducing-Query-Rule-Rewriting-Problem-to-BCQ-Answerings":{"title":"Reducing Query-Rule-Rewriting Problem to BCQ Answerings","content":"\n\u003e We shall build on definitions given in [[Chase-Like Trees and Saturated Chase-Like Trees]]. We will also rely on the results in [[Preliminary Results on Saturated Chase-Like Trees]], and [[Witness Fragmentation and Witness Gluing]].\n\n## Preliminaries\n\nWe first make precise the terms that will be useful in describing the algorithm.\n\n\u003e **Definition**. Given a boolean conjunctive query $\\overline{Q} = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ and a subset $V$ of $\\elems(\\vec{x})$,\n\u003e  - the *closure $\\overline{V}$ of $V$ in $\\overline{Q}$* is the set of variables given by $$\n\\overline{V} = \\Set{ x \\in \\elems(\\vec{x})\\ \\biggm\\vert\n\\begin{array}{c}\n  \\text{ there are } j \\in J \\text{ and } x' \\in V \\text{ such that} \\\\\n  \\vec{u_j} \\text{ contains both $x$ and $x'$}\n\\end{array}\n}\n$$\n\u003e  - the *boundary $\\partial V$ of $V$ in $\\overline{Q}$* is the set of variables given by $$\\partial V = \\overline{V} \\setminus V$$\n\u003e  - the *subquery $\\overline{Q}_V$ of $\\overline{Q}$ induced by $V$* is the conjunctive query $$\\exists \\vec{V}. \\bigwedge_{j \\in J_\\overline{V}} A_j(\\vec{u}_j)$$ where\n\u003e \t - $\\vec{V}$ is $V$ ordered into a sequence by the order of appearance in $\\vec{x}$\n\u003e \t - $J_\\overline{V} = \\set{ j \\in J \\mid \\vec{u}_j \\text{ only mentions variables from } \\overline{V}}$\n\u003e \n\u003e \u003e *Remark*. The subquery $\\overline{Q}_V$ of $\\overline{Q}$ induced by $V$ is typically not boolean anymore, since $\\mathrm{FV}(\\overline{Q}_V) = \\partial V$.\n\n## The Basic Rewriting Algorithm\n\nNow consider the following algorithm. Note that we make use of an oracle for BCQ answering over GTGD rules in Step `6-3-1-1`.\n\n\u003e **Definition** Define the procedure $\\mathrm{QueryRuleRewrite1}(\\Sigma, Q)$ as follows:\n\u003e \n\u003e *Input*:\n\u003e   - $\\Sigma$ a finite set of head-normal GTGDs\n\u003e   - $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ a conjunctive query\n\u003e\n\u003e *Algorithm*:\n\u003e  1. Let $\\Sigma_\\mathrm{rew}$ be a Datalog rewriting of $\\Sigma$.\n\u003e  2. Let `mut` $\\Sigma' \\leftarrow \\emptyset$ be a variable holding new full TGD rules\n\u003e  3. Let $\\vec{z} \\leftarrow$ free variables of $Q$, in the order of quantification\n\u003e  4. Let $\\overline{Q} = \\exists \\vec{z}. Q$\n\u003e  5. Let $\\mathcal{H}(\\overline{Q}) = (\\mathcal{V}, \\mathcal{E})$ be the query structure hypergraph of $\\overline{Q}$\n\u003e  6. For each connected sub-hypergraph $C$ of vertices in $\\mathcal{H}(\\overline{Q})$, do:\n\u003e      1. Let $\\partial C$ be the boundary of $C$ in $\\overline{Q}$, and let $\\mathrm{Subgoal_C}$ be a fresh $|\\partial C|$-ary predicate symbol associated with $C$\n\u003e      2. Let $\\overline{Q}_C$ be the subquery of $\\overline{Q}$ induced by $C$\n\u003e      3. For each $\\Sigma$-tentacle ejection template $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$, do:\n\u003e          1. For every possible $T$-closing map $\\gamma: \\partial C \\rightarrow {\\sim}_\\tau \\cup \\consts(\\Sigma)$ on $\\overline{Q}_C$ do:\n\u003e              1. If $(T, \\gamma)$ generically $\\Sigma$-proves $\\overline{Q}_C$, then\n\u003e                  1. Let $\\operatorname{remap}: {\\sim_\\tau} \\rightarrow \\Vars$ be any injection from $\\sim_\\tau$ to the set of variables (for instance, a choice function on $\\sim_\\tau$)\n\u003e                  2. Let $\\mathrm{quotient}: (\\bigcup {\\sim_\\tau}) \\rightarrow {\\sim_\\tau}$ be the quotient map sending an element in $\\bigcup {\\sim_\\tau}$ to its equivalence class under $\\sim_\\tau$\n\u003e                  3. Let $\\vec{v}$ be the sequence of variables in $\\operatorname{im} (\\mathrm{remap} \\circ \\mathrm{quotient})$ (in some order)\n\u003e                  4. Add a full TGD rule $$\\forall \\vec{v}. (\\mathrm{remap} \\circ \\mathrm{quotient})(\\beta \\wedge F_\\tau) \\rightarrow (\\mathrm{remap} \\circ \\gamma)(\\mathrm{Subgoal}_C(\\vec{\\partial C}))$$ to $\\Sigma'$\n\u003e  7. Let $\\mathrm{Goal}$ be a fresh $|\\vec{z}|$-ary goal predicate\n\u003e  8. For each subset $V \\supseteq \\elems(\\vec{z})$ of $\\mathcal{V}$, do the following:\n\u003e      1. Let $\\set{C_i}_{i \\in I_V}$ be the set of connected components of $\\mathcal{H}(\\overline{Q}-V)$\n\u003e      2. Let $J_V = \\set{ j \\in J \\mid \\vec{u}_j \\text{ only contains variables from } V}$\n\u003e      3. Add a full TGD rule $$\\forall \\vec{V}. \\left(\\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\\right) \\wedge \\left(\\bigwedge_{i \\in I_V} \\mathrm{Subgoal}_{C_i}(\\partial C_i)\\right) \\rightarrow \\mathrm{Goal}(\\vec{z})$$ to $\\Sigma'$\n\u003e  9. Return $(\\Sigma_\\mathrm{rew} \\cup \\Sigma', \\mathrm{Goal})$\n\nThe $\\mathrm{Subgoal}_C$ predicate essentially captures the fulfilment of the subquery, with variables in $C$ being witnessed by nulls and variables in $\\partial C$ being witnessed by constants in the base instance. To make this idea precise, we prove the following lemma, which also turns out to be useful for the correctness proof of the $\\mathrm{QueryRuleRewrite1}$ algorithm.\n\n\u003e **Lemma (Subquery-Subgoal Correspondence)**. Let $\\Sigma$ be a finite set of GTDGs, $Q = \\exists \\vec{q}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ a conjunctive query and $I$ a ground instance. \n\u003e \n\u003e Write\n\u003e  - $(\\Sigma_\\mathrm{qrr}, \\mathrm{Goal}^Q) = \\mathrm{QueryRuleRewrite1}(\\Sigma, Q)$,\n\u003e  - $\\vec{z} = \\mathrm{FV}(Q)$ and $\\overline{Q} = \\exists \\vec{z}. Q$, and\n\u003e  - $\\mathcal{H}(\\overline{Q}) = (\\mathcal{V}, \\mathcal{E})$ for the query hypergraph of $\\overline{Q}$.\n\u003e\n\u003e Take any connected sub-hypergraph $C$ of $\\mathcal{H}(\\overline{Q})$, and let $\\overline{Q}_C = \\exists \\vec{C}. \\bigwedge_{j \\in J_\\overline{C}} A_j(\\vec{u}_j)$ be the subquery of $\\overline{Q}$ induced by $C$. Then the following implications hold.\n\u003e \n\u003e  1. If $\\sigma_\\overline{C}$ is a factual substitution that exactly covers $\\overline{C}$ with $\\touchDowners(\\sigma_\\overline{C}) = \\partial C$, then $$\n\\sigma_\\overline{C} \\left(\n  \\bigwedge_{j \\in J_\\overline{C}} A_j(\\vec{u}_j)      \n\\right) \\in \\TreeFacts(\\SatTree_\\Sigma(I))\n  \\Longrightarrow\n    I \\wedge \\Sigma_\\mathrm{qrr} \\models \\sigma_\\overline{C}(\\mathrm{Subgoal}_C(\\vec{\\partial C})).\n$$\n\u003e  2. If $\\sigma_{\\partial C}$ is a ground substitution that covers exactly $\\partial C$, then $$\nI \\wedge \\Sigma_\\mathrm{qrr}\n  \\models\n    \\sigma_{\\partial C}(\n      \\mathrm{Subgoal}_C(\\vec{\\partial C})\n    )\n  \\Longrightarrow\nI \\wedge \\Sigma\n    \\models\n      \\sigma_{\\partial C}(\\overline{Q}_C)\n$$\n\u003e \n\u003e \u003e *Proof of (1)*. Suppose that $\\sigma_\\overline{C}$ is a factual substitution that exactly covers $\\overline{C}$ with $\\touchDowners(\\sigma_\\overline{C}) = \\partial C$. Suppose further that $$\n\\sigma_\\overline{C}\\left(\n  \\bigwedge_{j \\in J_\\overline{C}} A_j(\\vec{u}_j)\n\\right) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$$holds.\n\u003e \u003e\n\u003e \u003e Then all of $\\overline{C} \\setminus \\partial C = C$ are mapped to nulls by $\\sigma_\\overline{C}$ , and by connectedness of $C$ and the definition of $J_\\overline{C}$ , there exists some valid generative path $(\\tau = \\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta, \\sigma)$ such that all nulls in $\\sigma_\\overline{C}[C]$ are introduced within the tentacle hanging from $(\\tau, \\sigma)$ (TODO: write this fact as a lemma somewhere: this follows from the witness decomposition).\n\u003e \u003e \n\u003e \u003e \n\u003e \u003e For a variable $w \\in \\partial C$ such that $\\sigma_\\overline{C}(w) \\in \\consts(\\Sigma)$, set $\\gamma_\\sigma(w) = \\sigma_\\overline{C}(w)$. Otherwise, if $w \\in \\partial C$ has $\\sigma_\\overline{C}(w) \\not\\in \\consts(\\Sigma)$, then as $\\sigma_\\overline{C}\\left(\\bigwedge_{j \\in J_\\overline{C}} A_j(\\vec{u}_j)\\right)$ contains a fact that mentions both $\\sigma_\\overline{C}(w)$ and a null occuring in $\\Tentacle_\\Sigma(T, \\sigma)$, $\\sigma$ must send some variable $\\tilde{w} \\in \\vec{x}$ to $\\sigma_\\overline{C}(w)$ (TODO: We might want to make this argument a bit more precise. The reasoning is informally as follows: as there is no way $\\sigma_\\overline{C}(w)$ can be introduced during the chase process (since $\\sigma_\\overline{C}(w)$ does not appear in $\\Sigma$), $\\sigma_\\overline{C}(w)$ must be mentioned in one of exported facts at the root of the tentacle). So choose such $\\tilde{w}$ for each $w \\in \\partial C$ with $\\sigma_\\overline{C}(w) \\not \\in \\consts(\\Sigma)$, and set $\\gamma_\\sigma(w) = [\\tilde{w}]_{\\sim_T}$ for all such $w$.\n\u003e \u003e\n\u003e \u003e We make the following claim:\n\u003e \u003e\n\u003e \u003e \u003e **Claim 1**. $(T, \\gamma_\\sigma)$ generically proves $\\overline{Q}_C$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e *Proof*. We need to prove that $(\\GenConst_\\Sigma \\circ \\mathrm{quotient}_{\\sim_T})(F_T \\wedge \\beta) \\wedge \\Sigma \\models (\\mathrm{GenConst}_\\Sigma \\circ \\gamma_\\sigma)(\\overline{Q}_C)$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e By the assumption on $\\sigma$ and $\\sigma_\\overline{C}$, we have $\\sigma(F_T \\wedge \\beta) \\wedge \\Sigma \\models \\sigma_\\overline{C}(\\overline{Q}_C)$. As $\\mathrm{ker}(\\sigma) = {\\sim}_T$, $\\sigma$ factors through the quotient map and an injection, i.e. there is an injective map $\\phi: {\\sim}_T \\rightarrow \\Consts$ such that $\\sigma = \\phi \\circ \\mathrm{quotient}_{{\\sim}_T}$. \n\u003e \u003e \u003e \n\u003e \u003e \u003e **If $\\consts(\\Sigma)$ is empty,** then for any $w \\in \\partial C$,  $(\\phi^{-1} \\circ \\sigma_\\overline{C})(w) = \\gamma_\\sigma(w)$ by the construction of $\\gamma_\\sigma$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e (TODO: Unfortunately, we do not have $\\phi^{-1} \\circ \\sigma_\\overline{C} = \\gamma_\\sigma$ when $\\Sigma$ contains constants. For such cases to work, we need to include the data of \"which equivalence classes are mapped to which elements in $\\consts(\\Sigma)$\", likely in a form of partial function $\\sigma_T \\rightharpoonup \\consts(\\Sigma)$.)\n\u003e \u003e \u003e \n\u003e \u003e \u003e So $\\phi^{-1} \\circ \\sigma_\\overline{C} = \\gamma_\\sigma$, and as $\\mathrm{GenConst}_\\Sigma \\circ \\phi^{-1}$ is a $\\consts(\\Sigma)$-fixing consts translation, $(\\mathrm{GenConst}_\\Sigma \\circ \\phi^{-1} \\circ \\sigma)(F_T \\wedge \\beta) \\wedge \\Sigma = (\\GenConst_\\Sigma \\circ \\mathrm{quotient}_{\\sim_T})(F_T \\wedge \\beta) \\wedge \\Sigma$ entails $(\\mathrm{GenConst}_\\Sigma \\circ \\phi^{-1} \\circ \\sigma_\\overline{C}) = (\\mathrm{GenConst}_\\Sigma \\circ \\gamma_\\sigma)$.\n\u003e \u003e\n\u003e \u003e Now that Claim 1 has been established, $\\Sigma_\\mathrm{qrr}$ contains a rule $$\\tau_\\mathrm{Subgoal} = \\forall \\vec{v}. (\\mathrm{remap} \\circ \\mathrm{quotient})(\\beta \\wedge F_T) \\rightarrow (\\mathrm{remap} \\circ \\gamma_\\sigma)(\\mathrm{Subgoal}_C(\\vec{\\partial C})).$$for some remapping function $\\mathrm{remap}: {\\sim_T} \\rightarrow \\Vars$ and some ordering $\\vec{v}$ of variables in $(\\mathrm{remap} \\circ \\mathrm{quotient})(\\beta \\wedge F_T)$.\n\u003e \u003e \n\u003e \u003e We now wish to set up a substitution $\\sigma_\\vec{v}$ exactly covering $\\vec{v}$ such that $\\FullSat(I)$ can be $\\tau_\\mathrm{Subgoal}$-chased with $\\sigma_\\vec{v}$ and $\\sigma_\\vec{v}((\\mathrm{remap} \\circ \\gamma_\\sigma)(\\mathrm{Subgoal}_C(\\vec{\\partial C}))) = \\sigma_\\overline{C}(\\mathrm{Subgoal}_C(\\vec{\\partial C}))$. Pick a retraction $\\mathrm{remap}^{-1}$ of $\\mathrm{remap}$ and a section $\\mathrm{quotient}^{-1}$ of $\\mathrm{quotient}$. Now let $\\sigma_\\vec{v} = \\sigma \\circ \\mathrm{quotient}^{-1} \\circ \\mathrm{remap}^{-1}$.\n\u003e \u003e \n\u003e \u003e Then $\\sigma_\\vec{v}((\\mathrm{remap} \\circ \\mathrm{quotient})(\\beta \\wedge F_T)) = \\sigma(\\beta \\wedge F_T)$. Since $T$ is an abstraction of $(\\tau, \\sigma)$, we have $\\sigma(\\beta \\wedge F_T) \\in \\FullSat(I)$, so $\\FullSat(I)$ can be $\\tau_\\mathrm{Subgoal}$-chased with $\\sigma_\\vec{v}$.\n\u003e \u003e \n\u003e \u003e To check the remaining equality, pick any $w \\in \\partial C$. If $\\sigma_\\overline{C}(w) \\in \\consts(\\Sigma)$, then $$\n\\begin{align}\n  \\sigma_\\vec{v}(\\mathrm{remap}(\\gamma_\\sigma(w)))\n    \u0026= \\sigma_\\vec{v}(\\mathrm{remap}(\\sigma_\\overline{C}(w))) \\\\\n    \u0026= \\sigma_\\vec{v}(\\sigma_\\overline{C}(w)) \\\\\n    \u0026= \\sigma_\\overline{C}(w) \\\\\n\\end{align}\n$$ as $\\sigma_\\overline{C}(w)$ is just a constant. On the other hand, if $\\sigma_\\overline{C}(w) \\not \\in \\consts(\\Sigma)$, then $$\n\\begin{align}\n  \\sigma_\\vec{v}(\\mathrm{remap}(\\gamma_\\sigma(w)))\n    \u0026= \\sigma_\\vec{v}(\\mathrm{remap}([\\tilde{w}]_{\\sim_T})) \\\\\n    \u0026= (\\sigma \\circ \\mathrm{quotient}^{-1} \\circ \\mathrm{remap}^{-1})(\\mathrm{remap}([\\tilde{w}]_{\\sim_T})) \\\\\n    \u0026= (\\sigma \\circ \\mathrm{quotient}^{-1})([\\tilde{w}]_{\\sim_T}) \\\\\n    \u0026= \\sigma(\\tilde{w}) \\\\\n    \u0026= \\sigma_\\overline{C}(w),\n\\end{align}\n$$where the second last equality is due to $\\sigma$ conforming to $\\sim_T$, and the last equality follows from the choice of $\\tilde{w}$.\n\u003e \u003e \n\u003e \u003e From these calculations we have $\\sigma_\\vec{v}((\\mathrm{remap} \\circ \\gamma_\\sigma)(\\mathrm{Subgoal}_C(\\vec{\\partial C}))) = \\sigma_\\overline{C}(\\mathrm{Subgoal}_C(\\vec{\\partial C}))$. Therefore $\\tau_\\mathrm{Subgoal}$-chasing $\\FullSat(I)$ with $\\sigma_\\vec{v}$ indeed yields $\\sigma_\\overline{C}(\\mathrm{Subgoal}_C(\\vec{\\partial C}))$. We conclude that $I \\wedge \\Sigma_\\mathrm{qrr} \\models \\sigma_\\overline{C}(\\mathrm{Subgoal}_C(\\vec{\\partial C}))$.\n\u003e\n\u003e \u003e *Proof of (2)*. Suppose that $\\sigma_{\\partial C}$ is a ground substitution that covers exactly $\\partial C$. Suppose further that $$\nI \\wedge \\Sigma_\\mathrm{qrr}\n  \\models\n    \\sigma_{\\partial C}(\n      \\mathrm{Subgoal}_C(\\vec{\\partial C})\n    )$$holds. By construction of $\\Sigma_\\mathrm{qrr}$, there must be some\n\u003e \u003e     - $\\Sigma$-ejection template $T = (\\tau_T = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_T, F_T)$,\n\u003e \u003e     - a $T$-closing map $\\gamma_T: \\partial C \\rightarrow {\\sim_T} \\cup \\consts(\\Sigma)$,\n\u003e \u003e     - an injection $\\mathrm{remap}: {\\sim}_T \\rightarrow \\Vars$ and\n\u003e \u003e     - a substitution $\\sigma_\\vec{v}$ that exactly covers $\\vec{v} = \\operatorname{im} (\\mathrm{remap} \\circ \\mathrm{quotient})$\n\u003e \u003e\n\u003e \u003e such that $(T, \\gamma_T)$ generically proves $\\overline{Q}_C$ and $$\n\\begin{align}\n(\n  \\sigma_\\vec{v}\n    \\circ \\mathrm{remap}\n    \\circ \\mathrm{quotient}\n)(\\beta \\wedge F_T)\n  \u0026\\subseteq\n    \\FullSat_{\\Sigma_\\mathrm{qrr}}(I), \\\\\n(\n  \\sigma_\\vec{v}\n    \\circ \\mathrm{remap}\n    \\circ \\gamma_T\n)(\\mathrm{Subgoal}_C(\\vec{\\partial C}))\n \u0026=\n   \\sigma_{\\partial C}(\\mathrm{Subgoal}_C(\\vec{\\partial C})).\n\\end{align}\n$$\n\u003e \u003e\n\u003e \u003e Let $\\phi: {\\sim}_T \\rightarrow \\Consts$ be the map defined by $\\sigma_\\vec{v} \\circ \\mathrm{remap}$. Since $(\\phi \\circ \\mathrm{quotient})(\\beta \\wedge F_T) \\subseteq \\FullSat_{\\Sigma_\\mathrm{qrr}}(I)$, and as $\\Sigma_\\mathrm{qrr}$ is a conservative extenstion of $\\Sigma$ (where we consider $\\mathrm{Subgoal}_C$-s and $\\mathrm{Goal}$ as newly introduced predicate symbols) by construction of $\\Sigma_\\mathrm{qrr}$, $(\\phi \\circ \\mathrm{quotient})(\\beta \\wedge F_T) \\subseteq \\FullSat_{\\Sigma}(I)$. As $(\\phi \\circ \\mathrm{quotient})(\\beta)$ is a set of base facts, $I \\wedge \\Sigma \\models (\\phi \\circ \\mathrm{quotient})(\\beta \\wedge F_T)$.\n\u003e \u003e\n\u003e \u003e Now, by the application of Genericity of Generic Proofs to $(T, \\gamma_T)$ and $\\phi$, $(\\phi \\circ \\mathrm{quotient})(\\beta \\wedge F_T) \\models (\\phi \\circ \\gamma_T)(\\overline{Q}_C)$. As $(\\sigma_\\vec{v} \\circ \\mathrm{remap} \\circ \\gamma_T)(\\mathrm{Subgoal}_C(\\vec{\\partial C})) = \\sigma_{\\partial C}(\\mathrm{Subgoal}_C(\\vec{\\partial C}))$, we have $(\\sigma_\\vec{v} \\circ \\mathrm{remap} \\circ \\gamma_T) = \\sigma_{\\partial C}$. Therefore $$\n\\begin{align}\n  (\\phi \\circ \\gamma_T)(\\overline{Q}_C)\n    \u0026= (\\sigma_\\vec{v} \\circ \\mathrm{remap} \\circ \\gamma_T)(\\overline{Q}_C) \\\\\n    \u0026= \\sigma_{\\partial C}(\\overline{Q}_C),\n\\end{align}\n$$and hence $(\\phi \\circ \\mathrm{quotient})(\\beta \\wedge F_T) \\models \\sigma_{\\partial C}(\\overline{Q}_C)$.\n\u003e \u003e\n\u003e \u003e By transitivity of the $\\models$ relation, we conclude that $I \\wedge \\Sigma \\models \\sigma_{\\partial C}(\\overline{Q}_C)$.\n\n\u003e **Theorem**. $\\mathrm{QueryRuleRewrite1}(\\Sigma, Q)$ is a query-rule-rewriting of $(\\Sigma, Q)$.\n\u003e \n\u003e \u003e *Proof*. Fix $\\Sigma$ and $Q = \\exists \\vec{q}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ and let\n\u003e \u003e  - $(\\Sigma_\\mathrm{qrr}, \\mathrm{Goal}^Q) = \\mathrm{QueryRuleRewrite1}(\\Sigma, Q)$\n\u003e \u003e  - $\\vec{z} = \\mathrm{FV}(Q)$\n\u003e \u003e  - $\\mathcal{H}(\\overline{Q}) = (\\mathcal{V}, \\mathcal{E})$ be the query hypergraph of $\\overline{Q} = \\exists \\vec{z}. Q$\n\u003e \u003e\n\u003e \u003e Take any base instance $I$ and a ground substitution $\\sigma_\\mathrm{sol}$ that covers exactly $\\vec{z}$. We wish to see that $$I \\wedge \\Sigma \\models \\sigma_\\mathrm{sol}(Q) \\Longleftrightarrow I \\wedge \\Sigma_\\mathrm{qrr} \\models \\sigma_\\mathrm{sol}(\\mathrm{Goal^Q}(\\vec{z})) $$holds.\n\u003e \u003e \n\u003e \u003e ($\\Longrightarrow$, the \"completeness\" of the rewrite):\n\u003e \u003e Suppose that $I \\wedge \\Sigma \\models \\sigma_\\mathrm{sol}(Q)$. Then by the universality of $\\SatTree_\\Sigma$, the ground substitution $\\sigma_\\mathrm{sol}$ extends to the factual substitution $\\sigma$ exactly covering $\\vec{z} \\concat \\vec{q}$ such that $\\set{\\sigma(A_j(\\vec{u}_j)) \\mid j \\in J} \\subseteq \\TreeFacts(\\SatTree_\\Sigma(I))$.\n\u003e \u003e \n\u003e \u003e Let $V = \\touchDowners(\\sigma)$ be the touchdowners of $\\sigma$. Since $\\sigma \\supseteq \\sigma_\\mathrm{sol}$, and $\\touchDowners(\\sigma_\\mathrm{sol}) = \\elems(z)$, $V \\supseteq \\elems(\\vec{z})$. Now let $\\set{C_i}_{i \\in I_V}$ be the set of connected components of $\\mathcal{H}(\\overline{Q}-V)$, and let $J_V = \\set{ j \\in J \\mid \\vec{u}_j \\text{ only contains variables from } V}$. By the base-fact completeness of Datalog saturations, it suffices see that the rule $$\\forall \\vec{V}. \\left(\\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\\right) \\wedge \\left(\\bigwedge_{i \\in I_V} \\mathrm{Subgoal}_{C_i}(\\partial C_i)\\right) \\rightarrow \\mathrm{Goal}^Q(\\vec{z})$$is applicable to $\\FullSat_{\\Sigma_\\mathrm{qrr}}(I)$ with the ground substitution $\\sigma \\upharpoonright V$.\n\u003e \u003e \n\u003e \u003e For each $j \\in J_V$, $\\vec{u}_j$ only contains variables from $V$, so $\\sigma(A_j(\\vec{u}_j)))$ is a ground fact. Since $\\sigma(A_j(\\vec{u}_j))) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$ and $\\Sigma_\\mathrm{qrr}$ contains a Datalog rewriting of $\\Sigma$, we have $\\sigma(A_j(\\vec{u}_j))) \\in \\TreeFacts(\\SatTree_{\\Sigma_\\mathrm{qrr}}(I))$. As $\\sigma(A_j(\\vec{u}_j)))$ is a ground fact, $\\sigma(A_j(\\vec{u}_j))) \\in \\FullSat_{\\Sigma_\\mathrm{qrr}}(I)$.\n\u003e \u003e \n\u003e \u003e Take $i \\in I_V$. It remains to see that $\\sigma(\\mathrm{Subgoal}_{C_i}(\\partial C_i)) \\in \\FullSat_{\\Sigma_\\mathrm{qrr}}(I)$. Since $V \\cap \\overline{C_i} = \\partial C_i$, $(\\sigma \\upharpoonright \\overline{C_i})$ exactly covers $\\overline{C_i}$ while $\\touchDowners(\\sigma \\upharpoonright \\overline{C_i}) = \\partial C_i$. Since $$\n\\sigma\\left(\\bigwedge_{j \\in J} A_j(\\vec{u}_j) \\right)\n  \\in \\TreeFacts(\\SatTree_\\Sigma(I)),\n$$and $J_\\overline{C_i} \\subseteq J$, *a fortiori* $$\n(\\sigma \\upharpoonright \\overline{C_i})\\left(\\bigwedge_{j \\in J_\\overline{C_i}} A_j(\\vec{u}_j) \\right)\n  \\in \\TreeFacts(\\SatTree_\\Sigma(I)).\n$$Therefore by (1) of the Subquery-Subgoal Correspondence Lemma, $$\n\\begin{align}\n  I \\wedge \\Sigma_\\mathrm{qrr}\n    \u0026\\models (\\sigma \\upharpoonright \\overline{C_i})(\\mathrm{Subgoal}_{C_i}(\\vec{\\partial C_i})) \\\\\n    \u0026= \\sigma(\\mathrm{Subgoal}_{C_i}(\\vec{\\partial C_i})).\n\\end{align}\n$$Since $\\sigma(\\mathrm{Subgoal}_{C_i}(\\partial C_i))$ is a ground fact, we conclude that $\\sigma(\\mathrm{Subgoal}_{C_i}(\\partial C_i)) \\in \\FullSat_{\\Sigma_\\mathrm{qrr}}(I)$.\n\u003e \u003e \n\u003e \u003e ($\\Longleftarrow$, the \"soundness\" of the rewrite):\n\u003e \u003e Suppose $I \\wedge \\Sigma_\\mathrm{qrr} \\models \\sigma_\\mathrm{sol}(\\mathrm{Goal^Q}(\\vec{z}))$. By construction of $\\Sigma_\\mathrm{qrr}$, there must be some subset $V \\supseteq \\elems(\\vec{z})$ of $\\mathcal{V}$ such that if we write\n\u003e \u003e  - $\\set{C_i}_{i \\in I_V}$ for the set of connected components of $\\mathcal{H}(\\overline{Q}-V)$, and\n\u003e \u003e  - $J_V$ for the set $\\set{ j \\in J \\mid \\vec{u}_j \\text{ only contains variables from } V}$,\n\u003e \u003e \n\u003e \u003e then the ground substitution $\\sigma_\\mathrm{sol}$ can be extended to a ground substitution $\\sigma_V$ that exactly covers $\\vec{V}$ such that $$\n\\sigma_V \\left(\n  \\set{A_j(\\vec{u}_j) \\mid j \\in J_V} \\cup \\set{\\mathrm{Subgoal}_{C_i}(\\partial C_i) \\mid i \\in I_V}\n\\right) \\subseteq \\FullSat_{\\Sigma_\\mathrm{qrr}}(I)\n$$holds, so that the base fact $\\sigma_\\mathrm{sol}(\\mathrm{Goal^Q}(\\vec{z}))$ is $\\Sigma_\\mathrm{qrr}$-derived through the rule $$\\forall \\vec{V}. \\left(\\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\\right) \\wedge \\left(\\bigwedge_{i \\in I_V} \\mathrm{Subgoal}_{C_i}(\\partial C_i)\\right) \\rightarrow \\mathrm{Goal}^Q(\\vec{z}).$$together with $\\sigma_V$.\n\u003e \u003e \n\u003e \u003e Now for each $i \\in I_V$, $\\sigma_V \\upharpoonright (\\partial C_i)$ is a ground substitution exactly covering $\\partial C_i$, so by (2) of the Subquery-Subgoal Correspondence Lemma, $I \\wedge \\Sigma \\models (\\sigma_V \\upharpoonright (\\partial C_i))(\\overline{Q}_{C_i}) = \\sigma_V(\\overline{Q}_{C_i})$.\n\u003e \u003e \n\u003e \u003e Also for each $j \\in J_V$, $I \\wedge \\Sigma_\\mathrm{qrr} \\models \\sigma_V(A_j(\\vec{u}_j))$, but since $\\Sigma_\\mathrm{qrr}$ proves no new instance of existing predicates (i.e. predicates that are not $\\mathrm{Subgoal}$s and $\\mathrm{Goal}^Q$), $I \\wedge \\Sigma \\models \\sigma_V(A_j(\\vec{u}_j))$.\n\u003e \u003e \n\u003e \u003e Therefore, we have $$\n\\begin{align}\nI \\wedge \\Sigma\n  \u0026\\models \\left(\n    \\bigwedge_{j \\in J_V} \\sigma_V(A_j(\\vec{u}_j))\n  \\right) \\wedge \\left(\n    \\bigwedge_{i \\in I_V}\\sigma_V(\\overline{Q}_{C_i})\n  \\right).\n\\end{align}\n$$Now $$\n\\begin{align}\n  \\left(\n    \\bigwedge_{j \\in J_V} \\sigma_V(A_j(\\vec{u}_j))\n  \\right) \u0026\\wedge \\left(\n    \\bigwedge_{i \\in I_V}\\sigma_V(\\overline{Q}_{C_i})\n  \\right) \\\\\n    \u0026= \\sigma_V \\left(\n      \\left(\n        \\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\n      \\right) \\wedge \\left(\n        \\bigwedge_{i \\in I_V} \\overline{Q}_{C_i}\n      \\right)\n    \\right) \\\\\n    \u0026= \\sigma_V \\left(\n      \\left(\n        \\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\n      \\right) \\wedge \\left(\n        \\bigwedge_{i \\in I_V}\n          \\exists \\vec{C_i}. \\bigwedge_{j \\in J_\\overline{C_i}} A_j(\\vec{u}_j)\n      \\right)\n    \\right) \\\\\n    \u0026\\equiv \\sigma_V \\left(\n      \\left(\n        \\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\n      \\right) \\wedge \\left(\n        \\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}.\n        \\bigwedge_{i \\in I_V}\n          \\bigwedge_{j \\in J_\\overline{C_i}} A_j(\\vec{u}_j)\n      \\right)\n    \\right) \\\\\n    \u0026\\equiv \\sigma_V \\left(\n      \\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}.\n      \\left(\n        \\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\n      \\right) \\wedge \\left(\n        \\bigwedge_{i \\in I_V}\n          \\bigwedge_{j \\in J_\\overline{C_i}} A_j(\\vec{u}_j)\n      \\right)\n    \\right) \\\\\n    \u0026\\equiv \\sigma_V \\left(\n      \\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}.\n      \\bigwedge_{j \\in J} A_j(\\vec{u}_j)\n    \\right)\n\\end{align}\n$$where $J_\\overline{C_i} = \\set{ j \\in J \\mid \\vec{u}_j \\text{ only mentions variables from } \\overline{C_i}}$, and the last equivalence is justified by the fact that $J_V \\cup \\bigcup \\set{J_\\overline{C_i} \\mid i \\in I_V} = J$ (which is straightforward to check) and by the $\\wedge$-commutativity. Therefore $$I \\wedge \\Sigma\n  \\models \\sigma_V \\left(\n      \\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}.\n      \\bigwedge_{j \\in J} A_j(\\vec{u}_j)\n    \\right).\n  $$Now, restricting $\\sigma_V$ to $\\elems(\\vec{z})$ yields $\\sigma_\\mathrm{sol}$, and existentially quantifying all variables in $V \\setminus \\elems(\\vec{z})$ from the formula $\\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ yields the original query $Q$, since $\\set{\\elems(C_i) \\mid i \\in I_V}$ is a disjoint cover of $(\\elems(\\vec{q} \\concat \\vec{z})) \\setminus V$.\n\u003e \u003e\n\u003e \u003e We therefore conclude that $I \\wedge \\Sigma \\models \\sigma_\\mathrm{sol}(Q)$.\n","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/notes/Tentacle-Ejection-Templates":{"title":"Tentacle Ejection Templates","content":"\n## Preliminaries\n\n### In-place unifications\n\nWe shall first define what it means to identify (in-place) variables in a GTGD rule.\n\n\u003e **Definition**. Let $\\vec{x}$ be a set of variables. An *in-place unification on $\\vec{x}$* is a partition $\\sim_\\vec{x}$ of $\\elems(\\vec{x})$.\n\u003e \n\u003e \u003e **Example**. If $\\vec{x} = (x_0, x_1, x_2, x_3)$, then an equivalence relation given by a partition $\\set{\\set{x_0}, \\set{x_1, x_3}, \\set{x_2}}$ is an in-place unification on $\\vec{x}$.\n\n## Tentacle Ejection Templates\n\nWe first describe an object that abstractly describe a situation where a tentacle hangs from some saturation of some base instance:\n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs and $\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma$. A *$(\\tau, \\Sigma)$-export template* is a set $F$ of atomic formulae such that each $A \\in F$\n\u003e   1. only mentions constants from $\\Sigma$, and\n\u003e   2. only mentions variables in $\\elems(\\vec{x})$ that appear in some atom in $\\eta$.\n\u003e\n\u003e \u003e *Example*. Let $\\tau = \\forall x_1, x_2. R_1(x_1, x_2) \\wedge U(x_1) \\wedge P(c_0) \\rightarrow \\exists y. H(x_2, y, c_1)$ and $\\Sigma = \\set{\\tau}$. Then the following are all $(\\tau, \\Sigma)$-export templates:\n\u003e \u003e   - $\\set{R_1(x_2, c_1), R_1(x_2, x_2)}$\n\u003e \u003e   - $\\set{R_1(c_0, c_1), U(x_2)}$\n\u003e \u003e   - $\\set{H(x_2, x_2, x_2), P(x_2)}$\n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs. A *$\\Sigma$-tentacle ejection template* is a triple $(\\tau, \\sim_\\tau, F_\\tau)$ where $\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma$, $\\sim_\\tau$ is an in-place unification on $\\vec{x}$ and $F_\\tau$ is a $(\\tau, \\Sigma)$-export template.\n\nNext, we define what is means to \"instantiate\" $\\Sigma$-tentacle ejection templates.\n\n\u003e **Definition**. Let $\\vec{x}$ be a set of variables and $\\sim_\\vec{x}$ an in-place unification on $\\vec{x}$. A factual substitution $\\sigma: \\Vars \\rightharpoonup \\Consts$ is said to *conform to $\\sim_\\vec{x}$* if $\\sigma$ covers exactly $\\vec{x}$ and for each $x_1, x_2 \\in \\elems(\\vec{x})$, and $$\\sigma(x_1) = \\sigma(x_2) \\Longleftrightarrow x_1 \\sim_\\vec{x} x_2.$$ In other words, $\\sigma$ covering exactly $\\vec{x}$ conforms to $\\sim_\\vec{x}$ if and only if $\\mathrm{ker}(\\sigma) = \\sim_\\vec{x}$ where $\\mathrm{ker}(\\sigma)$ is the set-theoretic kernel of $\\sigma$.\n\u003e\n\u003e \u003e *Example*. If $\\vec{x} = (x_0, x_1, x_2, x_3)$ and $\\elems(\\vec{x}) / \\sim_\\vec{x} = \\set{\\set{x_0}, \\set{x_1, x_3}, \\set{x_2}}$ as in the previous example, then a substitution $\\sigma$ given by $$\n\\begin{array}{c c}\n  \\sigma: \u0026\\Vars \u0026\\rightharpoonup \u0026\\Consts \\\\\n          \u0026x_0 \u0026\\mapsto \u0026c_3 \\\\\n          \u0026x_1 \u0026\\mapsto \u0026c_6 \\\\\n          \u0026x_2 \u0026\\mapsto \u0026c_2 \\\\\n          \u0026x_3 \u0026\\mapsto \u0026c_6 \\\\\n\\end{array}\n$$ conforms to $\\sim_\\vec{x}$.\n\n\u003e **Definition** Let $\\Sigma$ be a finite set of GTGDs, and $T = (\\tau = \\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template. Given a ground substitution $\\sigma$ that conforms to $\\sim_\\tau$, the *$\\Sigma$-instantiation $\\Tentacle_\\Sigma(T, \\sigma)$ of $T$ fired with $\\sigma$* is defined as the subtree of $\\SatTree_\\Sigma(\\sigma(F_\\tau \\cup \\beta))$ induced by the set of nodes in $\\SatTree_\\Sigma(\\sigma(F_\\tau \\cup \\beta))$ that either\n\u003e   1. is the root node, or\n\u003e   2. corresponds to a valid generative $\\Sigma$-chase-path on $\\sigma(F_\\tau)$ and starts with $(\\tau, \\sigma)$.\n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance, $T = (\\tau = \\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta, \\sim_\\tau, F_\\tau)$ a $\\Sigma$-tentacle ejection template and $\\sigma$ a factual substitution conforming to $\\sim_\\tau$. We say that *$T$ can be $\\Sigma$-instantiated on $I$ using $\\sigma$* if $\\sigma(F_\\tau \\cup \\beta) \\subseteq \\FullSat_\\Sigma(I)$.\n\nAn instantiation of a $\\Sigma$-tentacle ejection template on an instance embeds into the $\\SatTree$ of the instance, in the following sense:\n\n\u003e **Proposition (Ejection Embedding)**.\n\u003e Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance and $T = (\\tau, \\sim_\\tau, F_\\tau)$ a $\\Sigma$-tentacle ejection template that can be instantiated on $I$ using $\\sigma$. Then for each node $\\vec{d}$ in $\\Tentacle_\\Sigma(T, \\sigma)$,\n\u003e  1. $\\vec{d}$ is a valid generative $\\Sigma$-chase-path on $I$, i.e. is a node in $\\SatTree_\\Sigma(I)$, and moreover,\n\u003e  2. $\\Instance_{\\Tentacle_\\Sigma(T, \\sigma)}(\\vec{d}) \\subseteq \\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$\n\u003e \n\u003e \u003e *Proof*. Since $\\Tentacle_\\Sigma(T, \\sigma)$ is a subtree of $\\SatTree_\\Sigma(\\sigma(F_\\tau \\cup \\beta))$, the proposition is obvious from the SatTree monotonicity.\n\n### Tentacle Abstraction\n\nWe have just seen that the instantiation of a tentacle $(\\tau, \\sim_\\tau, F_\\tau)$ with a substitution $\\sigma$ is a way of turning a tentacle ejection template into a chase-like tree that can be actually embeded to a tentacle hanging from $(\\tau, \\sigma)$.\n\nWe now describe a way to \"abstract\" an actual tentacle to a tentacle ejection template that can be instantiated back exactly to the original tentacle.\n\n\u003e **Definition**. Let $(\\tau, \\sigma)$ be a valid generative $\\Sigma$-chase-path on $I$. We say that a $\\Sigma$-tentacle ejection template $T = (\\tau_T, \\sim_T, F_T)$ is an *abstraction of $(\\tau, \\sigma)$ over $I$* if\n\u003e   - $\\tau_T = \\tau$\n\u003e   - $\\sigma$ conforms to $\\sim_T$\n\u003e   - $\\sigma(F_T) = \\exports_\\Sigma(I, (\\tau, \\sigma))$\n\nThe next proposition shows that we can always abstract a valid generative $\\Sigma$-chase-path on a base instance.\n\n\u003e **Proposition (existence of abstraction)**. Let $(\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta), \\sigma)$ be a valid generative $\\Sigma$-chase-path on a base instance $I$. Then there exists an abstraction of $(\\tau, \\sigma)$ over $I$. ^d4d09d\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e Let $E = \\exports_\\Sigma(I, (\\tau, \\sigma))$, $D = (\\operatorname{im} \\sigma \\cap \\consts(E)) \\setminus \\consts(\\Sigma)$ and $V \\subseteq \\elems(\\vec{x})$ be variables in $\\vec{x}$ that appear in some atom in $\\eta$ (these are the *exported variables of $\\tau$*).\n\u003e \u003e \n\u003e \u003e We first claim the following:\n\u003e \u003e \n\u003e \u003e \u003e **Claim 1**. $\\sigma \\upharpoonright V: V \\rightarrow D$ is a surjection onto $D$. In particular, there exists a right-inverse $\\sigma^{-1}: D \\rightarrow V$ of $\\sigma \\upharpoonright V$, so that $\\sigma \\circ \\sigma^{-1} = \\mathrm{id}_D$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e *Proof*. Take any constant $c \\in D$. Then $c$ occurs in $E$, so $c$ is $\\Sigma$-guarded by some fact $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](G(\\vec{t}))$ in $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta)$ (where $\\nu$ is some null-picking function). As $c \\in D$, $c$ does not occur in $\\Sigma$, hence the fact $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](G(\\vec{t}))$ must contain $c$. Moreover, as $c$ does not occur in $\\Sigma$, $G(\\vec{t})$ does not contain $c$, so $\\sigma$ must introduce $c$ to the fact $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](G(\\vec{t}))$. Hence there is variable $x$ occuring in $G(\\vec{t})$ such that $\\sigma(x) = c$, and we are done since $x \\in V$.\n\u003e \u003e \n\u003e \u003e Let $\\sigma^{-1}: D \\rightarrow V$ be the right-inverse of $\\sigma \\upharpoonright V$ constructed in Claim 1, and now let $F = \\sigma^{-1}(E)$ (assume that every constant not in $D$ is sent as-is by $\\sigma^{-1}$). Then by construction $\\sigma(F) = E$.\n\u003e \u003e \n\u003e \u003e Next, we make the following useful claim:\n\u003e \u003e \n\u003e \u003e \u003e **Claim 2**. For each atomic formula $A \\in F$, $(\\sigma^{-1} \\circ \\sigma)(A) = A$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e *Proof*. By construction of $F$, $A = \\sigma^{-1}(B)$ for some fact $B \\in E$. But since $\\sigma^{-1}$ is a right-inverse of $\\sigma \\upharpoonright V$, $$\n\\begin{align}\n(\\sigma^{-1} \\circ \\sigma)(A)\n  \u0026= (\\sigma^{-1} \\circ \\sigma \\circ \\sigma^{-1})(B) \\\\\n  \u0026= (\\sigma^{-1} \\circ (\\sigma \\upharpoonright V) \\circ \\sigma^{-1})(B) \\\\\n  \u0026= \\sigma^{-1}(B) \\\\\n  \u0026= A\n\\end{align}\n$$\n\u003e \u003e \n\u003e \u003e We now claim that $F$ is a $(\\tau, \\Sigma)$-export template. Since every atom $A$ in $F$ can be written as $A = \\sigma^{-1}(R(\\vec{c}))$ for some fact $R(\\vec{c}) \\in E$, we need to check that for each $R(\\vec{c}) \\in E$, the atom $\\sigma^{-1}(R(\\vec{c})) \\in F$\n\u003e \u003e   - *(only mentions constants from $\\Sigma$)*: Take a constant $a$ in $\\sigma^{-1}(R(\\vec{c}))$. Assume for contradiction that $a$ does not appear in $\\Sigma$.\n\u003e \u003e     \n\u003e \u003e     We must have $a \\not \\in D$; if $a \\in D$, then by Claim 2 the atom $\\sigma^{-1}(R(\\vec{c})) = (\\sigma^{-1} \\circ \\sigma \\circ \\sigma^{-1})(R(\\vec{c}))$ would not contain $a$, since the outer $\\sigma^{-1}$ would send $\\sigma(a) = a \\in D$ to a variable, contradicting the choice of $a$.\n\u003e \u003e     \n\u003e \u003e     Since $a \\not \\in D = (\\operatorname{im} \\sigma \\cap \\consts(E)) \\setminus \\consts(\\Sigma)$ while $a \\not \\in \\consts(\\Sigma)$, we must have either $a \\not \\in \\operatorname{im} \\sigma$ or $a \\not \\in \\consts(E)$. It is impossible that $a \\not \\in \\consts(E)$, since $F$ is obtained by replacing a constants in $E$ by variables. Hence $a \\not \\in \\operatorname{im} \\sigma$.\n\u003e \u003e     \n\u003e \u003e     As $R(\\vec{c}) \\in E$, $R(\\vec{c}) = \\sigma(\\sigma^{-1}(R(\\vec{c})))$ is $\\Sigma$-guarded by some fact in $\\chaseHead_\\nu(\\tau, \\sigma) = \\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta)$. In particular, $a = \\sigma(a)$ appears either in $\\Sigma$ or in some atom of $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta)$.\n\u003e \u003e     \n\u003e \u003e     If $a$ appears in some atom of $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta)$, then $a$ must appear in $\\eta$, since $a \\not \\in \\operatorname{im} \\sigma$. In any case $a$ appears in $\\Sigma$, hence a contradiction.\n\u003e \u003e\n\u003e \u003e   - *(only mentions variables from $\\elems(\\vec{x})$ that appear in some atom in $\\eta$)*: This is obvious from the construction of $F$, since $\\sigma^{-1}: D \\rightarrow V$.\n\u003e \u003e \n\u003e \u003e We now have that $(\\tau, \\operatorname{ker} \\sigma, F)$ is an abstraction of $(\\tau, \\sigma)$.\n\nAs expected, instantiation of an abstraction of chase-step direction $(\\tau, \\sigma)$ equals the tentacle hanging from $(\\tau, \\sigma)$, as formulated in the following lemma.\n\n\u003e **Lemma (abstraction-instantiation)**. Let $(\\tau, \\sigma)$ be a valid generative $\\Sigma$-chase-path on $I$, and $T = (\\tau, \\sim, F)$ be an abstraction of $(\\tau, \\sigma)$ over $I$. ^efa86e\n\u003e \n\u003e Then for all nonempty valid generative $\\Sigma$-chase-path $\\vec{d}$ on $I$, if $\\vec{d}$ starts with $(\\tau, \\sigma)$, then $\\Instance_{\\Tentacle_\\Sigma(T, \\sigma)}(\\vec{d}) = \\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$.\n\u003e \n\u003e \u003e *Proof*. Let $\\tau = \\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta$. We proceed by induction on $\\vec{d}$. \n\u003e \u003e \n\u003e \u003e (base case $\\vec{d} = ((\\tau, \\sigma))$): We first make the following claim: \n\u003e \u003e \n\u003e \u003e \u003e **Claim**. $$\\exports_\\Sigma(I, (\\tau, \\sigma)) = \\exports_\\Sigma(\\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta), (\\tau, \\sigma))$$\n\u003e \u003e \u003e *Proof*.\n\u003e \u003e \u003e ($\\subseteq$): Take any $F \\in \\exports_\\Sigma(I, (\\tau, \\sigma))$. Then $F$ is guarded by $\\chaseHead_\\nu(\\tau, \\sigma)$, and $F \\in \\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta)$ so $F \\in \\exports_\\Sigma(\\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta), (\\tau, \\sigma))$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e ($\\supseteq$): Follows from the fact that $I \\supseteq \\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta)$.\n\u003e \u003e\n\u003e \u003e Now $$\n\n\\begin{align}\n\\Instance_{\\SatTree_{\\Sigma(I)}}(\\vec{d})\n  \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{SC}_{\\Sigma, ()}(I), (\\tau, \\sigma))) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(I, (\\tau, \\sigma))) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chaseHead_{\\widehat{\\#_{\\vec{d}}}}(\\tau, \\sigma) \\cup \\exports_\\Sigma(I, (\\tau, \\sigma))) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chaseHead_{\\widehat{\\#_{\\vec{d}}}}(\\tau, \\sigma) \\cup \\exports_\\Sigma(\\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta), (\\tau, \\sigma)) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta), (\\tau, \\sigma))) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\sigma(F \\cup \\beta), (\\tau, \\sigma))) \\\\\n  \u0026= \\Instance_{\\SatTree_\\Sigma(\\sigma(F \\cup \\beta))}(\\vec{d}) \\\\\n  \u0026= \\Instance_{\\Tentacle_\\Sigma(T, \\sigma)}(\\vec{d})\n\\end{align}\n$$so we are done.\n\u003e \u003e\n\u003e \u003e (inductive part): Obvious.\n\n\n## Generic Proofs\n\nThroughout this section, whenever we take a generic $\\Sigma$-tentacle ejection template $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$ and a (not necessarily boolean) conjunctive query $Q = \\exists \\vec{z}. \\bigwedge_{i \\in I} A_i(\\vec{w_i})$, by renaming bound variables we shall assume that $\\vec{x}, \\vec{y}$, $\\vec{z}$ and $\\operatorname{FV}(Q)$ are all disjoint to each other.\n\n\u003e **Definition**. For a set $\\Sigma$ of finite GTGDs, a *$\\Sigma$-generic constant assignment* is a computable injection $\\GenConst_\\Sigma: \\mathcal{P}_\\mathrm{fin}(\\Vars) \\rightarrow \\Consts$ such that $\\mathrm{im}(\\GenConst) \\cap \\consts(\\Sigma) = \\emptyset$.\n\nFrom now on, we shall assume that, for each $\\Sigma$, we have decided a choice on a $\\Sigma$-generic constant assignment $\\GenConst_\\Sigma$. We shall refer to this particular function as *the* $\\Sigma$-generic constant assignment.\n\n\u003e **Definition**. Let $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template. The *generic instance $\\GenInst_\\Sigma(T)$ associated with $T$* is the instance $$\n\\GenInst_\\Sigma(T) :=\n  (\\GenConst_\\Sigma \\circ \\mathrm{quotient}_{\\sim_T})(F_\\tau \\wedge \\beta)\n$$ where $\\mathrm{quotient}_{\\sim_T}: \\elems(\\vec{x}) \\rightarrow {\\sim_\\tau}$ is the quotient map $x \\mapsto [x]_{\\sim_\\tau}$.\n\n\u003e **Definition**. Let $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template, and let $Q$ be a (*not necessarily boolean*) conjunctive query.  A *$T$-closing map on $Q$* is a map $\\gamma: \\operatorname{FV}(Q) \\rightarrow ({\\sim}_\\tau \\cup \\consts(\\Sigma))$.\n\n\u003e **Definition**. Let $T$ be a $\\Sigma$-tentacle ejection template, $Q$ a conjunctive query and $\\gamma: \\mathrm{FV}(Q) \\rightarrow ({\\sim_T} \\cup \\mathrm{consts}(\\Sigma))$ a $T$-closing map on $Q$. We say that $(T, \\gamma)$ *generically $\\Sigma$-proves* $Q$ when $\\GenInst_\\Sigma(T) \\wedge \\Sigma \\models (\\mathrm{GenConst}_\\Sigma \\circ \\gamma)(Q)$.\n\nGeneric $\\Sigma$-proofs are \"generic\" because there is no assumption on constants symbols appearing in $\\mathrm{GenInst}_\\Sigma(T)$ (other than those appear in $\\Sigma$), and we can treat them essentially as universally quantified variables (just like the usual Generalization Rule in the first-order calculus). The reason we are not working with variables and with constants is to make clear how we are reducing query-rewriting problem into the BCQ answering problem over GTGD rules.\n\nThe next proposition formalizes this idea.\n\n\u003e **Proposition** (Genericity of Generic Proofs). Suppose $T$ is a $\\Sigma$-tentacle ejection template, $Q$ a conjunctive query and $\\gamma: \\mathrm{FV}(Q) \\rightarrow ({\\sim_T} \\cup \\consts(\\Sigma))$ a $T$-closing map on $Q$.\n\u003e \n\u003e If $(T, \\gamma)$ generically proves $Q$ and $\\phi: {\\sim_T} \\rightarrow \\Consts$ is any map with the displayed signature, then $(\\phi \\circ \\mathrm{quotient}_{\\sim_T})(F_T \\wedge \\beta) \\wedge \\Sigma \\models (\\phi \\circ \\gamma)(Q)$.\n\u003e \n\u003e \u003e *Proof*. As $\\mathrm{GenConst}_\\Sigma$ is an injection, we may pick a retraction $\\mathrm{GenConst}_\\Sigma^{-1}$ of $\\mathrm{GenConst}_\\Sigma$.\n\u003e \u003e \n\u003e \u003e By assumption, $(\\GenConst_\\Sigma \\circ \\mathrm{quotient}_{\\sim_T})(F_\\tau \\wedge \\beta) \\wedge \\Sigma \\models (\\mathrm{GenConst}_\\Sigma \\circ \\gamma)(Q)$. Now, consider the consts translation $\\psi := \\phi \\circ \\mathrm{GenConst}_\\Sigma^{-1}: \\Consts \\rightarrow \\Consts$ that fixes all constants not in the image of $\\mathrm{GenConst}_\\Sigma$. As $\\psi$ fixes $\\consts(\\Sigma)$ and rule-query entailment is preserved by $\\consts(\\Sigma)$-fixing consts translations, we have $$\n\\begin{align}\n  (\n    \\phi \\circ\n    \\mathrm{quotient}_{{\\sim}_T}\n  )(\n    F_T \\wedge \\beta\n  ) \\wedge \\Sigma\n  \u0026= \\psi((\n    \\mathrm{GenConst}_\\Sigma \\circ\n    \\mathrm{quotient}_{{\\sim}_T}\n  )(F_T \\wedge \\beta)) \\wedge \\Sigma \\\\\n  \u0026\\models \\psi(\n    (\\mathrm{GenConst}_\\Sigma \\circ \\gamma)(Q)\n  ) \\\\\n  \u0026= (\\phi \\circ \\gamma)(Q) \\\\\n\\end{align}\n$$\n","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/notes/Witness-Fragmentation-and-Witness-Gluing":{"title":"Witness Fragmentation and Witness Gluing","content":"\n\u003e This note depends on [[Preliminary Results on Saturated Chase-Like Trees]].\n\nThis note explores the relationship between ordinary witnesses and \"fragmented witnesses\", which will be defined in the following sections. First, we begin with some preliminary definitions.\n\n\u003e **Definition**. For a boolean conjunctive query $Q$ and its witness $(\\sigma, \\mathcal{F})$, the *set of touchdowners* $\\touchDowners(\\sigma)$ of $\\sigma$ is the set $\\sigma^{-1}[\\consts(\\mathcal{F})]$ of variables that get sent to constants in $\\mathcal{F}$.\n\u003e \n\u003e **Examples**: ![[Pasted image 20221116200624.png]]![[Pasted image 20221116200657.png]] \n\n\u003e **Definition**. For a valid generative chase-path $((\\tau, \\sigma))$ on $I$, we define the *tentacle of $\\SatTree_\\Sigma(I)$ hanging from $(\\tau, \\sigma)$* to be the subtree of $\\SatTree_\\Sigma(I)$ induced by all descendants of the node $((\\tau, \\sigma))$. We call $(\\tau, \\sigma)$ the *wrist* of the tentacle that hangs from $(\\tau, \\sigma)$.\n\n\u003e **Definition**. For a binary conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_i Q_i(\\vec{x'}_i)$, the *query structure hypergraph $\\mathcal{H}(Q)$* of $Q$ is the labelled hypergraph defined with\n\u003e  - the vertex set $V_Q = \\elems(\\vec{x})$\n\u003e  - for each $i$, a hyperedge named $Q_i$ that spans $\\elems(\\vec{x'}_i) \\subseteq V_Q$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_i Q_i(\\vec{x'}_i)$ and a subset $X$ of $\\elems(\\vec{x})$, the *$X$-masked query structure hypergraph*, denoted $\\mathcal{H}(Q-X)$, is the hypergraph obtained by weak-deleting [^1] all vertices in $X$.\n\n## Witness Gluing\n\nWe can \"glue\" small witnesses together to form a $(\\Sigma, I)$-witness for a query. To make this precise, we start with some definitions.\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ is *a base-factual substitution* if $\\operatorname{im} \\sigma \\subseteq \\Consts$, and that it is a *null-factual substitution* if $\\operatorname{im} \\sigma \\subseteq \\Nulls$.\n\n\u003e **Definition**. Given a finite set $\\Sigma$ of GTGDs, a base instance $I$ and a boolean conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, a *Q-fragmented substitution* is a pair $(\\sigma_b, \\set{ \\sigma'_V }_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b))})$ such that\n\u003e  - $\\sigma_b$ is a base-factual substitution such that $\\domain(\\sigma_b) \\subseteq \\elems(\\vec{x})$\n\u003e  - for each $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$, $\\sigma'_V$ is a null-factual substitution with $\\domain(\\sigma'_V) = V$.\n\u003e\n\u003e \u003e *Notational convention*. We will often omit the indexing set of the family $\\set{\\sigma'_V}_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b))}$ and simply write it as $\\set{\\sigma'_V}_V$.\n\n\u003e **Remark**. By construction, a $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$ is a *collection of compatible factual substitutions*, in a sense that $\\sigma_b \\not\\in \\set{\\sigma'_V}_V$, and for each pair $\\sigma_1, \\sigma_2$ of factual substitutions in the set $\\set{ \\sigma_b } \\cup \\set{ \\sigma'_V }_V$, $\\domain(\\sigma_1) \\cup \\domain(\\sigma_2) \\neq \\emptyset \\Longrightarrow \\sigma_1 = \\sigma_2$.\n\n\u003e **Definition**. By the previous remark, for a $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$, the set-theoretic union $\\bigcup(\\set{ \\sigma_b } \\cup \\set{ \\sigma'_V }_V)$ is a well-defined factual substitution. We shall call this union the *gluing of $(\\sigma_b, \\set{\\sigma'_V}_V)$*, and denote it by $\\Glue_Q(\\sigma_b, \\set{\\sigma'_V}_V)$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, a $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$ is said to be a *$Q$-fragmented $(\\Sigma, I)$-witness for $Q$* if\n\u003e  - for each $Q_j(\\vec{x'}_j)$ in $Q$ such that $\\elems(\\vec{x'}_j) \\subseteq \\domain(\\sigma_b)$, the fact $Q_j(\\sigma_b(\\vec{x'}_j))$ is an element of $\\Sat_\\Sigma(I)$, which is the instance assigned to the root of $\\SatTree_\\Sigma(I)$\n\u003e  - for each connected component $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$ and each predicate $Q_j(\\vec{x'}_j)$ corresponding to an edge $Q_j$ contained in $V$, the fact $Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j))$ is an element of $\\TreeFacts(\\SatTree_\\Sigma(I))$.\n\nThen almost by definition we obtain the following lemma:\n\n\u003e **Lemma (Witness Gluing)**. Suppose $(\\sigma_b, \\set{\\sigma'_V}_V)$ is a $Q$-fragmented $(\\Sigma, I)$-witness for $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$. Then $(\\Glue_Q(\\sigma_b, \\set{\\sigma'_V}_V), \\SatTree_\\Sigma(I))$ is a witness for $Q$.\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e Write $\\sigma$ for the factual substitution $\\Glue_Q(\\sigma_b, \\set{\\sigma'_V}_V)$. Clearly $\\sigma$ exactly covers $\\vec{x}$.\n\u003e \u003e \n\u003e \u003e Now pick $j \\in J$. We need to see that $Q_j(\\sigma(\\vec{x'}_j))$ is an element of $\\TreeFacts(\\SatTree_\\Sigma(I))$.\n\u003e \u003e \n\u003e \u003e If the edge $Q_j$ does not span any vertex in $\\mathcal{H}(Q - \\domain(\\sigma_b))$, then $Q_j$ does not mention any variable *not in* $\\domain(\\sigma_b)$. Hence $\\elems(\\vec{x'}_j) \\subseteq \\domain(\\sigma_b)$, so by the assumption on $(\\sigma_b, \\set{\\sigma'_V}_V)$, the fact $Q_j(\\sigma_b(\\vec{x'}_j))$ appears in $\\Sat_\\Sigma(I)$, hence in $\\TreeFacts(\\SatTree_\\Sigma(I))$.\n\u003e \u003e \n\u003e \u003e So suppose that $Q_j$ does span a vertex $x$ in $\\mathcal{H}(Q - \\domain(\\sigma_b))$. Then $x$ belongs to some connected component $V$ of $\\mathcal{H}(Q - \\domain(\\sigma_b))$, and by definition of being a connected component $Q_j$ spans vertices in $V$. So by assumption on $(\\sigma_b, \\set{\\sigma'_V}_V)$, $Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j))$ is an element of $\\TreeFacts(\\SatTree_\\Sigma(I))$. As $\\sigma \\supseteq \\sigma_V \\circ \\sigma_b$, $Q_j(\\sigma(\\vec{x'}_j)) = Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j)) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$.\n\n## Fragmentation and Gluing\n\nIn this section, we shall see that fragmented witnesses and witnesses are in a bijective relation via the gluging operation and its inverse operation, which we shall call \"fragmentation\".\n\nWe begin with the definition of the fragmentation operator $\\Frag_Q$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$ and a factual substitution $\\sigma$ covering $\\vec{x}$, define the *fragmentation $\\Frag_Q(\\sigma)$ of $\\sigma$* as the $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))})$, where\n\u003e  - $\\sigma_b$ is a restriction of $\\sigma$ to $\\touchDowners(\\sigma)$\n\u003e  - for each $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$, $\\sigma'_V: V \\rightarrow \\Facts$ is a restriction of $\\sigma$ to $V$\n\nThen the following holds:\n\n\u003e **Lemma (Witness Fragmentation)**. If $\\sigma$ is a $(\\Sigma, I)$-witness for a BCQ $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, then $\\Frag_Q(\\sigma)$ is a $Q$-fragmented $(\\Sigma, I)$-witness for $Q$.\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e Let $(\\sigma_b, \\set{\\sigma'_V}_V) = \\Frag_Q(\\sigma)$. We check that this is in fact a $Q$-fragmented $(\\Sigma, I)$-witness for $Q$ according to the definition of $Q$-fragmented witnesses.\n\u003e \u003e \n\u003e \u003e To check the first condition, take $j \\in J$ such that $\\elems(\\vec{x'}_j) \\subseteq \\domain(\\sigma_b)$. Then since $Q_j(\\sigma(\\vec{x'}_j)) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$, by a consequence of Fact Introduction lemma, $Q_j(\\sigma(\\vec{x'}_j)) \\in \\Sat_\\Sigma(I)$.\n\u003e \u003e \n\u003e \u003e To check the second condition, take $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$ and $j \\in J$ such that $Q_j$ lies entirely in $V$. Now $(\\sigma_V \\circ \\sigma_b)(x) = \\sigma(x)$ for each $x \\in V \\cup \\domain(\\sigma_b)$ by construction of $\\sigma_V$ and $\\sigma_b$, and as $\\vec{x'}_j$ only contains variables from $V \\cup \\domain(\\sigma_b)$, $Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j)) = Q_j(\\sigma(\\vec{x'}_j)) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$.\n\nAs a corollary, we have the following propositions:\n\n\u003e **Proposition**. $\\Frag_Q$ defines a assignment of $Q$-fragmented $(\\Sigma, I)$-witnesses for $Q$ on the set of $(\\Sigma, I)$-witnesses for $Q$\n\n\u003e **Theorem (Fragmentation-Gluing Bijection)**. For a BCQ $Q$, $\\Frag_Q$ and $\\Glue_Q$ are mutual bijections between $(\\Sigma, I)$-witnesses for $Q$ and $Q$-fragmented $(\\Sigma, I)$-witnesses for $Q$.\n\u003e \n\u003e \u003e *Proof*. We only need to check that the two maps are mutual inverses. But this is the case by definition: $\\Frag_Q \\circ \\Glue_Q$ essentially unions fragmented substitutions and then restricts them to respective domains, while $\\Glue_Q \\circ \\Frag_Q$ unions all restricted substitutions, recovering the original substitution.\n\n\n[^1]: see Ch. 7, [[Books#^327283]] for details","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/notes/definitions/Chase-Like-Trees-and-Saturated-Chase-Like-Trees":{"title":"Chase-Like Trees and Saturated Chase-Like Trees","content":"\n\u003e This note builds on [[Saturations]]\n\nWe shall define a tree structure that \"stems from a base instance $I$ and witnesses every possible conclusion that can be $\\Sigma$-deduced from $I$\". To make this idea precise, we define a few concepts.\n\n## Some generic definitions \n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs. We say that _a set $G$ of factual terms is $\\Sigma$-guarded by a set of factual terms $\\vec{t}$_ when $G \\subseteq \\consts(\\Sigma) \\cup \\vec{t}$ .\n\n\u003e **Definition**. Injective functions of the form $\\nu: \\mathbb{N} \\rightarrow \\Nulls$ will be referred to as *null-picking functions*.\n\n\u003e **Definition**. For a null-picking function $\\nu$, a vector $\\vec{y} = (y_1, \\ldots, y_n)$ of variables and a factual substitution $\\sigma$ whose domain is disjoint from $\\vec{y}$, we define *the factual substitution $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls]$* with domain $\\domain(\\sigma) + \\elems(\\vec{y})$ that substitutes each $y_i$ to distinct nulls (chosen by $\\nu$) and follows $\\sigma$ elsewhere: $$\n\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](x)=\n\\begin{cases}\n    n_{\\nu(i)} \u0026 \\text{if $x = y_i$} \\\\\n    \\sigma(x) \u0026 \\text{if $x \\in \\domain(\\sigma)$}\n\\end{cases}$$\n\n\u003e **Definition**. For a TGD $\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$, an instance $I$ and a factual substitution $\\sigma$ that covers $\\vec{x}$, we say that *$I$ can be $\\tau$-chased with $\\sigma$* when $\\sigma(\\beta) \\subseteq I$.\n\nIntuitively, this means that the premise $\\beta$ is witnessed by some facts in $I$, and $\\sigma$ specifies which constant or null appearing in $I$ is witnessing each variable in $\\vec{x}$.\n\nWe shall describe how an instance can be \"extended\" by applying a GTGD.\n\n\u003e **Definition**. Given a null-picking function $\\nu$, a finite set $\\Sigma$ of GTGDs, an element $\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma$ and an instance $I$ that can be $\\tau$-chased with a factual substitution $\\sigma$, we define:\n\u003e  - *the $(\\tau, \\sigma)$-chase head $\\chaseHead_\\nu(\\tau, \\sigma)$ (through $\\nu$)* to be the set $$\\chaseHead_\\nu(\\tau, \\sigma) := \\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta).$$ of facts. \n\u003e    Intuitively, this is a set of new facts generated from $I$ by applying the rule $\\tau$ with $\\sigma$.\n\u003e  - *the $\\Sigma$-exports $\\exports_\\Sigma(I, (\\tau, \\sigma))$ from $I$ along $(\\tau, \\sigma)$* to be the set $$\\exports_\\Sigma(I, (\\tau, \\sigma)) := \\set{\\ F \\in I\\ |\\ F \\text{ is } \\Sigma \\text{-guarded by }\\chaseHead_\\nu(\\tau, \\sigma) \\ }.$$\n\u003e  - *the one-step $\\Sigma$-chase $\\chase_{\\Sigma, \\nu}(I, (\\tau, \\sigma))$ of $I$ with $(\\tau, \\sigma)$ (through $\\nu$)* to be an instance defined by  $$\\chase_{\\Sigma, \\nu}(I, (\\tau, \\sigma)) := \\chaseHead_\\nu(\\tau, \\sigma) \\cup \\exports_\\Sigma(I, (\\tau, \\sigma)).$$\n\n### Chase-Like Trees\n\n\u003e **Definition**. A *chase-like tree $T$* is a directed rooted tree $(T_0, v_r)$ together with the *instance assignment* $\\operatorname{Instance}_T: V(T_0) \\rightarrow \\Instances$ of instances to vertices.\n\n\u003e **Definition**. For a chase-like tree $T$ with the instance assignment $\\operatorname{Instance}_T$, we define the instance $\\TreeFacts(T)$ as the union $\\bigcup \\mathrm{im} \\operatorname{Instance}_T$ of images of the instance assignment.\n\n### The Canonical Global Null-Picking Function\n\n\u003e **Definition**. We write $\\ChaseStepDir$ for the set $\\GTGDFormulae \\times \\FactualSubstitutions$, and call a pair $(\\tau, \\sigma) \\in \\ChaseStepDir$ a *generic chase-step direction*. We call a finite (resp. infinite) sequence of generic chase-step directions a *finite (resp. infinite) generic chase-path*.\n\n\u003e**Definition**. We fix a coding function (hence a computable injection into $\\mathbb{N}$) $$\\#: \\ChaseStepDir^{\u003c \\omega} \\times \\mathbb{N} \\rightarrow \\mathbb{N}$$ on pairs of a finite generic chase-path and a natural.\n\nBy precomposing $\\#$ to the canonical null-picking function $\\nu_{\\mathrm{id}}(i \\in \\mathbb{N}) = n_i$ and currying, we obtain a $\\ChaseStepDir^{\u003c \\omega}$-indexed family $\\set{ \\widehat{\\#_\\vec{d}}}_{\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}}$ of null-picking functions. More explicitly, we have the following:\n\n\u003e**Definition**. For each $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, we define *the canonical null-picking function $\\widehat{\\#_{\\vec{d}}}$ at $\\vec{d}$* to be the function $$\n\\begin{align}\n\\widehat{\\#_{\\vec{d}}} : \\mathbb{N} \u0026 \\rightarrow \\Nulls\\\\\n                                   i \u0026 \\mapsto n_{\\#(\\vec{d}, i)}\n\\end{align}\n$$\n\nThis family of null-picking functions will be used in the following definition to formally ensure that no null introduced in one branch is brought to its sibling branches.\n\n## Saturated Chase-Like Trees\n\nThroughout this section, we shall fix some finite set $\\Sigma$ of head-normal GTGDs.\n\nFrom now on, we would like to work with specialized chase-step directions:\n\n\u003e **Definition**. We write $\\ChaseStepDir_\\Sigma$ for the set $\\Sigma \\times \\FactualSubstitutions$, and call a pair $(\\tau, \\sigma) \\in \\Sigma \\times \\FactualSubstitutions$ a *$\\Sigma$-chase-step direction*. We call a finite (resp. infinite) sequence of $\\Sigma$-chase-step directions a *finite (resp. infinite) $\\Sigma$-chase-path*.\n\n\u003e **Definition**. We say that a $\\Sigma$-chase-step direction $(\\tau, \\sigma)$ is *generative* if $\\tau$ is a non-full rule, and that a $\\Sigma$-chase-path $\\vec{d}$ is *generative* if each $(\\tau, \\sigma) \\in \\elems(\\vec{d})$ is generative.\n\n\u003e **Definition**. Given a base instance $I$, define, by induction on finite chase-paths $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, the *shortcut $\\Sigma$-chase $\\operatorname{SC}_{\\Sigma, \\vec{d}}(I)$ of $I$ along $\\vec{d}$* by $$\n\\begin{align}\n  \\operatorname{SC}_{\\Sigma, ()}(I) \u0026= \\FullSat_\\Sigma(I) \\\\\n  \\operatorname{SC}_{\\Sigma, \\vec{d} \\concat (\\tau, \\sigma)}(I) \u0026=\n    \\begin{cases}\n      \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{SC}_{\\Sigma, \\vec{d}}(I), (\\tau, \\sigma))) \u0026 \\text{if $\\operatorname{SC}_{\\Sigma, \\vec{d}}(I)$ can be $\\tau$-chased with $\\sigma$} \\\\\n      \\emptyset \u0026 \\text{otherwise}\n    \\end{cases}\n\\end{align}\n$$\n\n\u003e **Definition**. For a base instance $I$ and a finite chase-path $\\vec{d}$, we say that $\\vec{d}$ is *a valid $\\Sigma$-chase-path on $I$* if either $\\operatorname{SC}_{\\Sigma, \\vec{d}}(I) \\neq \\emptyset$ or both $I$ and $\\vec{d}$ are empty.\n\n\u003e **Definition**. The *$\\Sigma$-saturated chase-like tree $\\SatTree_\\Sigma(I)$ of a base instance $I$* is a chase-like tree with:\n\u003e  - the set $(\\ChaseStepDir^{\u003c \\omega})_{\\Sigma\\mathrm{, valid, gen}}$ of *all* valid generative $\\Sigma$-chase-paths on $I$ as the vertex set\n\u003e  - (labelled) edges of the form $\\vec{p} \\xrightarrow{d} \\vec{p} \\concat (d)$ for each pair of vertices (hence valid , generative $\\Sigma$-chase-paths) $\\vec{p}$ and $\\vec{p} \\concat (d)$\n\u003e  - the instance assignment function defined by $$\n\\begin{array}{c c}\n\\operatorname{Instance}_{\\SatTree_\\Sigma(I)}:\n  \u0026(\\ChaseStepDir^{\u003c \\omega})_{\\Sigma\\mathrm{, valid, gen}} \u0026 \\longrightarrow \u0026\\Instances \\\\\n  \u0026\\vec{d} \u0026\\longmapsto \u0026\\operatorname{SC}_{\\Sigma, \\vec{d}}(I)\n\\end{array}\n$$\n\n\u003e **Proposition (SatTree monotonicity)**. If $\\Sigma$ is a finite set of GTGDs and $I \\subseteq I'$ are base instances, then for each node $\\vec{d}$ in $\\SatTree_\\Sigma(I)$,\n\u003e   1. $\\vec{d}$ is also a node in $\\SatTree_\\Sigma(I')$, and moreover,\n\u003e   2. $\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d}) \\subseteq \\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d})$.\n\u003e\n\u003e \u003e *Proof*. We show both of (1) and (2) simultaneously by induction on $\\vec{d}$.\n\u003e \u003e \n\u003e \u003e (Base case):\n\u003e \u003e   1. Obvious.\n\u003e \u003e   2. By saturation monotonicity.\n\u003e \u003e (Inductive part):\n\u003e \u003e  Let $\\vec{d} \\concat (\\tau, \\sigma)$ be a node in $\\SatTree_\\Sigma(I)$, hence a valid generative $\\Sigma$-chase-path on $I$. Then $\\vec{d}$ is a node in $\\SatTree_\\Sigma(I)$, so by inductive hypothesis, $\\vec{d}$ is a valid generative $\\Sigma$-chase-path on $I'$, and $\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d}) \\subseteq \\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d}))$. Then we have:\n\u003e \u003e    1. Since $\\vec{d} \\concat (\\tau, \\sigma)$ is a valid $\\Sigma$-chase-path on $I$, by definition of $\\Instance_{\\SatTree_\\Sigma(I)}$, $\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$ can be $\\tau$-chased with $\\sigma$. So $\\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d}) \\supseteq \\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$ can also be $\\tau$-chased with $\\sigma$, and $\\vec{d} \\concat (\\tau, \\sigma)$ is a valid $\\Sigma$-chase-path on $I'$ as well. Moreover,\n\u003e \u003e    2. as $\\chase$ is clearly monotonic in its first argument, we have $$\n\\begin{align}\n\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d} \\concat (\\tau, \\sigma))\n \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d}), (\\tau, \\sigma))) \\\\\n \u0026\\subseteq \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d}), (\\tau, \\sigma))) \\\\\n \u0026= \\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d} \\concat (\\tau, \\sigma)).\n\\end{align}\n$$\n\nWe will often deal with witnesses of the form $(\\sigma, \\TreeFacts(\\SatTree_\\Sigma(I)))$. This motivates a distinguished name for such witnesses:\n\n\u003e **Definition**. For a BCQ $Q$, we say that a factual substitution $\\sigma$ is *a $(\\Sigma, I)$-witness for $Q$* when $(\\sigma, \\TreeFacts(\\SatTree_\\Sigma(I)))$ is a witness for $Q$.\n\n","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/notes/definitions/General-Notations":{"title":"General Notations","content":"\n\u003e This section defines general notations used throughout the notes.\n\nFor a formal finite sequence $(X_1, \\ldots, X_n)$ of same sorts, we abbriviate it as $\\vec{X}$. The set $\\set{\\ X_1, \\ldots, X_n\\ }$ will then be denoted as $\\elems(\\vec{X})$. We write $\\vec{X'} \\triangleleft \\vec{X}$ to mean that $\\vec{X'}$ is an initial segment of $\\vec{X}$, $\\vec{X'} \\leq \\vec{X}$ to mean that $\\vec{X'}$ is a subsequence of $\\vec{X}$ and $X' \\subseteq X$ to mean $\\elems(\\vec{X'}) \\subseteq \\elems(\\vec{X})$.\n\nFor two formal finite sequences $\\vec{X}$ and $\\vec{Y}$, we denote by $\\vec{X} \\concat \\vec{Y}$ the concatenation of $\\vec{X}$ and $\\vec{Y}$. For a nonempty (possibly infinite) sequence $(x) \\concat \\vec{X}$, we write $\\head((x) \\concat \\vec{X})$ to mean the first element $x$ of the sequence.\n\nA pair $(T, v_r)$ of a directed acyclic graph $T$ and a vertex $v_r \\in V(T)$ is called a *directed tree rooted at $v_r$* if the underlying undirected graph of $T$ is a tree and every $v \\in V(T) \\setminus \\set{v_r}$ has precisely one vertex $p_v \\in V(T)$ such that there is an edge $(p_v, v) \\in E(T)$. We shall often call $T$ a *rooted tree*.\n\nFor a directed tree $T$, we say that a node $u$ is a _descendant_ of $v$, written $u \u003c v$, when there is a (directed) path from $v$ to $u$.\n\nFor a hypergraph $\\mathcal{H} = (V, \\mathcal{E})$, we write $\\ConnComp(\\mathcal{H})$ for the set of connected components (i.e. the quotient of $V$ under the smallest equivalence relation $\\sim$ containing $x_1 \\sim x_2$ for each $x_1, x_2$ such that there is a hyperedge $E \\in \\mathcal{E}$ that spans both $x_1$ and $x_2$).\n\nWe write $f: A \\rightharpoonup B$ to mean that $f$ is a partial function from $A$ to $B$. We denote by $\\domain(f)$ to mean the domain of $f$, and write $\\isDefinedAt{f}{x}$ to mean that $x \\in \\domain(f) \\subseteq A$, i.e. $f$ is defined at $x \\in A$.","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/notes/definitions/Logic-Preliminaries":{"title":"Logic Preliminaries","content":"\n\u003e This note builds on [[General Notations]].\n\nThis note mainly pulls definitions from [Rewriting the Infinite Chase](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf), but with quite a lot of modifications.\n\nWe assume the countably infinite collection $\\Vars = \\set{x_0, x_1, \\ldots}$ of variables, the ordered set $\\Nulls = \\set{\\ n_i \\mid i \\in \\mathbb{N}\\ }$ of *labelled nulls*, some given fixed (at most countable) set $\\Consts = \\set{c_0, c_1, \\ldots}$ of constants. We also assume an infinite collection $\\Predicates = \\set{P_0, P_1, \\ldots}$ of predicate symbols, such that there is an associated *arity-function* $\\Arity: \\Predicates \\rightarrow \\mathbb{N}$ such that the preimage $\\Arity^{-1}[\\set{n}]$ of $n \\in \\mathbb{N}$ is always infinite.\n\nWe say that a tuple $\\mathcal{L} = (\\Vars_\\mathcal{L}, \\Nulls_\\mathcal{L}, \\Consts_\\mathcal{L}, \\Predicates_\\mathcal{L})$ where $\\Vars_\\mathcal{L} \\subseteq \\Vars$ and so on, is a *first-order language*. For a first order language $\\mathcal{L} = (\\Vars_\\mathcal{L}, \\Nulls_\\mathcal{L}, \\Consts_\\mathcal{L}, \\Predicates_\\mathcal{L})$, we define:\n - *the set $\\Terms_\\mathcal{L}$ of (non-null) terms* as $\\Vars_\\mathcal{L} \\cup \\Consts_\\mathcal{L}$\n - *the set $\\NullableTerms_\\mathcal{L}$ of nullable terms* as $\\Vars_\\mathcal{L} \\cup \\Consts_\\mathcal{L} \\cup \\Nulls_\\mathcal{L}$\n - _the set $\\FactualTerms_\\mathcal{L}$ of factual terms_ as $\\Nulls_\\mathcal{L} \\cup \\Consts_\\mathcal{L}$\n - _the set $\\Atoms_\\mathcal{L}$ of atomic formulae (resp. the set $\\Facts_\\mathcal{L}$ of facts)_ to be a set of formal expression $P(t_1, t_2, \\ldots, t_{\\Arity(P)})$ with $P \\in \\Predicates_\\mathcal{L}$, $t_i \\in \\Terms_\\mathcal{L}$ (resp. $\\FactualTerms_\\mathcal{L}$) for each $1 \\leq i \\leq \\Arity(P)$\n - *the set $\\Formulae_\\mathcal{L}$ of (first-order) formulas under the signature $(\\Predicates_\\mathcal{L}, \\Consts_\\mathcal{L})$* to be a set of formal expressions inductively built up from $\\Atoms_\\mathcal{L}$ using unary connective $\\neg$, binary connectives $\\wedge, \\vee, \\rightarrow$ and quantifiers $\\exists x.$ and $\\forall x.$ (where $x \\in \\Vars_\\mathcal{L}$)\n\nFor most of the following definitions, we will assume some fixed first-order language $\\mathcal{L}$ and omit the subscript $_\\mathcal{L}$ unless it becomes necessary to specify the language. \n\n\u003e **Notational remark**. By an abuse of notation, we may omit the subscript $_\\mathcal{L}$ to denote the \"unconstraint version\" of the inductive construction. For example, by $\\Atoms$ we may simply mean the set of formal expressions of the form $P(t_1, \\ldots, t_{\\Arity(P)})$ where $P \\in \\Predicates$ and $t_i \\in \\Terms = \\Vars \\cup \\Consts$ for each $1 \\leq i \\leq \\Arity(P)$.\n\nSemantics (interpretation, logical-consequence relation and truth) of formulae is defined using the standard terminology. We also follow standard conventions concerning variables being *bound* and *free*.\n\n\u003e *Remark*. We are allowing $0$-ary predicate symbols. Therefore, *an interpretation* must assign a truth value from the set $\\set{\\perp, \\top}$ to each of the given $0$-ary predicates.\n\nFor brevity, we adopt the following notational conventions:\n  - for a an atomic formula $P(t_1, \\ldots, t_{\\Arity(P)})$, we simply write it as $P(\\vec{t})$ with an intention that $\\vec{t} = (t_1, \\ldots, t_{\\Arity(P)})$.\n  - for a formula of a form $\\exists x_1. \\exists x_2. \\ldots \\exists x_n. \\phi$, we simply write it as $\\exists \\vec{x}. \\phi$ with an intention that $\\vec{x} = (x_1, \\ldots, x_n)$.\n\nFor conjunctions $F = \\bigwedge_{1 \\leq i \\leq n} F_i$ and $G = \\bigwedge_{1 \\leq j \\leq m} G_j$ of formulae, we write $F \\subseteq G$ when for each $1 \\leq i \\leq n$, $F_i$ appears in $G$. That is, for each $1 \\leq i \\leq n$, there exists $1 \\leq j \\leq m$ with $F_i = G_j$.\n\nWe now define subclasses of objects defined above:\n  - a fact $P(\\vec{t})$ is *a base fact* if $\\vec{t}$ contains only constants (hence no nulls). We write $\\BaseFacts$ for the set of base facts.\n  - *an instance* is a finite set of facts. We write $\\Instances$ for the set $\\mathcal{P}_{\u003c \\omega}(\\Facts)$.\n  - an instance $I$ is *a base instance* if each fact in $I$ is a base fact.\n  - a formula is *a rectified formula* if no variable is bound twice, and no variable occurs both bound and free. By a standard renaming argument, any first-order formula is equivalent to a rectified formula. Hence from now on we will assume all formulae to be rectified.\n  - a formula is closed when every occurence of variable is bound.\n  - a closed formula is a *Tuple-Generating Dependency (or TGD)* if it is of the form $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ where $\\beta$ and $\\eta$ are conjunctions of atoms with $\\eta$ nonempty. In such a formula, $\\beta$ is referred to as the *body* and $\\eta$ is referred to as the *head* of this TGD.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is *a full TGD* if $\\vec{y}$ is empty, i.e. it is of the form $\\forall \\vec{x}. \\beta \\rightarrow \\eta$.\n  - a full TGD is *a Datalog rule* if its head contains exactly one atom. A finite set of Datalog rules is is called *a Datalog program*.\n  - a TGD is in a head-normal form if it is either a *Datalog rule*, or each atom in the head contains at least one existentially quantified variable.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is a *guarded-TGD (or GTGD)* if $\\beta$ contains an atom $P(\\vec{t})$ such that $\\vec{t} \\supseteq \\vec{x}$. We write $\\GTGDFormulae_\\mathcal{L}$ for the set of $\\mathcal{L}$-formulae that are GTGDs.\n  - a Conjunctive Query (CQ) is a formula of the form $\\exists \\vec{x}. \\bigwedge_i A_i$ where each $A_i$ is an atomic formula.\n\nWe say that a Datalog program $\\Sigma_\\rew$ is a *Datalog rewriting* of a finite collection $\\Sigma$ of GTGDs when for every base instance $I$ and a base fact $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_\\rew \\models F.$$\n\n## Notions of Substitutions\n\n### Factual subtitutions\n\n\u003e **Definition**. A *factual substitution* is a partial function $\\sigma: \\Vars \\rightharpoonup \\FactualTerms$ with a finite domain.\n\nA factual substitution canonically extends to a partial function $\\Atoms \\rightharpoonup \\Facts$ that is defined on atoms all of whose variables are in the domain of $\\sigma$. We identity this extension of $\\sigma$ with $\\sigma$ by an abuse of notation.\n\n\u003e **Definition**. We write $\\FactualSubstitutions = (\\Vars \\rightharpoonup \\FactualTerms)_{\u003c \\omega}$ for the countable set of all factual substitutions.\n\n\u003e **Definition**. A *ground substitution* is a factual substitution whose range is contained in $\\Consts$.\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ *covers* a set $\\vec{y}$ of variables when $\\elems(\\vec{y}) \\subseteq \\domain(\\sigma)$, and say that $\\sigma$ *exactly covers $\\vec{y}$* if $\\elems(\\vec{y}) = \\domain(\\sigma)$.\n\n#### BCQ Witnesses\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ together with a (potentially infinite) set $\\mathcal{F}$ of facts *witness a boolean conjunctive query $\\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$* if $\\sigma$ exactly covers $\\vec{x}$ and $$\\set{\\ \\sigma(A_i) \\mid 1 \\leq i \\leq n \\ } \\subseteq \\mathcal{F}.$$\n\n### Consts translations\n\n\u003e **Definition**. A *consts translation* is a function $t: \\Consts \\rightarrow \\Consts$.\n\nA consts translation $t$ then canonically extends to a function $\\tilde{t}: \\Facts \\rightarrow \\Facts$ that applies $t$ to each constant appearing in a fact (without modifying nulls). Then $\\tilde{t}$ further extends to a function $\\tilde{\\tilde{t}}: \\Instance \\rightarrow \\Instance$ that applies $\\tilde{t}$ to each fact in an instance. By an abuse of notation we shall identify all of $t, \\tilde{t}$ and $\\tilde{\\tilde{t}}$.\n","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/notes/definitions/Rewritings":{"title":"Rewritings","content":"\n\u003e This note builds on [[Logic Preliminaries]].\n\n## Conjunctive Query Answering\n\nThrough the language of substitutions, we define what it means to *answer* a conjunctive query.\n\n\u003e **Definition**. Given a set $\\Sigma$ of TGDs, a base instance $I$ and a rectified conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j(\\vec{y'}_j)$, an *answer to $Q$ on $I$ under $\\Sigma$* is a ground substitution $\\sigma$ covering exactly $\\mathrm{FV}(Q)$ such that $I \\wedge \\Sigma \\models \\sigma(Q)$. The set of all ansers to $Q$ on $I$ under $\\Sigma$ is denoted by $\\QueryAnswers(Q, I; \\Sigma)$.\n\n## Rule-Rewritings\n\n\u003e **Definition**. Given a set $\\Sigma$ of TGDs, a Datalog program $\\Sigma_{\\text{rew}}$ is *a rule-rewriting of $\\Sigma$* if, for every base instance $I$, $\\Sigma$ and $\\Sigma_{\\text{rew}}$ generate the same set of **base facts**, i.e. for every base fact $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_{\\text{rew}} \\models F.$$\n\n\u003e **Fact**. If $\\Sigma$ is a finite set of GTGDs, then there exists a rule-rewriting of $\\Sigma$, and moreover it can be computed.\n\u003e \n\u003e \u003e *Proof*: See [[Papers#^a74196]], where three different competitive algorithms for computing rule-rewriting of GTGDs are presented.\n\n## Query-Rule-Rewritings\n\n\u003e **Definition**. Let $\\Sigma$ be a set of TGDs and $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j(\\vec{y'}_j)$ a conjunctive query. Let $\\vec{z}$ be the sequence of free variables in $Q$. \n\u003e \n\u003e We say that a pair of a Datalog program $\\Sigma^Q_\\rew$ (with a suitably extended set of predicates) together with a (possibly fresh) *$|\\vec{z}|$-ary goal predicate* $\\mathrm{Goal^Q}(\\underbrace{-, \\ldots, -}_{|\\vec{z}|\\text{ arguments}})$ is a *query-rule-rewriting of $(\\Sigma, Q)$* if, for every base instance $I$, $$\\QueryAnswers(Q, I; \\Sigma) = \\QueryAnswers(\\mathrm{Goal}^Q(\\vec{z}), I; \\Sigma^Q_\\mathrm{rew}).$$ holds.\n\u003e \n\u003e \u003e *Remark*. This is equivalent to saying that, for all base instance $I$ and every ground substitution $\\sigma$ that exactly covers $\\elems(\\vec{z})$, $$I \\wedge \\Sigma \\models \\sigma(Q) \\Longleftrightarrow I \\wedge \\Sigma^Q_\\rew \\models \\sigma(\\mathrm{Goal^Q}(\\vec{z})) $$ holds.\n","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/notes/definitions/Saturations":{"title":"Saturations","content":"\n\u003e This note builds on [[Rewritings]]\n\nGiven an instance $I$ and a finite set $\\Sigma$ of Datalog rules, we can form *the smallest superinstance of $I$ satisfying $\\Sigma$*, which we shall call $\\Sat_\\Sigma(I)$. To make this precise, we begin with the following definition.\n\n## Datalog Saturations\n\n\u003e **Definition**. Given a Datalog program $\\Sigma$ and an instance $I$, we define the *$k$-th partial Datalog-saturation $\\Sat^k_\\Sigma(I)$ of $I$ by $\\Sigma$* by induction on $k \\in \\mathbb{N}$, by $$\\begin{align}\n  \\Sat^0_\\Sigma(I) \u0026= I \\\\\n  \\Sat^{k + 1}_\\Sigma(I) \u0026= \\Sat^k_\\Sigma(I) \\cup \\set{\\ \\sigma(\\eta) \\mid (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma, \\sigma \\text{ covers } \\vec{x}, \\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)\\ }\n\\end{align}$$\n\nHere are some basic properties of $\\Sat^k_\\Sigma(-)$.\n\n\u003e **Proposition**. If $I \\subseteq I'$ are instances and $\\Sigma$ is a finite set of GTGDs, then for each $k \\in \\mathbb{N}$, $\\Sat^k_\\Sigma(I) \\subseteq \\Sat^k_\\Sigma(I')$.\n\u003e \n\u003e \u003e *Proof*. By a simple induction on $k$.\n\n\u003e **Proposition**. Let $\\Sigma$ be a Datalog program and $I$ an instance. Then for each $k \\in \\mathbb{N}$ and for all base fact $F$, if $F \\in \\Sat_\\Sigma^k(I)$ then $I \\wedge \\Sigma \\vdash F$  (by $\\vdash$ we simply mean \"provable in natural deduction\"). ^7faefd\n\u003e \n\u003e \u003e *Proof*. By induction on $k$.\n\u003e \u003e \n\u003e \u003e The base case is obvious, since if $F \\in \\Sat^0_\\Sigma(I) = I$, $I \\vdash F$ and therefore $I \\wedge \\Sigma \\vdash F$. \n\u003e \u003e \n\u003e \u003e For the inductive part, suppose $F \\in \\Sat^{k+1}_\\Sigma(I)$. If $F \\in \\Sat^k_\\Sigma(I)$ then we are done by the inductive hypothesis. Otherwise, there must be some $(\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma$ and a factual substitution $\\sigma$ covering $\\vec{x}$ such that $\\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)$, and $F = \\sigma(\\eta)$. By inductive hypothesis, each atom $F \\in \\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)$ can be derived from $I \\wedge \\Sigma$, hence $I \\wedge \\Sigma \\vdash \\sigma(\\beta)$. Since $\\sigma(\\beta) \\rightarrow \\sigma(\\eta)$ can be deduced from $\\Sigma$ in one step, by modus ponens $I \\wedge \\Sigma \\vdash \\sigma(\\eta)$.\n\nNow, we define the desired instance.\n\n\u003e **Definition**. The *Datalog saturation $\\Sat_\\Sigma(I)$ of $I$ by a Datalog program $\\Sigma$* is defined as the instance $$\\Sat_\\Sigma(I) = \\bigcup_{k \\in \\mathbb{N}} \\Sat^k_\\Sigma(I).$$\n\n\u003e **Proposition (Saturation monotonicity)**. If $I \\subseteq I'$ are instances and $\\Sigma$ is a finite set of GTGDs, then $\\Sat_\\Sigma(I) \\subseteq \\Sat_\\Sigma(I')$.\n\u003e \n\u003e \u003e *Proof*. By monotonicity of $\\Sat^k_\\Sigma(-)$ for each $k \\in \\mathbb{N}$.\n\nOur requirement that the $\\Sat_\\Sigma(I)$ is \"*the smallest superinstance of $I$ satisfying $\\Sigma$*\" is captured in the following theorem.\n\n\u003e **Theorem (Base-fact completeness of Datalog saturations)**.\n\u003e Let $I$ be a base instance, $F$ a base fact and $\\Sigma$ be a Datalog program. Then $$F \\in \\Sat_\\Sigma(I) \\Longleftrightarrow I \\wedge \\Sigma \\models F.$$\n\u003e ^b7f0b5\n\u003e \u003e *Proof*.\n\u003e \u003e ($\\Longrightarrow$): By [[#^7faefd]] and soundness of natural deduction, $$\n\\begin{align}\nF \\in \\Sat_\\Sigma(I)\n  \u0026\\Longrightarrow F \\in \\Sat_\\Sigma^k(I) \\text{ for some } k \\in \\mathbb{N} \\\\\n  \u0026\\Longrightarrow I \\wedge \\Sigma \\vdash F \\\\\n  \u0026\\Longrightarrow I \\wedge \\Sigma \\models F \\\\\n\\end{align}$$\n\u003e \u003e ($\\Longleftarrow$):\n\u003e \u003e Let $\\mathcal{M}$ be a model that makes precisely the facts in $\\Sat_\\Sigma(I)$ true. We then have $\\mathcal{M} \\models I$, since $\\Sat_\\Sigma(I) \\supseteq \\Sat^0_\\Sigma(I) = I$.\n\u003e \u003e \n\u003e \u003e \u003e **Claim**. $\\mathcal{M} \\models \\Sigma$.\n\u003e \u003e \u003e *Proof of the claim*. Take any $\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma$. We show that $\\mathcal{M} \\models \\tau$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e So take any factual substitution $\\sigma$ such that $\\mathcal{M} \\models \\sigma(\\beta)$. By construction of $\\mathcal{M}$, $\\sigma(\\beta) \\subseteq \\Sat_\\Sigma(I)$. Since $\\sigma(\\beta)$ is finite, $\\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)$ for some $k \\in \\mathbb{N}$. But then by definition of $\\Sat^{k+1}_\\Sigma(I)$, $\\sigma(\\eta) \\in \\Sat^{k+1}_\\Sigma(I) \\subseteq \\Sat_\\Sigma(I)$, so $\\mathcal{M} \\models \\sigma(\\eta)$.\n\u003e \u003e\n\u003e \u003e Therefore $\\mathcal{M} \\models I \\wedge \\Sigma$ and by assumption $\\mathcal{M} \\models F$. But then by construction of $\\mathcal{M}$, $F \\in \\Sat_\\Sigma(I)$.\n\n## Full Saturations\n\nThe previous section talked about saturating an instance using a finite set of *Datalog* rules.\n\nWe can try to do the similar thing with a finite set of *guarded TGDs*, but at the same time we want to collect facts that does not mention newly introduced nulls. This motivates the following definition.\n\n\u003e **Definition**. Let $\\Sigma$ be a finite collection of TGDs and $I$ an instance.\n\u003e \n\u003e If $\\Sigma$ has some rule-rewriting $\\Sigma_\\mathrm{rew}$, then we define *the full saturation $\\FullSat_\\Sigma(I)$ of $I$ by $\\Sigma$* as $$\\FullSat_\\Sigma(I) = \\Sat_{\\Sigma_\\rew}(I).$$ \n\u003e \u003e *Remark*. This definition is well-defined, i.e. does not depend on the choice of $\\Sigma_\\mathrm{rew}$, since any two Datalog rewritings produce the same Datalog saturation by the theorem [[#^b7f0b5]]. \n\nThe following proposition is a simple consequence of [[#^b7f0b5]] and the definition of $\\FullSat_\\Sigma(-)$:\n\n\u003e **Proposition**. Suppose that $\\Sigma$ is a set of TGDs that admit a rule-rewriting. Then for a base instance $I$ and a *base fact* $F$, $$F \\in \\FullSat_\\Sigma(I) \\Longleftrightarrow I \\wedge \\Sigma \\models F.$$\n\u003e \u003e *Proof*. $$\n\\begin{align}\n  F \\in \\FullSat_\\Sigma(I)\n    \u0026\\Longleftrightarrow F \\in \\Sat_{\\Sigma_\\mathrm{rew}}(I) \\\\\n    \u0026\\Longleftrightarrow I \\wedge \\Sigma_\\mathrm{rew} \\models F \\\\\n    \u0026\\Longleftrightarrow I \\wedge \\Sigma \\models F.\n\\end{align}\n$$\n","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/references/Books":{"title":"Books","content":"\n## `Introduction to Graph and Hypergraph Theory`\n\n^327283\n\n[SOLO permalink](https://solo.bodleian.ox.ac.uk/permalink/f/89vilt/oxfaleph000591771), EBook ISBN: `9781614701125`\n\nI used a few terminologies from this book to describe/define notions about hypergraphs.","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/references/Papers":{"title":"Papers","content":"\n## `Rewriting the Infinite Chase`\n\n^a74196\n\nLink: [latest version on GitHub pages](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf)\n\nTODO: write down the ideas that are explored in this paper\n\n## `A general Datalog-based framework for tractable query answering over ontologies`\n\nLink: [ScienceDirect](https://www.sciencedirect.com/science/article/pii/S1570826812000388)\n\nTODO: write down the ideas that are explored in this paper\n","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/thoughts/2022-11-01-About-template-constraints":{"title":"2022-11-01 About template constraints","content":"\n## Constraints on Partitioning Imposed by the Query\n\nSuppose that the following query is given as $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$.\n\nThere are a few ways this query could be witnessed by nulls in an infinite branch of the tree-like chase (a.k.a. \"tentacles\") or by constants in the collection of input or saturated facts (a.k.a. \"squid head\"). The following is an exhaustive list of all possible combinations:\n - 0 variable in the squid head\n\t - all of $x, y, z$ get witnessed in the same tentacle\n - 1 variable in the squid head\n\t - $x$ gets witnessed in the head and $y, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in different tentacles\n\t - $z$ gets witnessed in the head and $x, y$ get witnessed in the same tentacle\n - 2 variables in the squid head\n\t - $x$ and $y$ get witnessed in the head and $z$ gets witnessed in a tentacle\n\t - $x$ and $z$ get witnessed in the head and $y$ gets witnessed in a tentacle\n\t - $y$ and $z$ get witnessed in the head and $x$ gets witnessed in a tentacle\n - 3 variables in the squid head\n\t - All of $x, y, z$ get witnessed in the squid head\n\nThere are two impossible combinations, namely:\n\n - `x` gets witnessed in the head and $y$ and $z$ get witnessed in _different_ tentacles\n - `z` gets witnessed in the head and $y$ and $x$ get witnessed in _different_ tentacles\n\nTo see why, suppose $y$ and $z$ are instantiated as nulls $n_1$ and $n_2$ in _different tentacles_. Then there is nowhere in the infinite tree-like chase structure that proves $R(n_1, n_2)$, which uses $n_1$ and $n_2$ at the same time. So we conclude that: _if_ $y$ and $z$ are to be instantiated with nulls, _then_ that must be happen on the same tentacle.\n\nGeneralising the example above, we can see that: if the query contains an atom $P(\\vec{u})$ within the existential, then every vector witnessing $\\vec{u}$ in $P(\\vec{u})$ always have all the nulls appear in the single tentacle.\n\nSo we can deduce to a certain extent how the instantiation of variables may be distributed to different tentacles by just looking at the query.\n\n## Constraints Imposed by the Reasoning Rules\n\nIn this section, we shall write $\\Sigma$ for the generic set of rules.\n\nWhen a pseudoquery is proven in a tentacle of the infinite chase, one might imagine the following situation:\n\n![[Pasted image 20221101171150.png]]\n\nHowever, this diagram needs a slight modification: we will always get a set different from $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$ in the $i$-th step of this short-cut proof. This is because we cannot salvage atoms that are not facts (i.e. ones containing nulls) from branches steming from $I_i$. So on top of $I_i$, we are only going to add ***base facts*** that are derived from $I_i$ using $\\Sigma$ (my guess is that this is in general not even a subset of $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$; is this true?). So we wrill write fact-saturated sets of $I_i$ with $\\Sigma$ as $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_i)$.\n\nAlso, by splitting the pseudoquery we can assume that a pseudoquery is realized in $I_n$ as oppsed to $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_n)$, since if we are assuming all variables in an atom $F(\\vec{t})$ to be realized in the squid head, we may treat $F(\\vec{t})$ as a separate query (TODO: this is really hand-wavy!).\n\nIn fact we will have something like the following:\n\n![[Pasted image 20221101171906.png]]\n\n","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null},"/thoughts/2022-11-09-Head-Tentacle-Partitions-and-Pseudo-Witnesses":{"title":"2022-11-09 Head-Tentacle Partitions and Pseudo-Witnesses","content":"\nWe explorered before in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]] a few possibility on how the entire query can be witnessed by nulls in different tentacles.\n\nLet us be more precise and formal.\n\n**Definition**. For a vector $\\vec{x}$ of distinct variables, we say that a pair $(H, \\mathcal{T})$ is a _head-tentacle partition of $\\vec{x}$_ when\n - $H \\subseteq \\elems(\\vec{x})$ and $\\mathcal{T} \\subseteq \\mathcal{P}(\\elems(\\vec{x}))$\n - $H \\not\\in \\mathcal{T}$\n - Either\n\t - $H = \\emptyset$ and $\\mathcal{T}$ is a partition (i.e. a cover of disjoint nonempty sets) of $\\elems(\\vec{x})$\n\t - $\\set{H} \\cup \\mathcal{T}$ is a partition of $\\elems(\\vec{x})$\n\n**Definition**. For a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$, define the corresponding _compatible cover_ $(H, \\mathcal{T})_\\text{cover}$ as the set $\\set{ H \\cup T \\mid T \\in \\mathcal{T} }$.\n\n**Definition**. Given a boolean conjunctive query $$Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i(\\vec{v_i})$$ we say that a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$ is _compatible with $Q$_ if, for every $1 \\leq i \\leq n$ and every $x_1, x_2 \\in \\elems(\\vec{v_i})$, there exists $C \\in (H, \\mathcal{T})_\\text{cover}$ such that $\\set{x_1, x_2} \\subseteq C$.\n\n**Definition**. For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$, the _witness pattern $\\mathrm{Pat}_\\sigma$ of $\\sigma$_ is the head-tentacle paritition $(H, \\mathcal{T})$ defined by $$\\begin{align}\nH \u0026= \\set{ x \\in \\elems(\\vec{x}) \\mid \\sigma(x) \\text{ is a constant}} \\\\\nT \u0026= (\\elems(\\vec{x}) \\setminus H) / \\sim\n\\end{align}$$ where $\\sim$ is the equivalence relation given by $x_1 \\sim x_2$ iff $\\sigma(x_1)$ and $\\sigma(x_2)$ appear in the same tentacle (TODO: define this precisely; it should be easy thanks to the explicit construction of $\\SatTree_\\Sigma(I)$).\n\n**Claim**:  For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$ (TODO: define notions so that this statement can be shortened), $\\mathrm{Pat}_\\sigma$ is compatible with $Q$.\n\n---\nNow that we defined notions, we can say the same thing as in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]], but more concisely:\n\nFor a query $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$, the following are the only head-tentacle partitions compatible with $Q$:\n - $(\\emptyset, \\set{\\set{x, y, z}})$\n - $(\\set{x}, \\set{\\set{y, z}})$\n - $(\\set{y}, \\set{\\set{x, z}})$\n - $(\\set{y}, \\set{\\set{x}, \\set{z}})$\n - $(\\set{z}, \\set{x, y})$\n - $(\\set{x, y}, \\set{\\set{z}})$\n - $(\\set{x, z}, \\set{\\set{y}})$\n - $(\\set{y, z}, \\set{\\set{x}})$\n - $(\\set{x, y, z}, \\emptyset)$\n\nLet us tinker with this example.\n\n**Question.** Given a finite set $\\Sigma$ of GTGDs, is $$\n\\left(\n\\Sigma \\cup \\left\\lbrace\n  \\begin{aligned}\n  \u0026 \\forall u, v. R(u, v) \\rightarrow \\mathrm{Subgoal}_\\mathrm{left}(v), \\\\\n  \u0026 \\forall v, w. R(v, w) \\rightarrow \\mathrm{Subgoal}_\\mathrm{right}(v), \\\\\n  \u0026 \\forall v. \\mathrm{Subgoal}_\\mathrm{left}(v) \\wedge \\mathrm{Subgoal}_\\mathrm{right}(v) \\rightarrow \\mathrm{Goal}^Q() \\\\\n\\end{aligned}\n\\right\\rbrace\n\\right)_\\mathrm{rew}\n$$ a query-rule-rewriting of $(\\Sigma, Q)$?\n\n**Answer**: For each possible head-tentacle partition, we can \"enrich\" the $\\SatTree$ by added rules and see if $\\mathrm{Goal}^Q()$ can be derived using chase steps.","lastmodified":"2023-01-13T11:39:02.389286731Z","tags":null}}