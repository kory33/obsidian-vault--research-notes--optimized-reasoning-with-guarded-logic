{"/notes/":{"title":"ü™¥ Quartz 3.","content":"\nHost your second brain and [digital garden](https://jzhao.xyz/posts/networked-thought) for free. Quartz features\n\n1. Extremely fast natural-language [[notes/search]]\n2. Customizable and hackable design based on [Hugo](https://gohugo.io/)\n3. Automatically generated backlinks, link previews, and local graph\n4. Built-in [[notes/CJK + Latex Support (ÊµãËØï) | CJK + Latex Support]] and [[notes/callouts | Admonition-style callouts]]\n5. Support for both Markdown Links and Wikilinks\n\nCheck out some of the [amazing gardens that community members](notes/showcase.md) have published with Quartz or read about [why I made Quartz](notes/philosophy.md) to begin with.\n\n## Get Started\n\u003e üìö Step 1: [Setup your own digital garden using Quartz](notes/setup.md)\n\nReturning user? Figure out how to [[notes/updating|update]] your existing Quartz garden.\n\nIf you prefer browsing the contents of this site through a list instead of a graph, you see a list of all [setup-related notes](/tags/setup).\n\n### Troubleshooting\n- üöß [Troubleshooting and FAQ](notes/troubleshooting.md)\n- üêõ [Submit an Issue](https://github.com/jackyzha0/quartz/issues)\n- üëÄ [Discord Community](https://discord.gg/cRFFHYye7t)\n\n","lastmodified":"2022-11-07T04:15:08.50208943Z","tags":null},"/notes/notes/Decomposing-the-Larger-Problem-into-Smaller-Subproblems":{"title":"","content":"\n\u003e We shall build on definitions given in [[Chase-Like Trees and Saturated Chase-Like Trees]].\n\nWe first make the following claim:\n\nClaim 1(Completeness and Soundness of saturated chase-like trees). For any finite set of GTGDs $\\Sigma$, a base instance $I$ and a conjunctive query $Q$, $$I \\wedge \\Sigma \\models Q\\Longleftrightarrow \\TreeFacts(\\SatTree_\\Sigma(I)) \\text{ witnesses } Q.$$\n","lastmodified":"2022-11-07T04:15:08.50208943Z","tags":null},"/notes/notes/definitions/Chase-Like-Trees-and-Saturated-Chase-Like-Trees":{"title":"","content":"\n\u003e This note builds on [[Rewriting, Existential Lifting and Saturation]]\n\nWe shall define a tree structure that \"stems from a base instance $I$ and witnesses every possible conclusion that can be $\\Sigma$-deduced from $I$\". To make this precise, we define a few concepts in this section. So fix a finite set $\\Sigma$ of head-normal GTGDs.\n\nWe say that _a set $G$ of factual terms is $\\Sigma$-guarded by a set of factual terms $\\vec{t}$_ when $G \\subseteq \\consts(\\Sigma) \\cup \\vec{t}$ .\n\nInjective functions of the form $\\nu: \\mathbb{N} \\rightarrow \\Nulls$ will be referred to as *null-picking functions*. For a null-picking function $\\nu$, a vector $\\vec{y} = (y_1, \\ldots, y_n)$ of variables and a factual substitution $\\sigma$ whose domain is disjoint from $\\vec{y}$, we define *the factual substitution $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls]$* with domain $\\domain(\\sigma) + \\elems(\\vec{y})$ that substitutes each $y_i$ to distinct nulls (chosen by $\\nu$) and follows $\\sigma$ elsewhere: $$\n\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](x)=\n\\begin{cases}\n    n_{\\nu(i)} \u0026 \\text{if $x = y_i$} \\\\\n    \\sigma(x) \u0026 \\text{if $x \\in \\domain(\\sigma)$}\n\\end{cases}$$\n\nFor a TGD $D = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$, an instance $I$ and a factual substitution $\\sigma$ that covers $\\vec{x}$, we say that *$I$ can be $D$-chased with $\\sigma$* when $\\sigma(\\beta) \\subseteq I$. Intuitively, this means that the premise $\\beta$ is witnessed by some facts in $I$, and $\\sigma$ specifies which constant or null appearing in $I$ is witnessing each variable in $\\vec{x}$.\n\nWe shall describe how an instance can be \"extended\" by applying a GTGD. (*Question: this is not a proper extension of $I$ because we are only taking along $\\Sigma$-guarded facts to the \"extension\". Is there any intuition why we should we do this, or is this just a technical trick that is used to bound the size of tree-like chase proofs so as to make the decision procedure decidable? Will I get an insight about the intuition behind this limitation if I read the proof of chase-proof completeness?*) Given a null-picking function $\\nu$, a GTGD $D = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ and an instance $I$ that can be $D$-chased with a factual substitution $\\sigma$, we define\n - *the chase head $\\chaseHead_\\nu(D, \\sigma)$* to be the fact $$\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta).$$ Intuitively, this is a new fact generated from $I$ by applying the rule $D$.\n - *the one-step chase $\\chase_\\nu(I; D, \\sigma)$ of $I$ with $(D, \\sigma)$ (through $\\nu$)* to be an instance defined by  $$\\set{\\chaseHead_\\nu(D, \\sigma)} \\cup \\set{\\ F \\in I\\ |\\ F \\text{ is } \\Sigma \\text{-guarded by }\\chaseHead_\\nu(D, \\sigma) \\ }.$$\n\nA *chase-like tree $T$ on an instance* is a directed rooted tree $(T_0, v_r)$ together with the *instance assignment* $\\operatorname{Instance}_T: V(T_0) \\rightarrow \\Instances$ of instances to vertices.\n\nFor a chase-like tree $T$ with the instance assignment $\\operatorname{Instance}_T$, we define the instance $\\TreeFacts(T)$ as the union $\\bigcup \\mathrm{im} \\operatorname{Instance}_T$ of image of the instance assignment.\n\n\nWe shall call a pair $(D, \\sigma) \\in \\Sigma \\times \\FactualSubstitutions$ a *chase-step direction*, and write $\\ChaseStepDir$ for the set $\\Sigma \\times \\FactualSubstitutions$ of all chase-step directions. We call a finite (resp. infinite) sequence of chase-step directions a *finite (resp. infinite) chase-path*.\n\n---\nTODO: we also need to encode \"the choice of facts that we take along $(D, \\sigma)$ when applying the chase step\", otherwise (I think) we can't quite argue about what we are trying to.\n\n---\n\nFix a coding function (hence a computable injection into $\\mathbb{N}$) $$\\#: \\ChaseStepDir^{\u003c \\omega} \\times \\mathbb{N} \\rightarrow \\mathbb{N}$$ on pairs of a finite chase-path and a natural. Precompose $\\#$ to the canonical null-picking function $\\nu_{\\mathrm{id}}(i \\in \\mathbb{N}) = n_i$ and curry to obtain a $\\ChaseStepDir^{\u003c \\omega}$-indexed family $\\set{ \\widehat{\\#_\\vec{d}}}_{\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}}$ of null-picking functions: More explicitly, for each $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, we have $$\n\\begin{align}\n\\widehat{\\#_{\\vec{d}}}\\ : \\mathbb{N} \u0026 \\rightarrow \\Nulls\\\\\n                                   i \u0026 \\mapsto n_{\\#(\\vec{d}, i)}\n\\end{align}\n$$\nThis family of null-picking functions will be used in the following definition to formally ensure that no null introduced in one branch is brought to its sibling branches.\n\nGiven a base instance $I$, define, by induction on finite chase-paths $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, the *canonical completion $\\operatorname{CC}_\\vec{d}(I)$ of $I$ along $\\vec{d}$* by $$\n\\begin{align}\n  \\operatorname{CC}_{()}(I) \u0026= \\FullSat_\\Sigma(I) \\\\\n  \\operatorname{CC}_{\\vec{d} \\concat (D, \\sigma)}(I) \u0026=\n    \\begin{cases}\n      \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{CC}_\\vec{d}(I); D, \\sigma)) \u0026 \\text{if $\\operatorname{CC}_\\vec{d}(I)$ can be $D$-chased with $\\sigma$} \\\\\n      \\emptyset \u0026 \\text{otherwise}\n    \\end{cases}\n\\end{align}\n$$\nFor a base instance $I$ and a finite chase-path $\\vec{d}$, we say that $\\vec{d}$ is *a valid chase-path on $I$* if either $\\operatorname{CC}_\\vec{d}(I) \\neq \\emptyset$ or both $I$ and $\\vec{d}$ are empty.\n\nNow define the *$\\Sigma$-saturated chase-like tree $\\SatTree_\\Sigma(I)$ of a base instance $I$* with:\n - the set $(\\ChaseStepDir^{\u003c \\omega})_{\\mathrm{valid}}$ of *all* valid chase-paths on $I$ as the vertex set\n - (labelled) edges of the form $\\vec{p} \\xrightarrow{d} \\vec{p} \\concat (d)$ for each pair of vertices (hence valid chase-paths) $\\vec{p}$ and $\\vec{p} \\concat (d)$\n - the instance assignment function defined by $$\n\\begin{array}{c c}\n\\operatorname{Instance}_{\\SatTree_\\Sigma(I)}:\n  \u0026(\\ChaseStepDir^{\u003c \\omega})_{\\mathrm{valid}} \u0026 \\longrightarrow \u0026\\Instances \\\\\n  \u0026\\vec{d} \u0026\\longmapsto \u0026\\operatorname{CC}_\\vec{d}(I)\n\\end{array}\n$$\n","lastmodified":"2022-11-07T04:15:08.50208943Z","tags":null},"/notes/notes/definitions/General-Notations":{"title":"","content":"\n\u003e This section defines general notations used throughout the notes.\n\nFor a formal finite sequence $(X_1, \\ldots, X_n)$ of same sorts, we abbriviate it as $\\vec{X}$. The set $\\set{\\ X_1, \\ldots, X_n\\ }$ will then be denoted as $\\elems(\\vec{X})$. We write $\\vec{X'} \\triangleleft \\vec{X}$ to mean that $\\vec{X'}$ is an initial segment of $\\vec{X}$, $\\vec{X'} \\leq \\vec{X}$ to mean that $\\vec{X'}$ is a subsequence of $\\vec{X}$ and $X' \\subseteq X$ to mean $\\elems(\\vec{X'}) \\subseteq \\elems(\\vec{X})$.\n\nFor two formal finite sequences $\\vec{X}$ and $\\vec{Y}$, we denote by $\\vec{X} \\concat \\vec{Y}$ the concatenation of $\\vec{X}$ and $\\vec{Y}$.\n\nA pair $(T, v_r)$ of a directed acyclic graph $T$ and a vertex $v_r \\in V(T)$ is called a *directed tree rooted at $v_r$* if the underlying undirected graph of $T$ is a tree and every $v \\in V(T) \\setminus \\set{v_r}$ has precisely one vertex $p_v \\in V(T)$ such that there is an edge $(p_v, v) \\in E(T)$. We shall often call $T$ a *rooted tree*.\n\nWe write $f: A \\rightharpoonup B$ to mean that $f$ is a partial function from $A$ to $B$. We denote by $\\domain(f)$ to mean the domain of $f$, and write $\\isDefinedAt{f}{x}$ to mean that $x \\in dom(f) \\subseteq A$, i.e. $f$ is defined at $x \\in A$.","lastmodified":"2022-11-07T04:15:08.50208943Z","tags":null},"/notes/notes/definitions/Logic-Preliminaries":{"title":"","content":"\n\u003e This note builds on [[General Notations]].\n\nThis note mainly pulls definitions from [Rewriting the Infinite Chase](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf), but with quite a lot of modifications.\n\nWe assume the countably infinite collection $\\Vars = \\set{x_1, x_2, x_3, \\ldots}$ of variables, the ordered set $\\Nulls = \\set{\\ n_i \\mid i \\in \\mathbb{N}\\ }$ of *labelled nulls* and some given fixed (at most countable) set $\\Consts = \\set{c_1, c_2, \\ldots}$ of constants.\n\nGiven a finite collection $\\Predicates = \\set{P_1, P_2, \\ldots, P_N}$ of predicates with finite arities $\\Arity(P_i)$ associated to each of them (both of which we will not explicitly write from now on), we define:\n - *the set $\\Terms$ of (non-null) terms* as $\\Vars \\cup \\Consts$\n - *the set $\\NullableTerms$ of nullable terms* as $\\Vars \\cup \\Consts \\cup \\Nulls$\n - _the set $\\FactualTerms$ of factual terms_ as $\\Nulls \\cup \\Consts$\n - _the set $\\Atoms$ of atomic formulae (resp. the set $\\Facts$ of facts)_ to be a set of formal expression $P(t_1, t_2, \\ldots, t_{\\Arity(P)})$ with $P \\in \\Predicates$, $t_i \\in \\Terms$ (resp. $\\FactualTerms$) for each $1 \\leq i \\leq \\Arity(P)$\n - *the set $\\Formulae$ of (first-order) formulas under the sigunature $(\\Predicates, \\Consts)$* to be a set of formal expressions inductively built up from $\\Atoms$ using unary connective $\\neg$, binary connectives $\\wedge, \\vee, \\rightarrow$ and quantifiers $\\exists x.$ and $\\forall x.$ (where $x \\in \\Vars$)\n\nSemantics (interpretation, logical-consequence relation and truth) of formulae is defined using the standard terminology. We also follow standard conventions concerning variables being *bound* and *free*.\n\nFor brevity, we adopt the following notational conventions:\n  - for a an atomic formula $P(t_1, \\ldots, t_{\\Arity(P)})$, we simply write it as $P(\\vec{t})$ with an intention that $\\vec{t} = (t_1, \\ldots, t_{\\Arity(P)})$.\n  - for a formula of a form $\\exists x_1. \\exists x_2. \\ldots \\exists x_n. \\phi$, we simply write it as $\\exists \\vec{x}. \\phi$ with an intention that $\\vec{x} = (x_1, \\ldots, x_n)$.\n\nFor conjunctions $F = \\bigwedge_{1 \\leq i \\leq n} F_i$ and $G = \\bigwedge_{1 \\leq j \\leq m} G_j$ of formulae, we write $F \\subseteq G$ when for each $1 \\leq i \\leq n$, $F_i$ appears in $G$. That is, for each $1 \\leq i \\leq n$, there exists $1 \\leq j \\leq m$ with $F_i = G_j$.\n\nWe now define subclasses of objects defined above:\n  - a fact $P(\\vec{t})$ is *a base fact* if $\\vec{t}$ contains only constants (hence no nulls). We write $\\BaseFacts$ for the set of base facts.\n  - *an instance* is a finite set of facts. We write $\\Instances$ for the set $\\mathcal{P}_{\u003c \\omega}(\\Facts)$.\n  - an instance $I$ is *a base instance* if each fact in $I$ is a base fact.\n  - a formula is *a rectified formula* if no variable is bound twice, and no variable occurs both bound and free. By a standard renaming argument, any first-order formula is equivalent to a rectified formula. Hence from now on we will assume all formulae to be rectified.\n  - a formula is closed when every occurence of variable is bound.\n  - a closed formula is a *Tuple-Generating Dependency (or TGD)* if it is of the form $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ where $\\beta$ and $\\eta$ are conjunctions of atoms with $\\eta$ nonempty. In such a formula, $\\beta$ is referred to as the *body* and $\\eta$ is referred to as the *head* of this TGD.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is *a full TGD* if $\\vec{y}$ is empty, i.e. it is of the form $\\forall \\vec{x}. \\beta \\rightarrow \\eta$.\n  - a full TGD is *a Datalog rule* if its head contains exactly one atom. A finite set of Datalog rules is is called *a Datalog program*.\n  - a TGD is in a head-normal form if it is either a *Datalog rule*, or each atom in the head contains at least one existentially quantified variable.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is a *guarded-TGD (or GTGD)* if $\\beta$ contains an atom $P(\\vec{t})$ such that $\\vec{t} \\supseteq \\vec{x}$.\n  - a Conjunctive Query (CQ) is a formula of the form $\\exists \\vec{x}. \\bigwedge_i A_i$ where each $A_i$ is an atomic formula.\n\nWe say that a Datalog program $\\Sigma_\\rew$ is a *Datalog rewriting* of a finite collection $\\Sigma$ of GTDGs when for every base instance $I$ and a base fact $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_\\rew \\models F.$$\nA *factual substitution* is a partial function $\\sigma: \\Vars \\rightharpoonup \\FactualTerms$ with a finite domain. A factual substitution canonically extends to a partial function $\\Atoms \\rightharpoonup \\Facts$ that is defined on atoms all of whose variables are in the domain of $\\sigma$. We identity this extension of $\\sigma$ with $\\sigma$ by an abuse of notation. We write $\\FactualSubstitutions = (\\Vars \\rightharpoonup \\FactualTerms)_{\u003c \\omega}$ for the countable set of all factual substitutions.\n\nWe say that a factual substitution $\\sigma$ *covers* a set $\\vec{y}$ of variables when $\\elems(\\vec{y}) \\subseteq \\domain(\\sigma)$, and that $\\sigma$ *covers* an atom $A$ (resp. a vector of atoms $\\vec{A}$) when $\\sigma$ covers the set $\\vars(A)$ (resp. $\\vars(\\vec{A})$) of variables in $A$ (resp. $\\vec{A}$).\n\nWe say that a (potentially infinite) set $\\mathcal{F}$ of facts *witnesses a closed conjunctive query $\\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$* if there exists a factual substitution $\\sigma$ covering $\\vec{A}$ such that $$\\set{\\ \\sigma(A_i) \\mid 1 \\leq i \\leq n \\ } \\subseteq \\mathcal{F}.$$","lastmodified":"2022-11-07T04:15:08.50208943Z","tags":null},"/notes/notes/definitions/Rewriting-Existential-Lifting-and-Saturation":{"title":"","content":"\n\u003e This note builds on [[Logic Preliminaries]]\n\nGiven a set $\\Sigma$ of TGDs, a Datalog program $\\Sigma_{\\text{rew}}$ is *a rewriting of $\\Sigma$* if for every base instance $I$, $\\Sigma$ and $\\Sigma_{\\text{rew}}$ generate the same set of consequences, i.e. for every __base fact__ $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_{\\text{rew}} \\models F.$$\nGiven a fact $R(\\vec{f})$, the *existential lifting $\\exlift(R(\\vec{f}))$ of $R(\\vec{f})$* is defined as the formula $$\\exlift(R(\\vec{f})) := \\exists \\vec{\\nu}. R(\\vec{f}[\\ \\vec{n} \\leftarrow \\vec{\\nu}\\ ])$$\nwhere\n - $\\vec{\\nu}$ are variables corresponding to nulls in $\\vec{f}$,\n - $\\vec{f}[\\ \\vec{n} \\leftarrow \\vec{\\nu}\\ ]$ is $\\vec{f}$ with nulls replaced by their corresponding variables in $\\vec{\\nu}$. \n\nThe *existential lifting $\\exlift(I)$ of an instance $I$* is a set $\\set{\\ \\exlift(F) \\mid F \\in I\\ }$ of formulae.\n\nGiven a Datalog program $\\Sigma$ and an instance $I$, we define the *$k$-th partial Datalog-saturation $\\Sat^k_\\Sigma(I)$ of $I$ by $\\Sigma$* by induction on $k \\in \\mathbb{N}$, by $$\n\\begin{align}\n  \\Sat^0_\\Sigma(I) \u0026= I \\\\\n  \\Sat^{k + 1}_\\Sigma(I) \u0026= \\Sat^k_\\Sigma(I) \\cup \\set{\\ \\sigma(\\eta) \\mid (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma, \\sigma \\text{ covers } \\vec{x}, \\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)\\ }\n\\end{align}$$\nWe define the *Datalog saturation $\\Sat_\\Sigma(I)$ of $I$ by a Datalog program $\\Sigma$* as $$\\Sat_\\Sigma(I) = \\bigcup_{k \\in \\mathbb{N}} \\Sat^k_\\Sigma(I)$$\nMore generally, for an arbitrary finite collection $\\Sigma$ of GTDGs and an instance $I$, we define *the full saturation $\\FullSat_\\Sigma(I)$ of $I$ by $\\Sigma$* as $$\\FullSat_\\Sigma(I) = \\Sat_{\\Sigma_\\rew}(I)$$ for *some* Datalog rewriting $\\Sigma_\\rew$ of $\\Sigma$. This definition is well-defined, since any two Datalog rewritings produce the same Datalog saturation by definition. ","lastmodified":"2022-11-07T04:15:08.50208943Z","tags":null},"/notes/references/Papers":{"title":"","content":"## `Rewriting the Infinite Chase`\n\nLink: [latest version on GitHub pages](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf)\n\nTODO: write down the ideas that are explored in this paper\n\n## `A general Datalog-based framework for tractable query answering over ontologies`\n\nLink: [ScienceDirect](https://www.sciencedirect.com/science/article/pii/S1570826812000388)\n\nTODO: write down the ideas that are explored in this paper\n","lastmodified":"2022-11-07T04:15:08.50208943Z","tags":null},"/notes/thoughts/2022-11-01-About-template-constraints":{"title":"","content":"\n## Constraints on Partitioning Imposed by the Query\n\nSuppose that the following query is given as $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$.\n\nThere are a few ways this query could be witnessed by nulls in an infinite branch of the tree-like chase (a.k.a. \"tentacles\") or by constants in the collection of input or saturated facts (a.k.a. \"squid head\"). The following is an exhaustive list of all possible combinations:\n - 0 variable in the squid head\n\t - all of $x, y, z$ get witnessed in the same tentacle\n - 1 variable in the squid head\n\t - $x$ gets witnessed in the head and $y, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in different tentacles\n\t - $z$ gets witnessed in the head and $x, y$ get witnessed in the same tentacle\n - 2 variables in the squid head\n\t - $x$ and $y$ get witnessed in the head and $z$ gets witnessed in a tentacle\n\t - $x$ and $z$ get witnessed in the head and $y$ gets witnessed in a tentacle\n\t - $y$ and $z$ get witnessed in the head and $x$ gets witnessed in a tentacle\n - 3 variables in the squid head\n\t - All of $x, y, z$ get witnessed in the squid head\n\nThere are two impossible combinations, namely:\n\n - `x` gets witnessed in the head and $y$ and $z$ get witnessed in _different_ tentacles\n - `z` gets witnessed in the head and $y$ and $x$ get witnessed in _different_ tentacles\n\nTo see why, suppose $y$ and $z$ are instantiated as nulls $n_1$ and $n_2$ in _different tentacles_. Then there is nowhere in the infinite tree-like chase structure that proves $R(n_1, n_2)$, which uses $n_1$ and $n_2$ at the same time. So we conclude that: _if_ $y$ and $z$ are to be instantiated with nulls, _then_ that must be happen on the same tentacle.\n\nGeneralising the example above, we can see that: if the query contains an atom $P(\\vec{u})$ within the existential, then every vector witnessing $\\vec{u}$ in $P(\\vec{u})$ always have all the nulls appear in the single tentacle.\n\nSo we can deduce to a certain extent how the instantiation of variables may be distributed to different tentacles by just looking at the query.\n\n## Constraints Imposed by the Reasoning Rules\n\nIn this section, we shall write $\\Sigma$ for the generic set of rules.\n\nWhen a pseudoquery is proven in a tentacle of the infinite chase, one might imagine the following situation:\n\n![[Pasted image 20221101171150.png]]\n\nHowever, this diagram needs a slight modification: we will always get a set different from $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$ in the $i$-th step of this short-cut proof. This is because we cannot salvage atoms that are not facts (i.e. ones containing nulls) from branches steming from $I_i$. So on top of $I_i$, we are only going to add ***base facts*** that are derived from $I_i$ using $\\Sigma$ (my guess is that this is in general not even a subset of $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$; is this true?). So we wrill write fact-saturated sets of $I_i$ with $\\Sigma$ as $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_i)$.\n\nAlso, by splitting the pseudoquery we can assume that a pseudoquery is realized in $I_n$ as oppsed to $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_n)$, since if we are assuming all variables in an atom $F(\\vec{t})$ to be realized in the squid head, we may treat $F(\\vec{t})$ as a separate query (TODO: this is really hand-wavy!).\n\nIn fact we will have something like the following:\n\n![[Pasted image 20221101171906.png]]\n\n","lastmodified":"2022-11-07T04:15:08.50208943Z","tags":null}}