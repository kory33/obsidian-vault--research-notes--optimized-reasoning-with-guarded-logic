{"/":{"title":"Optimized Reasoning with Guarded Logic","content":"\nThis is the personal vault of Ryosuke Kondo filled with both random and organized notes concerning my fourth year project `\"Optimized Reasoning with Guarded Logic\"`.\n\n## About the Project\n\nThe aim of the project is to solve the \"open world querying problem\" in case of existential conjunctive queries together with a finite collection of Guarded Tuple Generating Dependencies (GTGDs) set as axioms.\n\nThe problem in the case of atomic queries has been solved by [`Rewriting the Infinite Chase`](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf) by means of rewriting the given set of GTGD rules to Datalog rules. This project tries to extend this result to binary (or possibly, general) conjunctive queries.\n\nSee [[Rewritings and Saturations]] for concepts involved.\n\n## Internal Links\n\n### References\n\n - [[Papers]] (summarises papers that I think will be useful at some point)\n\n### Thoughts\n\nSome random thoughts regarding the project.\n\n - [[2022-11-01 About template constraints]]\n\n### Notes\n\nA collection of more structured notes.\n\n - Definitions:\n\t - Every other notes (should) depend on definitions given in this folder. The definition are organized into a DAG that starts from [[General Notations]].\n - [[Decomposing the Larger Problem into Smaller Subproblems]]\n\n## External Links\n\n - [Project Handbook 2022](https://www.cs.ox.ac.uk/teaching/courses/projects/handbook/Project%20Handbook%202022.pdf)\n\n## Meta Information\n\nContents of this repository is mainly authored on Kondo's machine using [Obsidian](https://obsidian.md), git-managed and then synchronized to a git repository [hosted on GitHub](https://github.com/kory33/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic).\n","lastmodified":"2022-11-26T08:49:47.414352883Z","tags":null},"/notes/Decomposing-the-Larger-Problem-into-Smaller-Subproblems":{"title":"Decomposing the Larger Problem into Smaller Subproblems","content":"\n\u003e We shall build on definitions given in [[Chase-Like Trees and Saturated Chase-Like Trees]]. We will also rely on the results in [[Preliminary Results on Saturated Chase-Like Trees]], [[Witness Fragmentation and Witness Gluing]] and [[Witness Decomposition]].\n\nWe start with the following claim, whose proof we leave to some other part of the notes:\n\n\u003e **Theorem (SatTree Universality)**. For any finite set of GTGDs $\\Sigma$, a base instance $I$ and a binary conjunctive query $Q$, $I \\wedge \\Sigma \\models Q$ if and only if there exists a $(\\Sigma, I)$-witness for $Q$.\n\u003e \n\u003e \u003e *Proof*. TODO\n\nThe main problem of our concern is the following decision problem:\n\n\u003e **Definition**. `AnswerQuery(I, Σ, Q)` is the problem of deciding whether $I \\wedge \\Sigma \\models Q$ holds.\n\nThroughout this note, we shall assume that the input query $Q$ is given in a form $\\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, where $\\vec{x'}_i \\subseteq \\vec{x}$ for each $i$.\n\nBy SatTree Universality, we can answer $I \\wedge \\Sigma \\models Q$ by finding a $(\\Sigma, I)$-witness $\\sigma$ (or proving that none exists) for $Q$. By Fragmentation-Gluing Bijection, this amounts to finding a $Q$-fragmented $(\\Sigma, I)$-witness $(\\sigma_b, \\set{\\sigma'_V}_V)$ for $Q$.\n\nTo find a fragmented witness $(\\sigma_b, \\set{\\sigma'_V}_V)$, we can nondeterministically guess $\\sigma_b$ which determines the indexing set of $\\set{\\sigma'_V}_V$, and then nondeterministically guess each $\\sigma'_V$ that sends a connected component of $\\mathcal{H}(Q - \\domain(\\sigma_b))$ to a single tentacle. We can verify the choice for $\\sigma_b$ by simply looking at $\\Sat_\\Sigma(I)$, and verify the choice for $\\sigma'_V$ by actually computing $\\SatTree_\\Sigma(I)$ up until all the introduction points of nulls in $\\operatorname{im}(\\sigma'_V)$.\n\nThe method just described yields a nondeterministic algorithm[^1], which we shall refer to as `AnswerQueryNonDet1`, for the problem `AnswerQuery(-, -, -)`.\n\n```\nAnswerQueryNonDet1(I, Σ, Q):\n  σ_base_domain \u003c- nondeterministically guess a subset of vec{x}\n  σ_base \u003c- nondeterministically guess an assignment of constants to each variable in σ_base_domain\n\n  masked_H := (σ_base_domain)-masked query structure hypergraph of Q\n  SatBase := Sat_Σ(I)\n\n  // check the condition for the base substitution\n  for each j in J:\n    if all variables in Q_j(vec{x'}_j) are in σ_base_domain:\n      if σ_base(Q_j(vec{x'}_j)) ∉ SatBase:\n        REJECT\n      fi\n    fi\n  done\n\n  // nondeterministically guess fragments\n  for each V in the connected components of masked_H:\n    (τ_t, σ_t) \u003c- nondeterministically guess a valid generative chase-direction on (I, Σ)\n    σ_V \u003c- nondeterministically guess an assignment of nulls in the tentacle hanging from (τ_t, σ_t) for each variable in V\n\n    Q'_V := conjunction of all atoms in Q that only mention variables from V or σ_base_domain\n    T := compute the tree of shortcut Σ-chase along all introduction points of nulls that are in the image of σ_V\n\n    for each Q' in σ_base(σ_V(Q'_V)):\n      if NOT (Q' in some node of T):\n        REJECT\n      fi\n    done\n\n\t// at this point, σ_V witnesses the non-existential subquery Q'_V\n  done\n\n  ACCEPT\n```\n\nThis is only a semi-decision nondeterministic algorithm, since the set of choices that can be made for `σ_V` is in general infinite. It turns out that this can be fixed immediately if we suppose an oracle for the following problem:\n\n\u003e **Definition**. `WitnessedUnderTentacle(τ_t, σ_t, I, Σ, Q')` is the problem of deciding whether a binary conjunctive query $Q'$ is witnessed on a tentacle of $\\SatTree_\\Sigma(I)$ hanging from $(\\tau_t, \\sigma_t)$.\n\nSo now, assume that an oracle for the problem `WitnessedUnderSubTree(-, -, -, -, -)` has been given. Then successfully guessing the factual substitution `σ_V` is equivalent to `WitnessedUnderTentacle(τ_t, σ_t, I, Σ, Q'')`, where `Q''` is the existential query  $$\n\\begin{align}\n\\exists \\vec{x} \u0026= V. \\bigwedge_{j \\in J_{\\sigma_{\\text{base}, V}}} Q_j(\\vec{x'}_j) \\\\\n\n\u0026 \\text{where } J_{\\sigma_\\text{base}, V} = \\set{ j \\in J \\mid Q_j \\text { contains only variables from V and }  \\domain(\\sigma_\\text{base})}.\n\\end{align}\n$$\n\nHence we have the following nondeterministic decision procedure, which we call `AnswerQueryNonDet2`, `ACCEPT`ing whenever `AnswerQueryNonDet1` does and `REJECT`ing whenever `AnswerQueryNonDet1` does not `ACCEPT`:\n\n```diff\nAnswerQueryNonDet2(I, Σ, Q):\n  ...\n\n  // nondeterministically guess fragments\n  for each V in the connected components of masked_H:\n    (τ_t, σ_t) \u003c- nondeterministically guess a valid generative chase-direction on (I, Σ)\n\n-    σ_V \u003c- nondeterministically guess an assignment of nulls in the tentacle hanging from (τ_t, σ_t) for each variable in V\n-\n-    Q'_V := conjunction of all atoms in Q that only mention variables from V or σ_base_domain\n-    T := compute the tree of shortcut Σ-chase along all introduction points of nulls that are in the image of σ_V\n-\n-    for each Q' in σ_base(σ_V(Q'_V)):\n-      if NOT (Q' in some node of T):\n-        REJECT\n-      fi\n-    done\n-\n-\t // at this point, σ_V witnesses the non-existential subquery Q'_V\n+    A'_V := conjunction of all atoms in Q that only mention variables from V or σ_base_domain, with all variables in σ_base_domain substituted using σ_base\n+    Q'_V = ∃{x in V}. σ_base(A'_V)\n+    if NOT WitnessedUnderSubTree(τ_t, σ_t, I, Σ, Q'_V):\n+      REJECT\n+    fi\n+\n+    // at this point, there exists a σ_V witnessing the existential subquery Q'_V\n  done\n\n  ACCEPT\n```\n\n(TODO; explain why the following is equivalent to the previous program). We now have the following algorithm:\n\n```diff\nAnswerQueryNonDet3(I, Σ, Q):\n  ...\n\n  // nondeterministically guess fragments\n  for each V in the connected components of masked_H:\n    (τ_t, σ_t) \u003c- nondeterministically guess a valid generative chase-direction on (I, Σ)\n\n    A'_V := conjunction of all atoms in Q that only mention variables from V or σ_base_domain, with all variables in σ_base_domain substituted using σ_base\n-    Q'_V = ∃{x in V}. σ_base(A'_V)\n-    if NOT WitnessedUnderSubTree(τ_t, σ_t, I, Σ, Q'_V):\n-      REJECT\n-    fi\n+    Q'_V = ∃{x in V}. A'_V // has variables in σ_base_domain free\n+    if NOT σ_base IN AnswerNonBooleanQuery(GenericInstance(Abst_Σ(τ_t, σ_t; I)), Σ, Q'_V):\n+      REJECT\n+    fi\n\n-    // at this point, there exists a σ_V witnessing the existential subquery Q'_V\n+    // at this point, there exists a σ_V witnessing the existential subquery σ_base_domain(Q'_V)\n  done\n\n  ACCEPT\n```\n\nThe next algorithm much more redundant than `AnswerQueryNonDet3`, but is still equivalent:\n\n```diff\nAnswerQueryNonDet4(I, Σ, Q):\n  ...\n\n  // nondeterministically guess fragments\n  for each V in the connected components of masked_H:\n    (τ_t, σ_t) \u003c- nondeterministically guess a valid generative chase-direction on (I, Σ)\n\n    A'_V := conjunction of all atoms in Q that only mention variables from V or σ_base_domain, with all variables in σ_base_domain substituted using σ_base\n    Q'_V = ∃{x in V}. A'_V // has variables in σ_base_domain free\n-    if NOT σ_base IN AnswerNonBooleanQuery(GenericInstance(Abst_Σ(τ_t, σ_t; I)), Σ, Q'_V):\n-      REJECT\n-    fi\n+    T \u003c- nondeterministically guess a Σ-tentacle ejection template\n+    if NOT T is applicable to SatBase:\n+      REJECT\n+    fi\n+    if NOT σ_base IN AnswerNonBooleanQuery(GenericInstance(T), Σ, Q'_V):\n+      REJECT\n+    fi\n\n    // at this point, there exists a σ_V witnessing the existential subquery Q'_V\n  done\n\n  ACCEPT\n```\n\n## Towards a query-rule rewriting\n\n(TODO: There is a HUGE gap here; we need to fill in some definitions and prove stuff in order to argue that the following algorithm works.)\n\nTherefore, we obtain the following rewriting algorithm:\n\n 1. Let $\\Sigma_\\mathrm{rew}$ be a Datalog rewriting of $\\Sigma$.\n 2. Let $\\Sigma' \\leftarrow \\emptyset$ be a mutable variable of new full TGD rules\n 3. Let $\\mathcal{H}(Q) = (\\mathcal{V}, \\mathcal{E})$ be the query structure hypergraph of $Q$\n 4. For each connected sub-hypergraph $V$ of vertices in $\\mathcal{H}(Q)$, do the following:\n\t 1. Let $\\partial V$ be the boundary of $V$, and let $\\mathrm{Subgoal_V}$ be a new $|\\partial V|$-ary predicate symbol associated with $V$.\n\t 2. Let $\\exists \\vec{V}. Q_V$ be the subquery of $Q$ induced by $V$.\n\t 3. For each $\\Sigma$-tentacle ejection template $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$, do:\n\t\t 1. For every possible $T$-generic constant mapping $\\sigma: \\partial V \\rightarrow {\\sim}_\\tau$, do:\n\t\t\t 1. If $(T, \\sigma)$ generically $\\Sigma$-proves $\\exists \\vec{V}. Q_V$, then\n\t\t\t\t 1. Add a full TGD rule $F_\\tau \\rightarrow \\mathrm{Subgoal}_V(\\partial V)$ to $\\Sigma'$.\n 5. Let $\\mathrm{Goal}$ be the 0-ary goal predicate. \n 6. For each subset $V \\subseteq \\mathcal{V}$, do the following:\n\t 1. Let $\\set{C_i}_{i \\in I_V}$ be the set of connected components of $\\mathcal{H}(Q-V)$.\n\t 2. Let $\\mathrm{Goal}_V$ be a new $|V|$-ary predicate symbol associated with $V$.\n\t 3. Add a full TGD rule $(\\bigwedge_{i \\in I_V} \\mathrm{Subgoal}_{C_i}(\\partial C_i)) \\rightarrow \\mathrm{Goal_V}(V)$ to $\\Sigma'$.\n\t 4. Add a full TGD rule $\\mathrm{Goal_V}(V) \\rightarrow \\mathrm{Goal}()$ to $\\Sigma'$.\n 7. Return $\\Sigma_\\mathrm{rew} \\cup \\Sigma'$ as a query-rule-rewriting of $(\\Sigma, Q)$.\n\n[^1]: In a sense of an algorithm running on nondeterministic turing machines, so `ACCEPT`s if *any* nondeterministic branch `ACCEPT`s, and `REJECT`s if *no* nondeterministic branch `ACCEPT`s.","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/notes/Preliminary-Results-on-Saturated-Chase-Like-Trees":{"title":"Preliminary Results on Saturated Chase-Like Trees","content":"\n## General Definitions surrounding $\\SatTree$s\n\n\u003e **Definition.** For chase-like tree $T$ and its vertex $v \\in T_0$, we say that $v$ *mentions* a factual term $t$ if $\\Instance_T(v)$ contains a fact $P(\\vec{t'})$ such that $t \\in \\elems(\\vec{t'})$.\n\n\u003e **Definition.** For a chase-like tree $T$ and a factual term $t$, the _subgraph of $T$ mentioning $t$_, denoted $T \\upharpoonright t$, is the subgraph of $T$ induced by the vertex set $V_t = \\set{v \\in T \\mid v \\text{ mentions } t }$ together with the instance assignment restricted to $V_t$, i.e. $\\Instance_{T \\upharpoonright t} = \\Instance_T \\upharpoonright V_t$ .\n\nWe can see that the subgraph of a $\\SatTree$ mentioning $t$ really is then a subtree sitting in the $\\SatTree$ as seen in the following proposition:\n\n\u003e **Proposition**. For a finite set $\\Sigma$ of GTGDs, a base instance $I$ and any factual term $t$, $\\SatTree_\\Sigma(I) \\upharpoonright t$ is connected. In particular, if $t$ is mentioned in $\\TreeFacts(\\SatTree_\\Sigma(I))$, then $\\SatTree_\\Sigma(I) \\upharpoonright t$ is a rooted subtree of $\\SatTree_\\Sigma(I)$.\n\u003e \n\u003e _Proof_. By construction of $\\SatTree_\\Sigma(I)$, we have that\n\u003e  - a factual term not already mentioned in $I$ is never introduced by any chase-step direction from any node\n\u003e  - a null introduced at a node $\\vec{d}$ is never introduced anywhere else in the tree\n\nNow, for each factual term $t$ mentioned somewhere in the $\\SatTree$, we can identify where $t$ has been \"introduced\" in the tree:\n\n\u003e **Definition.** For a factual term $t$ mentioned in $\\TreeFacts(\\SatTree_\\Sigma(I))$, the *introduction point $\\Intro(t)$ of $t$* is the root node of the subtree $\\SatTree_\\Sigma(I) \\upharpoonright t$.\n\nClearly, $\\Intro(t)$ is the root node $()$ if and only if $t$ is a constant.\n\n## Fact Introduction Lemma\n\nWe have the following useful lemma:\n\n\u003e **Lemma (Fact Introduction)**. For a node $n$ of $\\SatTree_\\Sigma(I)$, its ancestor node $a$ and a fact $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(n)$, if $\\Intro(t) \\geq a$ for all $t \\in \\elems(\\vec{t})$, then $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(a)$.\n\u003e \n\u003e _Proof_. TODO (we would probably make a heavy use of this lemma when arguing validity of query reductions)\n\nAn immediate consequence of the lemma is the following:\n\n\u003e **Proposition**. If $P(\\vec{t}) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$ is a base fact, then $P(\\vec{t}) \\in \\Sat_\\Sigma(I)$. ^6bd969\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e By the assumption, $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(n)$ for some node $n \\in \\SatTree_\\Sigma(I)$.\n\u003e \u003e \n\u003e \u003e Now for all $t \\in \\elems(\\vec{t})$, $\\Intro(t)$ is the root node $()$, which is an ancestor of $n$. Therefore by the Fact Introduction lemma $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(()) = \\Sat_\\Sigma(I)$.\n","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/notes/Tentacle-Ejection-Templates":{"title":"Tentacle Ejection Templates","content":"\n## Preliminaries\n\n### In-place unifications\n\nWe shall first define what it means to identify (in-place) variables in a GTGD rule.\n\n\u003e **Definition**. Let $\\vec{x}$ be a set of variables. An *in-place unification on $\\vec{x}$* is a partition $\\sim_\\vec{x}$ of $\\elems(\\vec{x})$.\n\n\u003e **Example**. If $\\vec{x} = (x_0, x_1, x_2, x_3)$, then an equivalence relation given by a partition $\\set{\\set{x_0}, \\set{x_1, x_3}, \\set{x_2}}$ is an in-place unification on $\\vec{x}$.\n\n## Tentacle Ejection Templates\n\nWe first describe an object that abstractly describe a situation where a tentacle hangs from some saturation of some base instance:\n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs and $\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma$. A *$(\\tau, \\Sigma)$-export template* is a set $F$ of atomic formulae such that each $A \\in F$\n\u003e   1. only mentions variables from $\\elems(\\vec{x})$ and constants from $\\Sigma$, and\n\u003e   2. is guarded by some atom in $\\eta$.\n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs. A *$\\Sigma$-tentacle ejection template* is a triple $(\\tau, \\sim_\\tau, F_\\tau)$ where $\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma$, $\\sim_\\tau$ is an in-place unification on $\\vec{x}$ and $F_\\tau$ is a $(\\tau, \\Sigma)$-export template.\n\nNext, we define what is means to \"instantiate\" $\\Sigma$-tentacle ejection templates.\n\n\u003e **Definition**. Let $\\vec{x}$ be a set of variables and $\\sim_\\vec{x}$ an in-place unification on $\\vec{x}$. A factual substitution $\\sigma: \\Vars \\rightharpoonup \\Consts$ is said to *conform to $\\sim_\\vec{x}$* if $\\sigma$ covers exactly $\\vec{x}$ and for each $x_1, x_2 \\in \\elems(\\vec{x})$, and $$\\sigma(x_1) = \\sigma(x_2) \\Longleftrightarrow x_1 \\sim_\\vec{x} x_2.$$ In other words, $\\sigma$ covering exactly $\\vec{x}$ conforms to $\\sim_\\vec{x}$ if and only if $\\mathrm{ker}(\\sigma) = \\sim_\\vec{x}$ where $\\mathrm{ker}(\\sigma)$ is the set-theoretic kernel of $\\sigma$.\n\u003e\n\u003e \u003e *Example*. If $\\vec{x} = (x_0, x_1, x_2, x_3)$ and $\\elems(\\vec{x}) / \\sim_\\vec{x} = \\set{\\set{x_0}, \\set{x_1, x_3}, \\set{x_2}}$ as in the previous example, then a substitution $\\sigma$ given by $$\n\\begin{array}{c c}\n  \\sigma: \u0026\\Vars \u0026\\rightharpoonup \u0026\\Consts \\\\\n          \u0026x_0 \u0026\\mapsto \u0026c_3 \\\\\n          \u0026x_1 \u0026\\mapsto \u0026c_6 \\\\\n          \u0026x_2 \u0026\\mapsto \u0026c_2 \\\\\n          \u0026x_3 \u0026\\mapsto \u0026c_6 \\\\\n\\end{array}\n$$ conforms to $\\sim_\\vec{x}$.\n\n\u003e **Definition** Let $\\Sigma$ be a finite set of GTGDs, and $T = (\\tau, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template. Given a factual substitution $\\sigma$ (TODO: we can assume that the image of $\\sigma$ lies in $\\Consts$) that conforms to $\\sim_\\tau$, the *$\\Sigma$-instantiation $\\Tentacle_\\Sigma(T, \\sigma)$ of $T$ with $\\sigma$* is defined as the subtree of $\\SatTree_\\Sigma(\\sigma(F_\\tau))$ induced by the set of nodes in $\\SatTree_\\Sigma(\\sigma(F_\\tau))$ that either\n\u003e   1. is the root node, or\n\u003e   2. corresponds to a valid generative $\\Sigma$-chase-path on $\\sigma(F_\\tau)$ and starts with $(\\tau, \\sigma)$.\n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance, $T = (\\tau, \\sim_\\tau, F_\\tau)$ a $\\Sigma$-tentacle ejection template and $\\sigma$ a factual substitution conforming to $\\sim_\\tau$. We say that *$T$ can be $\\Sigma$-instantiated on $I$ using $\\sigma$* if $\\sigma(F_\\tau) \\subseteq \\FullSat_\\Sigma(I)$. If $T$ can be instantiated on $I$ using *some* factual substitution $\\sigma$, we say that $T$ is applicable to $I$.\n\nNot surprisingly, an instantiation of a $\\Sigma$-tentacle ejection template embeds into the original SatTree, in the following sense:\n\n\u003e **Proposition (Ejection Embedding)**.\n\u003e Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance and $T = (\\tau, \\sim_\\tau, F_\\tau)$ a $\\Sigma$-tentacle ejection template that can be instantiated on $I$ using $\\sigma$. Then for each node $\\vec{d}$ in $\\Tentacle_\\Sigma(T, \\sigma)$,\n\u003e  1. $\\vec{d}$ is a valid generative $\\Sigma$-chase-path on $I$, i.e. is a node in $\\SatTree_\\Sigma(I)$, and moreover,\n\u003e  2. $\\Instance_{\\Tentacle_\\Sigma(T, \\sigma)}(\\vec{d}) \\subseteq \\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$\n\u003e \n\u003e \u003e *Proof*. Since $\\Tentacle_\\Sigma(T, \\sigma)$ is a subtree of $\\SatTree_\\Sigma(\\sigma(F_\\tau))$, the proposition is obvious from the SatTree monotonicity.\n\n### Tentacle Abstraction\n\nWe have just seen that the instantiation of a tentacle $(\\tau, \\sim_\\tau, F_\\tau)$ with a substitution $\\sigma$ is a way of turning a tentacle ejection template into a chase-like tree that can be actually embeded to a tentacle hanging from $(\\tau, \\sigma)$.\n\nWe now describe a way to \"abstract\" an actual tentacle to a tentacle ejection template that can be instantiated back to the original tentacle.\n\n\u003e **Definition**. Let $(\\tau, \\sigma)$ be a valid generative $\\Sigma$-chase-path on $I$. We define the *abstraction $\\Abst_\\Sigma(\\tau, \\sigma; I)$ of $(\\tau, \\sigma)$* to be the $\\Sigma$-tentacle ejection template $(\\tau, \\sim_\\sigma, F_{\\Sigma, \\tau, \\sigma})$ where\n\u003e   - $\\sim_\\sigma$ is the relation given by $x_1 \\sim_\\sigma x_2 \\Longleftrightarrow \\sigma(x_1) = \\sigma(x_2)$\n\u003e   - $F_{\\Sigma, \\tau, \\sigma} =$ (TODO; this should be all the exports carried outside from $\\FullSat(I)$, but we need constants \"abstracted\" to variables)\n\nAs promised, $\\Abst_\\Sigma(-, -; I)$ is a right inverse to $\\Tentacle_\\Sigma$:\n\n\u003e **Lemma (abstraction-instantiation)**. Let $T$ be the subtree of $\\Tentacle_\\Sigma(\\Abst_\\Sigma(\\tau, \\sigma; I), \\sigma)$ induced by all non-root nodes. Then $T$ equals the tentacle of $\\SatTree_\\Sigma(I)$ hanging from $(\\tau, \\sigma)$.\n\u003e \n\u003e \u003e *Proof*. (TODO)\n\n## Generic Proofs and Ejection Templates\n\nThroughout this section, whenever we take a generic $\\Sigma$-tentacle ejection template $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$ and a (not necessarily boolean) conjunctive query $Q = \\exists \\vec{z}. \\bigwedge_{i \\in I} A_i(\\vec{w_i})$, by renaming bound variables we shall assume that $\\vec{x}, \\vec{y}$, $\\vec{z}$ and $\\operatorname{FV}(Q)$ are all disjoint to each other.\n\n\u003e **Definition**. For a set $\\Sigma$ of finite GTGDs, a *$\\Sigma$-generic constant assignment* is a computable function $\\GenConst_\\Sigma: \\mathcal{P}_\\mathrm{fin}(\\Vars) \\rightarrow \\Consts$ such that $\\mathrm{im}(\\GenConst) \\cap \\consts(\\Sigma) = \\emptyset$.\n\n\u003e **Remark**. From now on, we shall assume that, for each $\\Sigma$, we have decided a choice on a $\\Sigma$-generic constant assignment $\\GenConst_\\Sigma$. We shall refer to this particular function as *the* $\\Sigma$-generic constant assignment.\n\n\u003e **Definition**. Let $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template. The *generic instance $\\GenInst_\\Sigma(T)$ associated with $T$* is the instance $$\\GenInst_\\Sigma(T) := \\set{ \\GenConst_\\Sigma(F) \\mid F \\in F_\\tau }.$$\n\n\u003e **Definition**. Let $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template, and let $Q$ be a (*not necessarily boolean*) conjunctive query.  A *$T$-expectation on $Q$* is a map $\\sigma: \\operatorname{FV}(Q) \\rightarrow {\\sim}_\\tau$.\n\u003e \n\u003e \u003e *Remark*. The reason we call such $\\sigma$ an *expectation* is because we will later expect that the closure of $Q$ by $\\sigma$ will be witnessed in a tentacle hanging from the generic instance associated with $T$.\n\n\u003e **Definition**. Let $T = (\\tau, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template, $Q = \\exists \\vec{z}. \\bigwedge_{i \\in I} A_i(\\vec{w_i})$ a conjunctive query and $\\sigma: \\mathrm{FV}(Q) \\rightarrow {\\sim_\\tau}$ a $T$-expectation on $Q$. The *$\\sigma$-closure of $Q$* is a boolean conjunctive query $\\mathrm{cl}_\\sigma(Q)$ given by $$\\mathrm{cl}_\\sigma(Q) = \\exists \\vec{z}. \\bigwedge_{i \\in I} A_i((\\GenConst_\\Sigma \\circ \\sigma)(\\vec{w_i}))$$\n\n\u003e **Definition**. Let $T$ be a $\\Sigma$-tentacle ejection template, $Q$ a conjunctive query and $\\sigma_Q: \\mathrm{FV}(Q) \\rightarrow {\\sim_\\tau}$ a $T$-expectation on $Q$. We say that $(T, \\sigma_Q)$ *generically proves* $Q$ when $\\GenInst_\\Sigma(T) \\wedge \\Sigma \\models \\mathrm{cl}_\\sigma(Q)$.\n\n### Witness Fragments and Generic Proofs\n\nIt turns out that the generic proofs are universal abstraction of situations where a fragmented witness occurs within a tentacle. We formalize this idea as follows:\n\n\u003e **Proposition**. Let $I$ be a base instance, $T$ a $\\Sigma$-tentacle ejection template that can be $\\sigma$-instantiated on $T$, and $Q$ a conjunctive query. (TODO: formlize the idea that in this situation $Q$ is \"witnessed\" under a tentacle hanging from $(\\tau_T, \\sigma)$)\n","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/notes/Witness-Decomposition":{"title":"Witness Decomposition","content":"\n\u003e This note depends on [[Witness Fragmentation and Witness Gluing]]\n\nIn this note, we shall see how a $(\\Sigma, I)$-witness for a BCQ must be constrained, and how that constraints maps to fragmented witnesses by the fragmentation-gluing bijeciton. \n\n## Witness Decomposition\n\nFirst, we have the following proposition, which states that \"vertices adjacent in $\\mathcal{H}(Q - \\touchDowners(\\sigma))$ must be sent to nulls lying the same chase-path\":\n\n\u003e **Proposition**. For a binary conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$ and a $(\\Sigma, I)$-witness $\\sigma$, if two variables $x_1$ and $x_2$ appear in a single atom $Q_j(\\vec{x'}_j)$ for some $j \\in J$, then $\\Intro(\\sigma(x_1))$ and $\\Intro(\\sigma(x_2))$ are $\\leq$-comparable.\n\u003e \n\u003e \u003e *Proof*. By assumption on $\\sigma$, there exists a node (i.e. a valid chase-path on $I$) $\\vec{d}$ such that $Q_j(\\sigma(\\vec{x'}_j)) \\in \\Instance_{\\SatTree_\\Sigma(I)}(n)$. Since both $\\SatTree_\\Sigma(I) \\upharpoonright \\sigma(x_1)$ and $\\SatTree_\\Sigma(I) \\upharpoonright \\sigma(x_2)$ are rooted subtrees containing $n$, both $\\Intro(\\sigma(x_1))$ and $\\Intro(\\sigma(x_2))$ are ancestors of $n$, so all of $\\set{ n, \\Intro(\\sigma(x_1)), \\Intro(\\sigma(x_2)) }$ lie on the same path in $\\SatTree_\\Sigma(I)$.\n\nNow we define the property of a witness:\n\n\u003e **Definition**. Let $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$ be a BCQ, $\\sigma$ a $(\\Sigma, I)$-witness and $X \\subseteq \\elems(\\vec{x})$. We say that *$\\sigma$ sends the entire $X$ to a single tentacle* if there exists a tentacle $T$ of $\\SatTree_\\Sigma(I)$ such that $\\Intro(\\sigma(x)) \\in T$ for every $x \\in X$.\n\nFrom this proposition, we can deduce the *witness decomposition*, as described in the following lemma:\n\n\u003e **Lemma (Witness Decomposition)**. Let $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$ be a BCQ, $\\sigma$ a $(\\Sigma, I)$-witness and $V$ a connected component $\\mathcal{H}(Q - \\touchDowners(\\sigma))$. Then $\\sigma$ sends the entire $V$ to a single tentacle. ^a87015\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e The previous proposition implies that, if two variables $x_1$ and $x_2$ are adjacent in $\\mathcal{H}(Q - \\touchDowners(\\sigma))$, then in particular they lie in the same tentacle.\n\u003e \u003e \n\u003e \u003e So take any two variables $x_1, x_2$ in $V \\in \\ConnComp(\\mathcal{H}(Q - \\touchDowners(\\sigma)))$. By connectedness of $V$, there exists a path $x_1 E_0 y_0 \\ldots y_{k-1} E_k x_2$ from $x_1$ to $x_2$. By induction on $k$, all of $y_0, \\ldots, y_{k-1}$ lie in the same tentacle in which $x_1$ is introduced, so $x_1$ and $x_2$ are introduced in the same tentacle.\n\n## Fragmented Witness Decomposition\n\nThe Witness Decomposition lemma shown above can be easily translated to the statement about fragmented witnesses using the Fragmentation-Gluing Bijection. We state this in the following theorem.\n\n\u003e **Theorem (Fragmented Witness Decomposition)**. Let $Q$ be a binary conjunctive query and $(\\sigma_b, \\set{\\sigma'_V}_V)$ a $Q$-fragmented $(\\Sigma, I)$-witness for $Q$. Then for each $V' \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$, $\\sigma'_{V'}: V' \\rightarrow \\Nulls$ sends the entire $V'$ a single tentacle.\n\u003e \n\u003e \u003e *Proof*. Let $\\sigma = \\Glue(\\sigma_b, \\set{\\sigma'_V}_V)$ be the gluing of $(\\sigma_b, \\set{\\sigma'_V}_V)$. By applying Witness Decomposition Lemma to $\\sigma$, $\\sigma$ sends the entire $V'$ to a single tentacle. Because $\\sigma$ and $\\sigma_{V'}$ agree on $V'$, $\\sigma_V$ sends the entire $V'$ to a single tentacle.\n","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/notes/Witness-Fragmentation-and-Witness-Gluing":{"title":"Witness Fragmentation and Witness Gluing","content":"\n\u003e This note depends on [[Preliminary Results on Saturated Chase-Like Trees]].\n\nThis note explores the relationship between ordinary witnesses and \"fragmented witnesses\", which will be defined in the following sections. First, we begin with some preliminary definitions.\n\n\u003e **Definition**. For a boolean conjunctive query $Q$ and its witness $(\\sigma, \\mathcal{F})$, the *set of touchdowners* $\\touchDowners(\\sigma)$ of $\\sigma$ is the set $\\sigma^{-1}[\\consts(\\mathcal{F})]$ of variables that get sent to constants in $\\mathcal{F}$.\n\u003e \n\u003e **Examples**: ![[Pasted image 20221116200624.png]]![[Pasted image 20221116200657.png]] \n\n\u003e **Definition**. For a valid generative chase-path $((\\tau, \\sigma))$ on $I$, we define the *tentacle of $\\SatTree_\\Sigma(I)$ hanging from $(\\tau, \\sigma)$* to be the subtree of $\\SatTree_\\Sigma(I)$ induced by all descendants of the node $((\\tau, \\sigma))$. We call $(\\tau, \\sigma)$ the *wrist* of the tentacle that hangs from $(\\tau, \\sigma)$.\n\n\u003e **Definition**. For a binary conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_i Q_i(\\vec{x'}_i)$, the *query structure hypergraph $\\mathcal{H}(Q)$* of $Q$ is the labelled hypergraph defined with\n\u003e  - the vertex set $V_Q = \\elems(\\vec{x})$\n\u003e  - for each $i$, a hyperedge named $Q_i$ that spans $\\elems(\\vec{x'}_i) \\subseteq V_Q$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_i Q_i(\\vec{x'}_i)$ and a subset $X$ of $\\elems(\\vec{x})$, the *$X$-masked query structure hypergraph*, denoted $\\mathcal{H}(Q-X)$, is the hypergraph obtained by weak-deleting [^1] all vertices in $X$.\n\n## Witness Gluing\n\nWe can \"glue\" small witnesses together to form a $(\\Sigma, I)$-witness for a query. To make this precise, we start with some definitions.\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ is *a base-factual substitution* if $\\operatorname{im} \\sigma \\subseteq \\Consts$, and that it is a *null-factual substitution* if $\\operatorname{im} \\sigma \\subseteq \\Nulls$.\n\n\u003e **Definition**. Given a finite set $\\Sigma$ of GTGDs, a base instance $I$ and a boolean conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, a *Q-fragmented substitution* is a pair $(\\sigma_b, \\set{ \\sigma'_V }_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b))})$ such that\n\u003e  - $\\sigma_b$ is a base-factual substitution such that $\\domain(\\sigma_b) \\subseteq \\elems(\\vec{x})$\n\u003e  - for each $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$, $\\sigma'_V$ is a null-factual substitution with $\\domain(\\sigma'_V) = V$.\n\u003e\n\u003e \u003e *Notational convention*. We will often omit the indexing set of the family $\\set{\\sigma'_V}_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b))}$ and simply write it as $\\set{\\sigma'_V}_V$.\n\n\u003e **Remark**. By construction, a $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$ is a *collection of compatible factual substitutions*, in a sense that $\\sigma_b \\not\\in \\set{\\sigma'_V}_V$, and for each pair $\\sigma_1, \\sigma_2$ of factual substitutions in the set $\\set{ \\sigma_b } \\cup \\set{ \\sigma'_V }_V$, $\\domain(\\sigma_1) \\cup \\domain(\\sigma_2) \\neq \\emptyset \\Longrightarrow \\sigma_1 = \\sigma_2$.\n\n\u003e **Definition**. By the previous remark, for a $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$, the set-theoretic union $\\bigcup(\\set{ \\sigma_b } \\cup \\set{ \\sigma'_V }_V)$ is a well-defined factual substitution. We shall call this union the *gluing of $(\\sigma_b, \\set{\\sigma'_V}_V)$*, and denote it by $\\Glue_Q(\\sigma_b, \\set{\\sigma'_V}_V)$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, a $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$ is said to be a *$Q$-fragmented $(\\Sigma, I)$-witness for $Q$* if\n\u003e  - for each $Q_j(\\vec{x'}_j)$ in $Q$ such that $\\elems(\\vec{x'}_j) \\subseteq \\domain(\\sigma_b)$, the fact $Q_j(\\sigma_b(\\vec{x'}_j))$ is an element of $\\Sat_\\Sigma(I)$, which is the instance assigned to the root of $\\SatTree_\\Sigma(I)$\n\u003e  - for each connected component $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$ and each predicate $Q_j(\\vec{x'}_j)$ corresponding to an edge $Q_j$ contained in $V$, the fact $Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j))$ is an element of $\\TreeFacts(\\SatTree_\\Sigma(I))$.\n\nThen almost by definition we obtain the following lemma:\n\n\u003e **Lemma (Witness Gluing)**. Suppose $(\\sigma_b, \\set{\\sigma'_V}_V)$ is a $Q$-fragmented $(\\Sigma, I)$-witness for $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$. Then $(\\Glue_Q(\\sigma_b, \\set{\\sigma'_V}_V), \\SatTree_\\Sigma(I))$ is a witness for $Q$.\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e Write $\\sigma$ for the factual substitution $\\Glue_Q(\\sigma_b, \\set{\\sigma'_V}_V)$. Clearly $\\sigma$ exactly covers $\\vec{x}$.\n\u003e \u003e \n\u003e \u003e Now pick $j \\in J$. We need to see that $Q_j(\\sigma(\\vec{x'}_j))$ is an element of $\\TreeFacts(\\SatTree_\\Sigma(I))$.\n\u003e \u003e \n\u003e \u003e If the edge $Q_j$ does not span any vertex in $\\mathcal{H}(Q - \\domain(\\sigma_b))$, then $Q_j$ does not mention any variable *not in* $\\domain(\\sigma_b)$. Hence $\\elems(\\vec{x'}_j) \\subseteq \\domain(\\sigma_b)$, so by the assumption on $(\\sigma_b, \\set{\\sigma'_V}_V)$, the fact $Q_j(\\sigma_b(\\vec{x'}_j))$ appears in $\\Sat_\\Sigma(I)$, hence in $\\TreeFacts(\\SatTree_\\Sigma(I))$.\n\u003e \u003e \n\u003e \u003e So suppose that $Q_j$ does span a vertex $x$ in $\\mathcal{H}(Q - \\domain(\\sigma_b))$. Then $x$ belongs to some connected component $V$ of $\\mathcal{H}(Q - \\domain(\\sigma_b))$, and by definition of being a connected component $Q_j$ spans vertices in $V$. So by assumption on $(\\sigma_b, \\set{\\sigma'_V}_V)$, $Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j))$ is an element of $\\TreeFacts(\\SatTree_\\Sigma(I))$. As $\\sigma \\supseteq \\sigma_V \\circ \\sigma_b$, $Q_j(\\sigma(\\vec{x'}_j)) = Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j)) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$.\n\n## Fragmentation and Gluing\n\nIn this section, we shall see that fragmented witnesses and witnesses are in a bijective relation via the gluging operation and its inverse operation, which we shall call \"fragmentation\".\n\nWe begin with the definition of the fragmentation operator $\\Frag_Q$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$ and a factual substitution $\\sigma$ covering $\\vec{x}$, define the *fragmentation $\\Frag_Q(\\sigma)$ of $\\sigma$* as the $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))})$, where\n\u003e  - $\\sigma_b$ is a restriction of $\\sigma$ to $\\touchDowners(\\sigma)$\n\u003e  - for each $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$, $\\sigma'_V: V \\rightarrow \\Facts$ is a restriction of $\\sigma$ to $V$\n\nThen the following holds:\n\n\u003e **Lemma (Witness Fragmentation)**. If $\\sigma$ is a $(\\Sigma, I)$-witness for a BCQ $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, then $\\Frag_Q(\\sigma)$ is a $Q$-fragmented $(\\Sigma, I)$-witness for $Q$.\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e Let $(\\sigma_b, \\set{\\sigma'_V}_V) = \\Frag_Q(\\sigma)$. We check that this is in fact a $Q$-fragmented $(\\Sigma, I)$-witness for $Q$ according to the definition of $Q$-fragmented witnesses.\n\u003e \u003e \n\u003e \u003e To check the first condition, take $j \\in J$ such that $\\elems(\\vec{x'}_j) \\subseteq \\domain(\\sigma_b)$. Then since $Q_j(\\sigma(\\vec{x'}_j)) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$, by a consequence of Fact Introduction lemma, $Q_j(\\sigma(\\vec{x'}_j)) \\in \\Sat_\\Sigma(I)$.\n\u003e \u003e \n\u003e \u003e To check the second condition, take $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$ and $j \\in J$ such that $Q_j$ lies entirely in $V$. Now $(\\sigma_V \\circ \\sigma_b)(x) = \\sigma(x)$ for each $x \\in V \\cup \\domain(\\sigma_b)$ by construction of $\\sigma_V$ and $\\sigma_b$, and as $\\vec{x'}_j$ only contains variables from $V \\cup \\domain(\\sigma_b)$, $Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j)) = Q_j(\\sigma(\\vec{x'}_j)) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$.\n\nAs a corollary, we have the following propositions:\n\n\u003e **Proposition**. $\\Frag_Q$ defines a assignment of $Q$-fragmented $(\\Sigma, I)$-witnesses for $Q$ on the set of $(\\Sigma, I)$-witnesses for $Q$\n\n\u003e **Theorem (Fragmentation-Gluing Bijection)**. For a BCQ $Q$, $\\Frag_Q$ and $\\Glue_Q$ are mutual bijections between $(\\Sigma, I)$-witnesses for $Q$ and $Q$-fragmented $(\\Sigma, I)$-witnesses for $Q$.\n\u003e \n\u003e \u003e *Proof*. We only need to check that the two maps are mutual inverses. But this is the case by definition: $\\Frag_Q \\circ \\Glue_Q$ essentially unions fragmented substitutions and then restricts them to respective domains, while $\\Glue_Q \\circ \\Frag_Q$ unions all restricted substitutions, recovering the original substitution.\n\n\n[^1]: see Ch. 7, [[Books#^327283]] for details","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/notes/definitions/Chase-Like-Trees-and-Saturated-Chase-Like-Trees":{"title":"Chase-Like Trees and Saturated Chase-Like Trees","content":"\n\u003e This note builds on [[Rewritings and Saturations]]\n\nWe shall define a tree structure that \"stems from a base instance $I$ and witnesses every possible conclusion that can be $\\Sigma$-deduced from $I$\". To make this idea precise, we define a few concepts.\n\n## Some generic definitions \n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs. We say that _a set $G$ of factual terms is $\\Sigma$-guarded by a set of factual terms $\\vec{t}$_ when $G \\subseteq \\consts(\\Sigma) \\cup \\vec{t}$ .\n\n\u003e **Definition**. Injective functions of the form $\\nu: \\mathbb{N} \\rightarrow \\Nulls$ will be referred to as *null-picking functions*.\n\n\u003e **Definition**. For a null-picking function $\\nu$, a vector $\\vec{y} = (y_1, \\ldots, y_n)$ of variables and a factual substitution $\\sigma$ whose domain is disjoint from $\\vec{y}$, we define *the factual substitution $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls]$* with domain $\\domain(\\sigma) + \\elems(\\vec{y})$ that substitutes each $y_i$ to distinct nulls (chosen by $\\nu$) and follows $\\sigma$ elsewhere: $$\n\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](x)=\n\\begin{cases}\n    n_{\\nu(i)} \u0026 \\text{if $x = y_i$} \\\\\n    \\sigma(x) \u0026 \\text{if $x \\in \\domain(\\sigma)$}\n\\end{cases}$$\n\n\u003e **Definition**. For a TGD $\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$, an instance $I$ and a factual substitution $\\sigma$ that covers $\\vec{x}$, we say that *$I$ can be $\\tau$-chased with $\\sigma$* when $\\sigma(\\beta) \\subseteq I$.\n\nIntuitively, this means that the premise $\\beta$ is witnessed by some facts in $I$, and $\\sigma$ specifies which constant or null appearing in $I$ is witnessing each variable in $\\vec{x}$.\n\nWe shall describe how an instance can be \"extended\" by applying a GTGD.\n\n\u003e **Definition**. Given a null-picking function $\\nu$, a finite set $\\Sigma$ of GTGDs, an element $\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma$ and an instance $I$ that can be $\\tau$-chased with a factual substitution $\\sigma$, we define:\n\u003e  - *the $(\\tau, \\sigma)$-chase head $\\chaseHead_\\nu(\\tau, \\sigma)$ (through $\\nu$)* to be the set $$\\chaseHead_\\nu(\\tau, \\sigma) := \\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta).$$ of facts. \n\u003e    Intuitively, this is a set of new facts generated from $I$ by applying the rule $\\tau$ with $\\sigma$.\n\u003e  - *the $\\Sigma$-exports $\\exports_\\Sigma(I, (\\tau, \\sigma))$ from $I$ along $(\\tau, \\sigma)$* to be the set $$\\exports_\\Sigma(I, (\\tau, \\sigma)) := \\set{\\ F \\in I\\ |\\ F \\text{ is } \\Sigma \\text{-guarded by }\\chaseHead_\\nu(\\tau, \\sigma) \\ }.$$\n\u003e  - *the one-step $\\Sigma$-chase $\\chase_{\\Sigma, \\nu}(I, (\\tau, \\sigma))$ of $I$ with $(\\tau, \\sigma)$ (through $\\nu$)* to be an instance defined by  $$\\chase_{\\Sigma, \\nu}(I, (\\tau, \\sigma)) := \\chaseHead_\\nu(\\tau, \\sigma) \\cup \\exports_\\Sigma(I, (\\tau, \\sigma)).$$\n\n### Chase-Like Trees\n\n\u003e **Definition**. A *chase-like tree $T$* is a directed rooted tree $(T_0, v_r)$ together with the *instance assignment* $\\operatorname{Instance}_T: V(T_0) \\rightarrow \\Instances$ of instances to vertices.\n\n\u003e **Definition**. For a chase-like tree $T$ with the instance assignment $\\operatorname{Instance}_T$, we define the instance $\\TreeFacts(T)$ as the union $\\bigcup \\mathrm{im} \\operatorname{Instance}_T$ of images of the instance assignment.\n\n### The Canonical Global Null-Picking Function\n\n\u003e **Definition**. We write $\\ChaseStepDir$ for the set $\\GTGDFormulae \\times \\FactualSubstitutions$, and call a pair $(\\tau, \\sigma) \\in \\ChaseStepDir$ a *generic chase-step direction*. We call a finite (resp. infinite) sequence of generic chase-step directions a *finite (resp. infinite) generic chase-path*.\n\n\u003e**Definition**. We fix a coding function (hence a computable injection into $\\mathbb{N}$) $$\\#: \\ChaseStepDir^{\u003c \\omega} \\times \\mathbb{N} \\rightarrow \\mathbb{N}$$ on pairs of a finite generic chase-path and a natural.\n\nBy precomposing $\\#$ to the canonical null-picking function $\\nu_{\\mathrm{id}}(i \\in \\mathbb{N}) = n_i$ and currying, we obtain a $\\ChaseStepDir^{\u003c \\omega}$-indexed family $\\set{ \\widehat{\\#_\\vec{d}}}_{\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}}$ of null-picking functions. More explicitly, we have the following:\n\n\u003e**Definition**. For each $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, we define *the canonical null-picking function $\\widehat{\\#_{\\vec{d}}}$ at $\\vec{d}$* to be the function $$\n\\begin{align}\n\\widehat{\\#_{\\vec{d}}} : \\mathbb{N} \u0026 \\rightarrow \\Nulls\\\\\n                                   i \u0026 \\mapsto n_{\\#(\\vec{d}, i)}\n\\end{align}\n$$\n\nThis family of null-picking functions will be used in the following definition to formally ensure that no null introduced in one branch is brought to its sibling branches.\n\n## Saturated Chase-Like Trees\n\nThroughout this section, we shall fix some finite set $\\Sigma$ of head-normal GTGDs.\n\nFrom now on, we would like to work with specialized chase-step directions:\n\n\u003e **Definition**. We write $\\ChaseStepDir_\\Sigma$ for the set $\\Sigma \\times \\FactualSubstitutions$, and call a pair $(\\tau, \\sigma) \\in \\Sigma \\times \\FactualSubstitutions$ a *$\\Sigma$-chase-step direction*. We call a finite (resp. infinite) sequence of $\\Sigma$-chase-step directions a *finite (resp. infinite) $\\Sigma$-chase-path*.\n\n\u003e **Definition**. We say that a $\\Sigma$-chase-step direction $(\\tau, \\sigma)$ is *generative* if $\\tau$ is a non-full rule, and that a $\\Sigma$-chase-path $\\vec{d}$ is *generative* if each $(\\tau, \\sigma) \\in \\elems(\\vec{d})$ is generative.\n\n\u003e **Definition**. Given a base instance $I$, define, by induction on finite chase-paths $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, the *shortcut $\\Sigma$-chase $\\operatorname{SC}_{\\Sigma, \\vec{d}}(I)$ of $I$ along $\\vec{d}$* by $$\n\\begin{align}\n  \\operatorname{SC}_{\\Sigma, ()}(I) \u0026= \\FullSat_\\Sigma(I) \\\\\n  \\operatorname{SC}_{\\Sigma, \\vec{d} \\concat (\\tau, \\sigma)}(I) \u0026=\n    \\begin{cases}\n      \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{SC}_{\\Sigma, \\vec{d}}(I), (\\tau, \\sigma))) \u0026 \\text{if $\\operatorname{SC}_{\\Sigma, \\vec{d}}(I)$ can be $\\tau$-chased with $\\sigma$} \\\\\n      \\emptyset \u0026 \\text{otherwise}\n    \\end{cases}\n\\end{align}\n$$\n\n\u003e **Definition**. For a base instance $I$ and a finite chase-path $\\vec{d}$, we say that $\\vec{d}$ is *a valid $\\Sigma$-chase-path on $I$* if either $\\operatorname{SC}_{\\Sigma, \\vec{d}}(I) \\neq \\emptyset$ or both $I$ and $\\vec{d}$ are empty.\n\n\u003e **Definition**. The *$\\Sigma$-saturated chase-like tree $\\SatTree_\\Sigma(I)$ of a base instance $I$* is a chase-like tree with:\n\u003e  - the set $(\\ChaseStepDir^{\u003c \\omega})_{\\Sigma\\mathrm{, valid, gen}}$ of *all* valid generative $\\Sigma$-chase-paths on $I$ as the vertex set\n\u003e  - (labelled) edges of the form $\\vec{p} \\xrightarrow{d} \\vec{p} \\concat (d)$ for each pair of vertices (hence valid , generative $\\Sigma$-chase-paths) $\\vec{p}$ and $\\vec{p} \\concat (d)$\n\u003e  - the instance assignment function defined by $$\n\\begin{array}{c c}\n\\operatorname{Instance}_{\\SatTree_\\Sigma(I)}:\n  \u0026(\\ChaseStepDir^{\u003c \\omega})_{\\Sigma\\mathrm{, valid, gen}} \u0026 \\longrightarrow \u0026\\Instances \\\\\n  \u0026\\vec{d} \u0026\\longmapsto \u0026\\operatorname{SC}_{\\Sigma, \\vec{d}}(I)\n\\end{array}\n$$\n\n\u003e **Proposition (SatTree monotonicity)**. If $\\Sigma$ is a finite set of GTGDs and $I \\subseteq I'$ are base instances, then for each node $\\vec{d}$ in $\\SatTree_\\Sigma(I)$,\n\u003e   1. $\\vec{d}$ is also a node in $\\SatTree_\\Sigma(I')$, and moreover,\n\u003e   2. $\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d}) \\subseteq \\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d})$.\n\u003e\n\u003e \u003e *Proof*. We show both of (1) and (2) simultaneously by induction on $\\vec{d}$.\n\u003e \u003e \n\u003e \u003e (Base case):\n\u003e \u003e   1. Obvious.\n\u003e \u003e   2. By saturation monotonicity.\n\u003e \u003e (Inductive part):\n\u003e \u003e  Let $\\vec{d} \\concat (\\tau, \\sigma)$ be a node in $\\SatTree_\\Sigma(I)$, hence a valid generative $\\Sigma$-chase-path on $I$. Then $\\vec{d}$ is a node in $\\SatTree_\\Sigma(I)$, so by inductive hypothesis, $\\vec{d}$ is a valid generative $\\Sigma$-chase-path on $I'$, and $\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d}) \\subseteq \\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d}))$. Then we have:\n\u003e \u003e    1. Since $\\vec{d} \\concat (\\tau, \\sigma)$ is a valid $\\Sigma$-chase-path on $I$, by definition of $\\Instance_{\\SatTree_\\Sigma(I)}$, $\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$ can be $\\tau$-chased with $\\sigma$. So $\\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d}) \\supseteq \\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$ can also be $\\tau$-chased with $\\sigma$, and $\\vec{d} \\concat (\\tau, \\sigma)$ is a valid $\\Sigma$-chase-path on $I'$ as well. Moreover,\n\u003e \u003e    2. as $\\chase$ is clearly monotonic in its first argument, we have $$\n\\begin{align}\n\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d} \\concat (\\tau, \\sigma))\n \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d}), (\\tau, \\sigma))) \\\\\n \u0026\\subseteq \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d}), (\\tau, \\sigma))) \\\\\n \u0026= \\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d} \\concat (\\tau, \\sigma)).\n\\end{align}\n$$\n\nWe will often deal with witnesses of the form $(\\sigma, \\TreeFacts(\\SatTree_\\Sigma(I)))$. This motivates a distinguished name for such witnesses:\n\n\u003e **Definition**. For a BCQ $Q$, we say that a factual substitution $\\sigma$ is *a $(\\Sigma, I)$-witness for $Q$* when $(\\sigma, \\TreeFacts(\\SatTree_\\Sigma(I)))$ is a witness for $Q$.\n\n","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/notes/definitions/General-Notations":{"title":"General Notations","content":"\n\u003e This section defines general notations used throughout the notes.\n\nFor a formal finite sequence $(X_1, \\ldots, X_n)$ of same sorts, we abbriviate it as $\\vec{X}$. The set $\\set{\\ X_1, \\ldots, X_n\\ }$ will then be denoted as $\\elems(\\vec{X})$. We write $\\vec{X'} \\triangleleft \\vec{X}$ to mean that $\\vec{X'}$ is an initial segment of $\\vec{X}$, $\\vec{X'} \\leq \\vec{X}$ to mean that $\\vec{X'}$ is a subsequence of $\\vec{X}$ and $X' \\subseteq X$ to mean $\\elems(\\vec{X'}) \\subseteq \\elems(\\vec{X})$.\n\nFor two formal finite sequences $\\vec{X}$ and $\\vec{Y}$, we denote by $\\vec{X} \\concat \\vec{Y}$ the concatenation of $\\vec{X}$ and $\\vec{Y}$. For a nonempty (possibly infinite) sequence $(x) \\concat \\vec{X}$, we write $\\head((x) \\concat \\vec{X})$ to mean the first element $x$ of the sequence.\n\nA pair $(T, v_r)$ of a directed acyclic graph $T$ and a vertex $v_r \\in V(T)$ is called a *directed tree rooted at $v_r$* if the underlying undirected graph of $T$ is a tree and every $v \\in V(T) \\setminus \\set{v_r}$ has precisely one vertex $p_v \\in V(T)$ such that there is an edge $(p_v, v) \\in E(T)$. We shall often call $T$ a *rooted tree*.\n\nFor a directed tree $T$, we say that a node $u$ is a _descendant_ of $v$, written $u \u003c v$, when there is a (directed) path from $v$ to $u$.\n\nFor a hypergraph $\\mathcal{H} = (V, \\mathcal{E})$, we write $\\ConnComp(\\mathcal{H})$ for the set of connected components (i.e. the quotient of $V$ under the smallest equivalence relation $\\sim$ containing $x_1 \\sim x_2$ for each $x_1, x_2$ such that there is a hyperedge $E \\in \\mathcal{E}$ that spans both $x_1$ and $x_2$).\n\nWe write $f: A \\rightharpoonup B$ to mean that $f$ is a partial function from $A$ to $B$. We denote by $\\domain(f)$ to mean the domain of $f$, and write $\\isDefinedAt{f}{x}$ to mean that $x \\in \\domain(f) \\subseteq A$, i.e. $f$ is defined at $x \\in A$.","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/notes/definitions/Logic-Preliminaries":{"title":"Logic Preliminaries","content":"\n\u003e This note builds on [[General Notations]].\n\nThis note mainly pulls definitions from [Rewriting the Infinite Chase](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf), but with quite a lot of modifications.\n\nWe assume the countably infinite collection $\\Vars = \\set{x_0, x_1, \\ldots}$ of variables, the ordered set $\\Nulls = \\set{\\ n_i \\mid i \\in \\mathbb{N}\\ }$ of *labelled nulls*, some given fixed (at most countable) set $\\Consts = \\set{c_0, c_1, \\ldots}$ of constants. We also assume an infinite collection $\\Predicates = \\set{P_0, P_1, \\ldots}$ of predicate symbols, such that there is an associated *arity-function* $\\Arity: \\Predicates \\rightarrow \\mathbb{N}$ such that the preimage $\\Arity^{-1}[\\set{n}]$ of $n \\in \\mathbb{N}$ is always infinite.\n\nWe say that a tuple $\\mathcal{L} = (\\Vars_\\mathcal{L}, \\Nulls_\\mathcal{L}, \\Consts_\\mathcal{L}, \\Predicates_\\mathcal{L})$ where $\\Vars_\\mathcal{L} \\subseteq \\Vars$ and so on, is a *first-order language*. For a first order language $\\mathcal{L} = (\\Vars_\\mathcal{L}, \\Nulls_\\mathcal{L}, \\Consts_\\mathcal{L}, \\Predicates_\\mathcal{L})$, we define:\n - *the set $\\Terms_\\mathcal{L}$ of (non-null) terms* as $\\Vars_\\mathcal{L} \\cup \\Consts_\\mathcal{L}$\n - *the set $\\NullableTerms_\\mathcal{L}$ of nullable terms* as $\\Vars_\\mathcal{L} \\cup \\Consts_\\mathcal{L} \\cup \\Nulls_\\mathcal{L}$\n - _the set $\\FactualTerms_\\mathcal{L}$ of factual terms_ as $\\Nulls_\\mathcal{L} \\cup \\Consts_\\mathcal{L}$\n - _the set $\\Atoms_\\mathcal{L}$ of atomic formulae (resp. the set $\\Facts_\\mathcal{L}$ of facts)_ to be a set of formal expression $P(t_1, t_2, \\ldots, t_{\\Arity(P)})$ with $P \\in \\Predicates_\\mathcal{L}$, $t_i \\in \\Terms_\\mathcal{L}$ (resp. $\\FactualTerms_\\mathcal{L}$) for each $1 \\leq i \\leq \\Arity(P)$\n - *the set $\\Formulae_\\mathcal{L}$ of (first-order) formulas under the signature $(\\Predicates_\\mathcal{L}, \\Consts_\\mathcal{L})$* to be a set of formal expressions inductively built up from $\\Atoms_\\mathcal{L}$ using unary connective $\\neg$, binary connectives $\\wedge, \\vee, \\rightarrow$ and quantifiers $\\exists x.$ and $\\forall x.$ (where $x \\in \\Vars_\\mathcal{L}$)\n\nFor most of the following definitions, we will assume some fixed first-order language $\\mathcal{L}$ and omit the subscript $_\\mathcal{L}$ unless it becomes necessary to specify the language. \n\n\u003e **Notational remark**. By an abuse of notation, we may omit the subscript $_\\mathcal{L}$ to denote the \"unconstraint version\" of the inductive construction. For example, by $\\Atoms$ we may simply mean the set of formal expressions of the form $P(t_1, \\ldots, t_{\\Arity(P)})$ where $P \\in \\Predicates$ and $t_i \\in \\Terms = \\Vars \\cup \\Consts$ for each $1 \\leq i \\leq \\Arity(P)$.\n\nSemantics (interpretation, logical-consequence relation and truth) of formulae is defined using the standard terminology. We also follow standard conventions concerning variables being *bound* and *free*.\n\nFor brevity, we adopt the following notational conventions:\n  - for a an atomic formula $P(t_1, \\ldots, t_{\\Arity(P)})$, we simply write it as $P(\\vec{t})$ with an intention that $\\vec{t} = (t_1, \\ldots, t_{\\Arity(P)})$.\n  - for a formula of a form $\\exists x_1. \\exists x_2. \\ldots \\exists x_n. \\phi$, we simply write it as $\\exists \\vec{x}. \\phi$ with an intention that $\\vec{x} = (x_1, \\ldots, x_n)$.\n\nFor conjunctions $F = \\bigwedge_{1 \\leq i \\leq n} F_i$ and $G = \\bigwedge_{1 \\leq j \\leq m} G_j$ of formulae, we write $F \\subseteq G$ when for each $1 \\leq i \\leq n$, $F_i$ appears in $G$. That is, for each $1 \\leq i \\leq n$, there exists $1 \\leq j \\leq m$ with $F_i = G_j$.\n\nWe now define subclasses of objects defined above:\n  - a fact $P(\\vec{t})$ is *a base fact* if $\\vec{t}$ contains only constants (hence no nulls). We write $\\BaseFacts$ for the set of base facts.\n  - *an instance* is a finite set of facts. We write $\\Instances$ for the set $\\mathcal{P}_{\u003c \\omega}(\\Facts)$.\n  - an instance $I$ is *a base instance* if each fact in $I$ is a base fact.\n  - a formula is *a rectified formula* if no variable is bound twice, and no variable occurs both bound and free. By a standard renaming argument, any first-order formula is equivalent to a rectified formula. Hence from now on we will assume all formulae to be rectified.\n  - a formula is closed when every occurence of variable is bound.\n  - a closed formula is a *Tuple-Generating Dependency (or TGD)* if it is of the form $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ where $\\beta$ and $\\eta$ are conjunctions of atoms with $\\eta$ nonempty. In such a formula, $\\beta$ is referred to as the *body* and $\\eta$ is referred to as the *head* of this TGD.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is *a full TGD* if $\\vec{y}$ is empty, i.e. it is of the form $\\forall \\vec{x}. \\beta \\rightarrow \\eta$.\n  - a full TGD is *a Datalog rule* if its head contains exactly one atom. A finite set of Datalog rules is is called *a Datalog program*.\n  - a TGD is in a head-normal form if it is either a *Datalog rule*, or each atom in the head contains at least one existentially quantified variable.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is a *guarded-TGD (or GTGD)* if $\\beta$ contains an atom $P(\\vec{t})$ such that $\\vec{t} \\supseteq \\vec{x}$. We write $\\GTGDFormulae_\\mathcal{L}$ for the set of $\\mathcal{L}$-formulae that are GTGDs.\n  - a Conjunctive Query (CQ) is a formula of the form $\\exists \\vec{x}. \\bigwedge_i A_i$ where each $A_i$ is an atomic formula.\n\nWe say that a Datalog program $\\Sigma_\\rew$ is a *Datalog rewriting* of a finite collection $\\Sigma$ of GTGDs when for every base instance $I$ and a base fact $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_\\rew \\models F.$$\n\n## Notions of Substitutions\n\n### Factual subtitutions\n\n\u003e **Definition**. A *factual substitution* is a partial function $\\sigma: \\Vars \\rightharpoonup \\FactualTerms$ with a finite domain.\n\nA factual substitution canonically extends to a partial function $\\Atoms \\rightharpoonup \\Facts$ that is defined on atoms all of whose variables are in the domain of $\\sigma$. We identity this extension of $\\sigma$ with $\\sigma$ by an abuse of notation.\n\n\u003e **Definition**. We write $\\FactualSubstitutions = (\\Vars \\rightharpoonup \\FactualTerms)_{\u003c \\omega}$ for the countable set of all factual substitutions.\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ *covers* a set $\\vec{y}$ of variables when $\\elems(\\vec{y}) \\subseteq \\domain(\\sigma)$, and say that $\\sigma$ *exactly covers $\\vec{y}$* if $\\elems(\\vec{y}) = \\domain(\\sigma)$.\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ together with a (potentially infinite) set $\\mathcal{F}$ of facts *witness a boolean conjunctive query $\\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$* if $\\sigma$ exactly covers $\\vec{x}$ and $$\\set{\\ \\sigma(A_i) \\mid 1 \\leq i \\leq n \\ } \\subseteq \\mathcal{F}.$$\n\n### Consts translations\n\n\u003e **Definition**. A *consts translation* is a function $\\sigma: \\Consts \\rightarrow \\Consts$.\n\nA consts translation $\\sigma$ then canonically extends to a function $\\tilde{\\sigma}: \\Facts \\rightarrow \\Facts$ that applies $\\sigma$ to each constant appearing in a fact (without modifying nulls). Then $\\tilde{\\sigma}$ further extends to a function $\\tilde{\\tilde{\\sigma}}: \\Instance \\rightarrow \\Instance$ that applies $\\tilde{\\sigma}$ to each fact in an instance. By an abuse of notation we shall identify all of $\\sigma, \\tilde{\\sigma}$ and $\\tilde{\\tilde{\\sigma}}$.\n","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/notes/definitions/Rewritings-and-Saturations":{"title":"Rewriting, Existential Lifting and Saturation","content":"\n\u003e This note builds on [[Logic Preliminaries]]\n\n\u003e **Definition**. Given a set $\\Sigma$ of TGDs, a Datalog program $\\Sigma_{\\text{rew}}$ is *a rule-rewriting of $\\Sigma$* if, for every base instance $I$, $\\Sigma$ and $\\Sigma_{\\text{rew}}$ generate the same set of **base facts**, i.e. for every base fact $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_{\\text{rew}} \\models F.$$\n\n\u003e **Definition**. Given a set $\\Sigma$ of TGDs and a conjunctive query $Q$, we say that a Datalog program $\\Sigma^Q_\\rew$ together with a fresh *0-ary goal predicate* $\\mathrm{Goal^Q}()$ is a *query-rule-rewriting of $(\\Sigma, Q)$* if for every base instance $I$, $$I \\wedge \\Sigma \\models Q \\Longleftrightarrow I \\wedge \\Sigma^Q_\\rew \\models \\mathrm{Goal^Q}(). $$\n\n\u003e **Definition**. Given a Datalog program $\\Sigma$ and an instance $I$, we define the *$k$-th partial Datalog-saturation $\\Sat^k_\\Sigma(I)$ of $I$ by $\\Sigma$* by induction on $k \\in \\mathbb{N}$, by $$\\begin{align}\n  \\Sat^0_\\Sigma(I) \u0026= I \\\\\n  \\Sat^{k + 1}_\\Sigma(I) \u0026= \\Sat^k_\\Sigma(I) \\cup \\set{\\ \\sigma(\\eta) \\mid (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma, \\sigma \\text{ covers } \\vec{x}, \\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)\\ }\n\\end{align}$$\n\n\u003e **Proposition**. If $I \\subseteq I'$ are instances and $\\Sigma$ is a finite set of GTGDs, then for each $k \\in \\mathbb{N}$, $\\Sat^k_\\Sigma(I) \\subseteq \\Sat^k_\\Sigma(I')$.\n\u003e \n\u003e \u003e *Proof*. By a simple induction on $k$.\n\n\u003e **Proposition**. Let $\\Sigma$ be a Datalog program and $I$ an instance. Then for each $k \\in \\mathbb{N}$ and for all base fact $F$, if $F \\in \\Sat_\\Sigma^k(I)$ then $I \\wedge \\Sigma \\vdash F$  (by $\\vdash$ we simply mean \"provable in natural deduction\"). ^7faefd\n\u003e \n\u003e \u003e *Proof*. By induction on $k$.\n\u003e \u003e \n\u003e \u003e The base case is obvious, since if $F \\in \\Sat^0_\\Sigma(I) = I$, $I \\vdash F$ and therefore $I \\wedge \\Sigma \\vdash F$. \n\u003e \u003e \n\u003e \u003e For the inductive part, suppose $F \\in \\Sat^{k+1}_\\Sigma(I)$. If $F \\in \\Sat^k_\\Sigma(I)$ then we are done by the inductive hypothesis. Otherwise, there must be some $(\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma$ and a factual substitution $\\sigma$ covering $\\vec{x}$ such that $\\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)$, and $F = \\sigma(\\eta)$. By inductive hypothesis, each atom $F \\in \\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)$ can be derived from $I \\wedge \\Sigma$, hence $I \\wedge \\Sigma \\vdash \\sigma(\\beta)$. Since $\\sigma(\\beta) \\rightarrow \\sigma(\\eta)$ can be deduced from $\\Sigma$ in one step, by modus ponens $I \\wedge \\Sigma \\vdash \\sigma(\\eta)$.\n\n\u003e **Definition**. The *Datalog saturation $\\Sat_\\Sigma(I)$ of $I$ by a Datalog program $\\Sigma$* is defined as the instance $$\\Sat_\\Sigma(I) = \\bigcup_{k \\in \\mathbb{N}} \\Sat^k_\\Sigma(I).$$\n\n\u003e **Proposition (Saturation monotonicity)**. If $I \\subseteq I'$ are instances and $\\Sigma$ is a finite set of GTGDs, then $\\Sat_\\Sigma(I) \\subseteq \\Sat_\\Sigma(I')$.\n\u003e \n\u003e \u003e *Proof*. By monotonicity of $\\Sat^k_\\Sigma(-)$ for each $k \\in \\mathbb{N}$.\n\n\u003e **Theorem (Base-fact completeness of Datalog saturations)**.\n\u003e Let $I$ be a base instance, $F$ a base fact and $\\Sigma$ be a Datalog program. Then $$F \\in \\Sat_\\Sigma(I) \\Longleftrightarrow I \\wedge \\Sigma \\models F.$$\n\u003e ^b7f0b5\n\u003e \u003e *Proof*.\n\u003e \u003e ($\\Longrightarrow$): By [[#^7faefd]] and soundness of the proof system of predicate logic, $$\n\\begin{align}\nF \\in \\Sat_\\Sigma(I)\n  \u0026\\Longrightarrow F \\in \\Sat_\\Sigma^k(I) \\text{ for some } k \\in \\mathbb{N} \\\\\n  \u0026\\Longrightarrow I \\wedge \\Sigma \\vdash F \\\\\n  \u0026\\Longrightarrow I \\wedge \\Sigma \\models F \\\\\n\\end{align}$$\n\u003e \u003e ($\\Longleftarrow$):\n\u003e \u003e Let $\\mathcal{M}$ be a model that makes precisely the facts in $\\Sat_\\Sigma(I)$ true. We then have $\\mathcal{M} \\models I$, since $\\Sat_\\Sigma(I) \\supseteq \\Sat^0_\\Sigma(I) = I$.\n\u003e \u003e \n\u003e \u003e \u003e **Claim**. $\\mathcal{M} \\models \\Sigma$.\n\u003e \u003e \u003e *Proof of the claim*. Take any $\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma$. We show that $\\mathcal{M} \\models \\tau$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e So take any factual substitution $\\sigma$ such that $\\mathcal{M} \\models \\sigma(\\beta)$. By construction of $\\mathcal{M}$, $\\sigma(\\beta) \\subseteq \\Sat_\\Sigma(I)$. Since $\\sigma(\\beta)$ is finite, $\\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)$ for some $k \\in \\mathbb{N}$. But then by definition of $\\Sat^{k+1}_\\Sigma(I)$, $\\sigma(\\eta) \\in \\Sat^{k+1}_\\Sigma(I) \\subseteq \\Sat_\\Sigma(I)$, so $\\mathcal{M} \\models \\sigma(\\eta)$.\n\u003e \u003e\n\u003e \u003e Therefore $\\mathcal{M} \\models I \\wedge \\Sigma$ and by assumption $\\mathcal{M} \\models F$. But then by construction of $\\mathcal{M}$, $F \\in \\Sat_\\Sigma(I)$.\n\u003e \u003e \n\n\u003e **Definition**. Let $\\Sigma$ be a finite collection of TGDs and $I$ an instance.\n\u003e \n\u003e If $\\Sigma$ has some rule-rewriting $\\Sigma_\\mathrm{rew}$, then we define *the full saturation $\\FullSat_\\Sigma(I)$ of $I$ by $\\Sigma$* as $$\\FullSat_\\Sigma(I) = \\Sat_{\\Sigma_\\rew}(I).$$ \n\u003e \u003e *Remark*. This definition is well-defined, i.e. does not depende on the choice of $\\Sigma_\\mathrm{rew}$, since any two Datalog rewritings produce the same Datalog saturation by definition. \n\nAs a corollary to [[#^b7f0b5]], we have the following.\n\n\u003e **Corollary**. Suppose that $\\Sigma$ is a set of TGDs that admit a rule-rewriting. Then for a base instance $I$ and a base fact $F$, $$F \\in \\FullSat_\\Sigma(I) \\Longleftrightarrow I \\wedge \\Sigma \\models F.$$\n\u003e \u003e *Proof*. $$\n\\begin{align}\n  F \\in \\FullSat_\\Sigma(I)\n    \u0026\\Longleftrightarrow F \\in \\Sat_{\\Sigma_\\mathrm{rew}}(I) \\\\\n    \u0026\\Longleftrightarrow I \\wedge \\Sigma_\\mathrm{rew} \\models F \\\\\n    \u0026\\Longleftrightarrow I \\wedge \\Sigma \\models F.\n\\end{align}\n$$\n","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/references/Books":{"title":"Books","content":"\n## `Introduction to Graph and Hypergraph Theory`\n\n^327283\n\n[SOLO permalink](https://solo.bodleian.ox.ac.uk/permalink/f/89vilt/oxfaleph000591771), EBook ISBN: `9781614701125`\n\nI used a few terminologies from this book to describe/define notions about hypergraphs.","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/references/Papers":{"title":"Papers","content":"\n## `Rewriting the Infinite Chase`\n\nLink: [latest version on GitHub pages](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf)\n\nTODO: write down the ideas that are explored in this paper\n\n## `A general Datalog-based framework for tractable query answering over ontologies`\n\nLink: [ScienceDirect](https://www.sciencedirect.com/science/article/pii/S1570826812000388)\n\nTODO: write down the ideas that are explored in this paper\n","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/thoughts/2022-11-01-About-template-constraints":{"title":"2022-11-01 About template constraints","content":"\n## Constraints on Partitioning Imposed by the Query\n\nSuppose that the following query is given as $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$.\n\nThere are a few ways this query could be witnessed by nulls in an infinite branch of the tree-like chase (a.k.a. \"tentacles\") or by constants in the collection of input or saturated facts (a.k.a. \"squid head\"). The following is an exhaustive list of all possible combinations:\n - 0 variable in the squid head\n\t - all of $x, y, z$ get witnessed in the same tentacle\n - 1 variable in the squid head\n\t - $x$ gets witnessed in the head and $y, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in different tentacles\n\t - $z$ gets witnessed in the head and $x, y$ get witnessed in the same tentacle\n - 2 variables in the squid head\n\t - $x$ and $y$ get witnessed in the head and $z$ gets witnessed in a tentacle\n\t - $x$ and $z$ get witnessed in the head and $y$ gets witnessed in a tentacle\n\t - $y$ and $z$ get witnessed in the head and $x$ gets witnessed in a tentacle\n - 3 variables in the squid head\n\t - All of $x, y, z$ get witnessed in the squid head\n\nThere are two impossible combinations, namely:\n\n - `x` gets witnessed in the head and $y$ and $z$ get witnessed in _different_ tentacles\n - `z` gets witnessed in the head and $y$ and $x$ get witnessed in _different_ tentacles\n\nTo see why, suppose $y$ and $z$ are instantiated as nulls $n_1$ and $n_2$ in _different tentacles_. Then there is nowhere in the infinite tree-like chase structure that proves $R(n_1, n_2)$, which uses $n_1$ and $n_2$ at the same time. So we conclude that: _if_ $y$ and $z$ are to be instantiated with nulls, _then_ that must be happen on the same tentacle.\n\nGeneralising the example above, we can see that: if the query contains an atom $P(\\vec{u})$ within the existential, then every vector witnessing $\\vec{u}$ in $P(\\vec{u})$ always have all the nulls appear in the single tentacle.\n\nSo we can deduce to a certain extent how the instantiation of variables may be distributed to different tentacles by just looking at the query.\n\n## Constraints Imposed by the Reasoning Rules\n\nIn this section, we shall write $\\Sigma$ for the generic set of rules.\n\nWhen a pseudoquery is proven in a tentacle of the infinite chase, one might imagine the following situation:\n\n![[Pasted image 20221101171150.png]]\n\nHowever, this diagram needs a slight modification: we will always get a set different from $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$ in the $i$-th step of this short-cut proof. This is because we cannot salvage atoms that are not facts (i.e. ones containing nulls) from branches steming from $I_i$. So on top of $I_i$, we are only going to add ***base facts*** that are derived from $I_i$ using $\\Sigma$ (my guess is that this is in general not even a subset of $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$; is this true?). So we wrill write fact-saturated sets of $I_i$ with $\\Sigma$ as $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_i)$.\n\nAlso, by splitting the pseudoquery we can assume that a pseudoquery is realized in $I_n$ as oppsed to $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_n)$, since if we are assuming all variables in an atom $F(\\vec{t})$ to be realized in the squid head, we may treat $F(\\vec{t})$ as a separate query (TODO: this is really hand-wavy!).\n\nIn fact we will have something like the following:\n\n![[Pasted image 20221101171906.png]]\n\n","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null},"/thoughts/2022-11-09-Head-Tentacle-Partitions-and-Pseudo-Witnesses":{"title":"2022-11-09 Head-Tentacle Partitions and Pseudo-Witnesses","content":"\nWe explorered before in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]] a few possibility on how the entire query can be witnessed by nulls in different tentacles.\n\nLet us be more precise and formal.\n\n**Definition**. For a vector $\\vec{x}$ of distinct variables, we say that a pair $(H, \\mathcal{T})$ is a _head-tentacle partition of $\\vec{x}$_ when\n - $H \\subseteq \\elems(\\vec{x})$ and $\\mathcal{T} \\subseteq \\mathcal{P}(\\elems(\\vec{x}))$\n - $H \\not\\in \\mathcal{T}$\n - Either\n\t - $H = \\emptyset$ and $\\mathcal{T}$ is a partition (i.e. a cover of disjoint nonempty sets) of $\\elems(\\vec{x})$\n\t - $\\set{H} \\cup \\mathcal{T}$ is a partition of $\\elems(\\vec{x})$\n\n**Definition**. For a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$, define the corresponding _compatible cover_ $(H, \\mathcal{T})_\\text{cover}$ as the set $\\set{ H \\cup T \\mid T \\in \\mathcal{T} }$.\n\n**Definition**. Given a boolean conjunctive query $$Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i(\\vec{v_i})$$ we say that a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$ is _compatible with $Q$_ if, for every $1 \\leq i \\leq n$ and every $x_1, x_2 \\in \\elems(\\vec{v_i})$, there exists $C \\in (H, \\mathcal{T})_\\text{cover}$ such that $\\set{x_1, x_2} \\subseteq C$.\n\n**Definition**. For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$, the _witness pattern $\\mathrm{Pat}_\\sigma$ of $\\sigma$_ is the head-tentacle paritition $(H, \\mathcal{T})$ defined by $$\\begin{align}\nH \u0026= \\set{ x \\in \\elems(\\vec{x}) \\mid \\sigma(x) \\text{ is a constant}} \\\\\nT \u0026= (\\elems(\\vec{x}) \\setminus H) / \\sim\n\\end{align}$$ where $\\sim$ is the equivalence relation given by $x_1 \\sim x_2$ iff $\\sigma(x_1)$ and $\\sigma(x_2)$ appear in the same tentacle (TODO: define this precisely; it should be easy thanks to the explicit construction of $\\SatTree_\\Sigma(I)$).\n\n**Claim**:  For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$ (TODO: define notions so that this statement can be shortened), $\\mathrm{Pat}_\\sigma$ is compatible with $Q$.\n\n---\nNow that we defined notions, we can say the same thing as in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]], but more concisely:\n\nFor a query $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$, the following are the only head-tentacle partitions compatible with $Q$:\n - $(\\emptyset, \\set{\\set{x, y, z}})$\n - $(\\set{x}, \\set{\\set{y, z}})$\n - $(\\set{y}, \\set{\\set{x, z}})$\n - $(\\set{y}, \\set{\\set{x}, \\set{z}})$\n - $(\\set{z}, \\set{x, y})$\n - $(\\set{x, y}, \\set{\\set{z}})$\n - $(\\set{x, z}, \\set{\\set{y}})$\n - $(\\set{y, z}, \\set{\\set{x}})$\n - $(\\set{x, y, z}, \\emptyset)$\n\nLet us tinker with this example.\n\n**Question.** Given a finite set $\\Sigma$ of GTGDs, is $$\n\\left(\n\\Sigma \\cup \\left\\lbrace\n  \\begin{aligned}\n  \u0026 \\forall u, v. R(u, v) \\rightarrow \\mathrm{Subgoal}_\\mathrm{left}(v), \\\\\n  \u0026 \\forall v, w. R(v, w) \\rightarrow \\mathrm{Subgoal}_\\mathrm{right}(v), \\\\\n  \u0026 \\forall v. \\mathrm{Subgoal}_\\mathrm{left}(v) \\wedge \\mathrm{Subgoal}_\\mathrm{right}(v) \\rightarrow \\mathrm{Goal}^Q() \\\\\n\\end{aligned}\n\\right\\rbrace\n\\right)_\\mathrm{rew}\n$$ a query-rule-rewriting of $(\\Sigma, Q)$?\n\n**Answer**: For each possible head-tentacle partition, we can \"enrich\" the $\\SatTree$ by added rules and see if $\\mathrm{Goal}^Q()$ can be derived using chase steps.","lastmodified":"2022-11-26T08:49:47.418352931Z","tags":null}}