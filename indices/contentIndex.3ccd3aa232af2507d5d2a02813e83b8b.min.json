{"/":{"title":"Optimized Reasoning with Guarded Logic","content":"\nThis is the personal vault of Ryosuke Kondo filled with both random and organized notes concerning my fourth year project `\"Optimized Reasoning with Guarded Logic\"`.\n\n## About the Project\n\nThe aim of the project is to solve the \"open world querying problem\" in case of existential conjunctive queries together with a finite collection of Guarded Tuple Generating Dependencies (GTGDs) set as axioms.\n\nThe problem in the case of atomic queries has been solved by [`Rewriting the Infinite Chase`](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf) by means of rewriting the given set of GTGD rules to Datalog rules. This project tries to extend this result to binary (or possibly, general) conjunctive queries.\n\nSee [[Saturations]] for concepts involved.\n\n## Internal Links\n\n### References\n\n - [[Papers]] (summarises papers that I think will be useful at some point)\n\n### Thoughts\n\nSome random thoughts regarding the project.\n\n - [[2022-11-01 About template constraints]]\n\n### Notes\n\nA collection of more structured notes.\n\n - Definitions:\n\t - Every other notes (should) depend on definitions given in this folder. The definition are organized into a DAG that starts from [[General Notations]].\n - [[Reducing Query-Rule-Rewriting Problem to BCQ Answerings]]\n\n## External Links\n\n - [Project Handbook 2022](https://www.cs.ox.ac.uk/teaching/courses/projects/handbook/Project%20Handbook%202022.pdf)\n\n## Meta Information\n\nContents of this repository is mainly authored on Kondo's machine using [Obsidian](https://obsidian.md), git-managed and then synchronized to a git repository [hosted on GitHub](https://github.com/kory33/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic).\n","lastmodified":"2022-12-15T19:18:20.592205077Z","tags":null},"/notes/Preliminary-Results-on-Saturated-Chase-Like-Trees":{"title":"Preliminary Results on Saturated Chase-Like Trees","content":"\n## General Definitions surrounding $\\SatTree$s\n\n\u003e **Definition.** For chase-like tree $T$ and its vertex $v \\in T_0$, we say that $v$ *mentions* a factual term $t$ if $\\Instance_T(v)$ contains a fact $P(\\vec{t'})$ such that $t \\in \\elems(\\vec{t'})$.\n\n\u003e **Definition.** For a chase-like tree $T$ and a factual term $t$, the _subgraph of $T$ mentioning $t$_, denoted $T \\upharpoonright t$, is the subgraph of $T$ induced by the vertex set $V_t = \\set{v \\in T \\mid v \\text{ mentions } t }$ together with the instance assignment restricted to $V_t$, i.e. $\\Instance_{T \\upharpoonright t} = \\Instance_T \\upharpoonright V_t$ .\n\nWe can see that the subgraph of a $\\SatTree$ mentioning $t$ really is then a subtree sitting in the $\\SatTree$ as seen in the following proposition:\n\n\u003e **Proposition**. For a finite set $\\Sigma$ of GTGDs, a base instance $I$ and any factual term $t$, $\\SatTree_\\Sigma(I) \\upharpoonright t$ is connected. In particular, if $t$ is mentioned in $\\TreeFacts(\\SatTree_\\Sigma(I))$, then $\\SatTree_\\Sigma(I) \\upharpoonright t$ is a rooted subtree of $\\SatTree_\\Sigma(I)$.\n\u003e \n\u003e \u003e _Proof_. By construction of $\\SatTree_\\Sigma(I)$, we have that\n\u003e \u003e - a factual term not already mentioned in $I$ is never introduced by any chase-step direction from any node\n\u003e \u003e - a null introduced at a node $\\vec{d}$ is never introduced anywhere else in the tree\n\nNow, for each factual term $t$ mentioned somewhere in the $\\SatTree$, we can identify where $t$ has been \"introduced\" in the tree:\n\n\u003e **Definition.** For a factual term $t$ mentioned in $\\TreeFacts(\\SatTree_\\Sigma(I))$, the *introduction point $\\Intro(t)$ of $t$* is the root node of the subtree $\\SatTree_\\Sigma(I) \\upharpoonright t$.\n\nClearly, $\\Intro(t)$ is the root node $()$ if and only if $t$ is a constant.\n\n## Fact Introduction Lemma\n\nWe have the following useful lemma:\n\n\u003e **Lemma (Fact Introduction)**. For a node $n$ of $\\SatTree_\\Sigma(I)$, its ancestor node $a$ and a fact $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(n)$, if $\\Intro(t) \\geq a$ for all $t \\in \\elems(\\vec{t})$, then $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(a)$.\n\u003e \n\u003e \u003e _Proof_. TODO (we would probably make a heavy use of this lemma when arguing validity of query reductions)\n\nAn immediate consequence of the lemma is the following:\n\n\u003e **Proposition**. If $P(\\vec{t}) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$ is a base fact, then $P(\\vec{t}) \\in \\Sat_\\Sigma(I)$. ^6bd969\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e By the assumption, $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(n)$ for some node $n \\in \\SatTree_\\Sigma(I)$.\n\u003e \u003e \n\u003e \u003e Now for all $t \\in \\elems(\\vec{t})$, $\\Intro(t)$ is the root node $()$, which is an ancestor of $n$. Therefore by the Fact Introduction lemma $P(\\vec{t}) \\in \\Instance_{\\SatTree_\\Sigma(I)}(()) = \\Sat_\\Sigma(I)$.\n\n## Universality of $\\SatTree$s\n\n\u003e **Fact**. Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance and $Q = \\exists \\vec{z}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ a conjunctive query. Then $$I \\wedge \\Sigma \\models Q \\Longleftrightarrow \\TreeFacts(\\SatTree_\\Sigma(I)) \\text{ witnesses } Q$$","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/notes/Reducing-Query-Rule-Rewriting-Problem-to-BCQ-Answerings":{"title":"Reducing Query-Rule-Rewriting Problem to BCQ Answerings","content":"\n\u003e We shall build on definitions given in [[Chase-Like Trees and Saturated Chase-Like Trees]]. We will also rely on the results in [[Preliminary Results on Saturated Chase-Like Trees]], and [[Witness Fragmentation and Witness Gluing]].\n\n## Preliminaries\n\nWe first make precise the terms that will be useful in describing the algorithm.\n\n\u003e **Definition**. Given a boolean conjunctive query $\\overline{Q} = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ and a subset $V$ of $\\elems(\\vec{x})$,\n\u003e  - the *closure $\\overline{V}$ of $V$ in $\\overline{Q}$* is the set of variables given by $$\n\\overline{V} = \\Set{ x \\in \\elems(\\vec{x})\\ \\biggm\\vert\n\\begin{array}{c}\n  \\text{ there are } j \\in J \\text{ and } x' \\in V \\text{ such that} \\\\\n  \\vec{u_j} \\text{ contains both $x$ and $x'$}\n\\end{array}\n}\n$$\n\u003e  - the *boundary $\\partial V$ of $V$ in $\\overline{Q}$* is the set of variables given by $$\\partial V = \\overline{V} \\setminus V$$\n\u003e  - the *subquery $\\overline{Q}_V$ of $\\overline{Q}$ induced by $V$* is the conjunctive query $$\\exists \\vec{V}. \\bigwedge_{j \\in J_\\overline{V}} A_j(\\vec{u}_j)$$ where\n\u003e \t - $\\vec{V}$ is $V$ ordered into a sequence by the order of appearance in $\\vec{x}$\n\u003e \t - $J_\\overline{V} = \\set{ j \\in J \\mid \\vec{u}_j \\text{ only mentions variables from } \\overline{V}}$\n\u003e \n\u003e \u003e *Remark*. The subquery $\\overline{Q}_V$ of $\\overline{Q}$ induced by $V$ is typically not boolean anymore, since $\\mathrm{FV}(\\overline{Q}_V) = \\partial V$.\n\n## The Basic Rewriting Algorithm\n\nNow consider the following algorithm. Note that we make use of an oracle for BCQ answering over GTGD rules in Step `6-3-1-1`.\n\n\u003e **Definition** Define the procedure $\\mathrm{QueryRuleRewrite1}(\\Sigma, Q)$ as follows:\n\u003e \n\u003e *Input*:\n\u003e   - $\\Sigma$ a finite set of head-normal GTGDs\n\u003e   - $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ a conjunctive query\n\u003e\n\u003e *Algorithm*:\n\u003e  1. Let $\\Sigma_\\mathrm{rew}$ be a Datalog rewriting of $\\Sigma$.\n\u003e  2. Let `mut` $\\Sigma' \\leftarrow \\emptyset$ be a variable holding new full TGD rules\n\u003e  3. Let $\\vec{z} \\leftarrow$ free variables of $Q$, in the order of quantification\n\u003e  4. Let $\\overline{Q} = \\exists \\vec{z}. Q$\n\u003e  5. Let $\\mathcal{H}(\\overline{Q}) = (\\mathcal{V}, \\mathcal{E})$ be the query structure hypergraph of $\\overline{Q}$\n\u003e  6. For each connected sub-hypergraph $C$ of vertices in $\\mathcal{H}(\\overline{Q})$, do:\n\u003e      1. Let $\\partial C$ be the boundary of $C$ in $\\overline{Q}$, and let $\\mathrm{Subgoal_C}$ be a fresh $|\\partial C|$-ary predicate symbol associated with $C$\n\u003e      2. Let $\\overline{Q}_C$ be the subquery of $\\overline{Q}$ induced by $C$\n\u003e      3. For each $\\Sigma$-tentacle ejection template $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$, do:\n\u003e          1. For every possible $T$-closing map $\\sigma: \\partial C \\rightarrow {\\sim}_\\tau$ on $\\overline{Q}_C$ do:\n\u003e              1. If $(T, \\sigma)$ generically $\\Sigma$-proves $\\overline{Q}_C$, then\n\u003e                  1. Let $\\operatorname{remap}: {\\sim_\\tau} \\rightarrow \\Vars$ be any injection from $\\sim_\\tau$ to the set of variables (for instance, a choice function on $\\sim_\\tau$)\n\u003e                  2. Let $\\mathrm{quotient}: (\\bigcup {\\sim_\\tau}) \\rightarrow {\\sim_\\tau}$ be the quotient map sending an element in $\\bigcup {\\sim_\\tau}$ to its equivalence class under $\\sim_\\tau$\n\u003e                  3. Let $\\vec{v}$ be the sequence of variables in $\\operatorname{im} (\\mathrm{remap} \\circ \\mathrm{quotient})$ (in some order)\n\u003e                  4. Add a full TGD rule $$\\forall \\vec{v}. (\\mathrm{remap} \\circ \\mathrm{quotient})(\\beta \\wedge F_\\tau) \\rightarrow (\\mathrm{remap} \\circ \\sigma)(\\mathrm{Subgoal}_C(\\vec{\\partial C}))$$ to $\\Sigma'$\n\u003e  7. Let $\\mathrm{Goal}$ be a fresh $|\\vec{z}|$-ary goal predicate\n\u003e  8. For each subset $V \\supseteq \\elems(\\vec{z})$ of $\\mathcal{V}$, do the following:\n\u003e      1. Let $\\set{C_i}_{i \\in I_V}$ be the set of connected components of $\\mathcal{H}(\\overline{Q}-V)$\n\u003e      2. Let $J_V = \\set{ j \\in J \\mid \\vec{u}_j \\text{ only contains variables from } V}$\n\u003e      3. Add a full TGD rule $$\\forall \\vec{V}. \\left(\\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\\right) \\wedge \\left(\\bigwedge_{i \\in I_V} \\mathrm{Subgoal}_{C_i}(\\partial C_i)\\right) \\rightarrow \\mathrm{Goal}(\\vec{z})$$ to $\\Sigma'$\n\u003e  9. Return $(\\Sigma_\\mathrm{rew} \\cup \\Sigma', \\mathrm{Goal})$\n\nTowards the correctness proof of this algorithm, we prepare the following lemma, which clarifies the semantics of $\\mathrm{Subgoal}$ predicates.\n\n\u003e **Lemma (Subquery-Subgoal Correspondence)**. Let $\\Sigma$ be a finite set of GTDGs, $Q = \\exists \\vec{q}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ a conjunctive query and $I$ a ground instance. \n\u003e \n\u003e Write\n\u003e  - $(\\Sigma_\\mathrm{qrr}, \\mathrm{Goal}^Q) = \\mathrm{QueryRuleRewrite1}(\\Sigma, Q)$,\n\u003e  - $\\vec{z} = \\mathrm{FV}(Q)$ and $\\overline{Q} = \\exists \\vec{z}. Q$, and\n\u003e  - $\\mathcal{H}(\\overline{Q}) = (\\mathcal{V}, \\mathcal{E})$ for the query hypergraph of $\\overline{Q}$.\n\u003e\n\u003e Take any connected sub-hypergraph $C$ of $\\mathcal{H}(\\overline{Q})$.\n\u003e \n\u003e Let $\\overline{Q}_C$ be the subquery of $\\overline{Q}$ induced by $C$, and $\\sigma_{\\partial C}$ be the ground substitution exactly covering $\\partial C$. Then $$\nI \\wedge \\Sigma \\models \\sigma_{\\partial C}(\\overline{Q}_C)\n  \\Longleftrightarrow\n    I \\wedge \\Sigma_\\mathrm{qrr} \\models \\sigma_{\\partial C}(\\mathrm{Subgoal}_C(\\vec{\\partial C})).\n$$\n\u003e \u003e *Proof*. (TODO).\n\nWe will also use the following proposition:\n\n\u003e **Proposition (Boolean Subquery Entailment)**. Let $\\overline{Q} = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ be a boolean conjunctive query and $V \\subseteq \\elems(\\vec{x})$. If $\\sigma$ covers exactly $\\elems(\\vec{x})$, then $$\n\\sigma \\left(\n  \\bigwedge_{j \\in J} A_j(\\vec{u}_j)\n\\right) \\models (\\sigma \\upharpoonright \\partial V)(\\overline{Q}_V)\n$$where $\\partial V$ is the boundary of $V$ in $\\overline{Q}$.\n\u003e\n\u003e \u003e *Proof*. Suppose $\\mathcal{A} \\models \\sigma \\left(\\bigwedge_{j \\in J} A_j(\\vec{u}_j)\\right)$. Then by restricting $\\sigma$ to $\\partial V$ and existentially quantifying all variables in $\\elems(\\vec{x}) \\setminus \\partial V$, we have $$\n\\mathcal{A} \\models\n  \\exists (\\vec{x} \\setminus \\partial V).\n    (\\sigma \\upharpoonright \\partial V) \\left(\n      \\bigwedge_{j \\in J} A_j(\\vec{u}_j)\n    \\right).\n$$Let $J_\\overline{V} = \\set{ j \\in J \\mid \\vec{u}_j \\text{ only mentions variables from } \\overline{V}}$, then by $\\wedge$-elimination, $$\n\\begin{align}\n\\mathcal{A}\n  \u0026\\models\n    \\exists (\\vec{x} \\setminus \\partial V).\n      (\\sigma \\upharpoonright \\partial V) \\left(\n        \\bigwedge_{j \\in J_\\overline{V}} A_j(\\vec{u}_j)\n      \\right) \\\\\n  \u0026\\equiv\n    \\exists \\vec{V}.\n      (\\sigma \\upharpoonright \\partial V) \\left(\n        \\bigwedge_{j \\in J_\\overline{V}} A_j(\\vec{u}_j)\n      \\right) \\\\\n  \u0026= \n    (\\sigma \\upharpoonright \\partial V) \\left(\n      \\exists \\vec{V}.\n        \\bigwedge_{j \\in J_\\overline{V}} A_j(\\vec{u}_j)\n    \\right) \\\\\n  \u0026=\n    (\\sigma \\upharpoonright \\partial V)(\\overline{Q}_V)\n\\end{align}\n$$where the second equivalence is deletion of existential quantification of variables in $(\\elems(\\vec{x}) \\setminus \\partial V) \\setminus V$, as they do not occur freely in the inner formula.\n\n\u003e **Theorem**. $\\mathrm{QueryRuleRewrite1}(\\Sigma, Q)$ is a query-rule-rewriting of $(\\Sigma, Q)$.\n\u003e \n\u003e \u003e *Proof*. Fix $\\Sigma$ and $Q = \\exists \\vec{q}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ and let\n\u003e \u003e  - $(\\Sigma_\\mathrm{qrr}, \\mathrm{Goal}^Q) = \\mathrm{QueryRuleRewrite1}(\\Sigma, Q)$\n\u003e \u003e  - $\\vec{z} = \\mathrm{FV}(Q)$\n\u003e \u003e  - $\\mathcal{H}(\\overline{Q}) = (\\mathcal{V}, \\mathcal{E})$ be the query hypergraph of $\\overline{Q} = \\exists \\vec{z}. Q$\n\u003e \u003e\n\u003e \u003e Take any base instance $I$ and a ground substitution $\\sigma_\\mathrm{sol}$ that covers exactly $\\vec{z}$. We wish to see that $$I \\wedge \\Sigma \\models \\sigma_\\mathrm{sol}(Q) \\Longleftrightarrow I \\wedge \\Sigma_\\mathrm{qrr} \\models \\sigma_\\mathrm{sol}(\\mathrm{Goal^Q}(\\vec{z})) $$holds.\n\u003e \u003e \n\u003e \u003e ($\\Longrightarrow$, the \"completeness\" of the rewrite):\n\u003e \u003e Suppose that $I \\wedge \\Sigma \\models \\sigma_\\mathrm{sol}(Q)$. Then by the universality of $\\SatTree_\\Sigma$, the ground substitution $\\sigma_\\mathrm{sol}$ extends to the factual substitution $\\sigma$ exactly covering $\\vec{z} \\concat \\vec{q}$ such that $\\set{\\sigma(A_j(\\vec{u}_j)) \\mid j \\in J} \\subseteq \\TreeFacts(\\SatTree_\\Sigma(I))$.\n\u003e \u003e \n\u003e \u003e Let $V = \\touchDowners(\\sigma)$ be the touchdowners of $\\sigma$. Since $\\sigma \\supseteq \\sigma_\\mathrm{sol}$, and $\\touchDowners(\\sigma_\\mathrm{sol}) = \\elems(z)$, $V \\supseteq \\elems(\\vec{z})$. Now let $\\set{C_i}_{i \\in I_V}$ be the set of connected components of $\\mathcal{H}(\\overline{Q}-V)$, and let $J_V = \\set{ j \\in J \\mid \\vec{u}_j \\text{ only contains variables from } V}$. By the base-fact completeness of Datalog saturations, it suffices see that the rule $$\\forall \\vec{V}. \\left(\\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\\right) \\wedge \\left(\\bigwedge_{i \\in I_V} \\mathrm{Subgoal}_{C_i}(\\partial C_i)\\right) \\rightarrow \\mathrm{Goal}^Q(\\vec{z})$$is applicable to $\\FullSat_{\\Sigma_\\mathrm{qrr}}(I)$ with the ground substitution $\\sigma \\upharpoonright V$.\n\u003e \u003e \n\u003e \u003e For each $j \\in J_V$, $\\vec{u}_j$ only contains variables from $V$, so $\\sigma(A_j(\\vec{u}_j)))$ is a ground fact. Since $\\sigma(A_j(\\vec{u}_j))) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$ and $\\Sigma_\\mathrm{qrr}$ contains a Datalog rewriting of $\\Sigma$, we have $\\sigma(A_j(\\vec{u}_j))) \\in \\TreeFacts(\\SatTree_{\\Sigma_\\mathrm{qrr}}(I))$. As $\\sigma(A_j(\\vec{u}_j)))$ is a ground fact, $\\sigma(A_j(\\vec{u}_j))) \\in \\FullSat_{\\Sigma_\\mathrm{qrr}}(I)$.\n\u003e \u003e \n\u003e \u003e Take $i \\in I_V$. It remains to see that $\\sigma(\\mathrm{Subgoal}_{C_i}(\\partial C_i)) \\in \\FullSat_{\\Sigma_\\mathrm{qrr}}(I)$. Since $$\nI \\wedge \\Sigma\n  \\models\n    \\sigma \\left(\n      \\bigwedge_{j \\in J} A_j(\\vec{u}_j)\n    \\right),\n$$by the Boolean Subquery Entailment, $I \\wedge \\Sigma \\models (\\sigma \\upharpoonright \\partial C)(\\overline{Q}_C)$. Now by the Subquery-Subgoal Correspondence Lemma, $$\nI \\wedge \\Sigma_\\mathrm{qrr} \\models (\\sigma \\upharpoonright \\partial C)(\\mathrm{Subgoal}_C(\\vec{\\partial C})).\n$$Since $\\sigma(\\mathrm{Subgoal}_{C_i}(\\partial C_i)) = (\\sigma \\upharpoonright \\partial C)(\\mathrm{Subgoal}_{C_i}(\\partial C_i))$ is a ground fact, we conclude that $\\sigma(\\mathrm{Subgoal}_{C_i}(\\partial C_i)) \\in \\FullSat_{\\Sigma_\\mathrm{qrr}}(I)$.\n\u003e \u003e \n\u003e \u003e ($\\Longleftarrow$, the \"soundness\" of the rewrite):\n\u003e \u003e Suppose $I \\wedge \\Sigma_\\mathrm{qrr} \\models \\sigma_\\mathrm{sol}(\\mathrm{Goal^Q}(\\vec{z}))$. By construction of $\\Sigma_\\mathrm{qrr}$, there must be some subset $V \\supseteq \\elems(\\vec{z})$ of $\\mathcal{V}$ such that if we write\n\u003e \u003e  - $\\set{C_i}_{i \\in I_V}$ for the set of connected components of $\\mathcal{H}(\\overline{Q}-V)$, and\n\u003e \u003e  - $J_V$ for the set $\\set{ j \\in J \\mid \\vec{u}_j \\text{ only contains variables from } V}$,\n\u003e \u003e \n\u003e \u003e then the ground substitution $\\sigma_\\mathrm{sol}$ can be extended to a ground substitution $\\sigma_V$ that exactly covers $\\vec{V}$ such that $$\n\\sigma_V \\left(\n  \\set{A_j(\\vec{u}_j) \\mid j \\in J_V} \\cup \\set{\\mathrm{Subgoal}_{C_i}(\\partial C_i) \\mid i \\in I_V}\n\\right) \\subseteq \\FullSat_{\\Sigma_\\mathrm{qrr}}(I)\n$$holds, so that the base fact $\\sigma_\\mathrm{sol}(\\mathrm{Goal^Q}(\\vec{z}))$ is $\\Sigma_\\mathrm{qrr}$-derived through the rule $$\\forall \\vec{V}. \\left(\\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\\right) \\wedge \\left(\\bigwedge_{i \\in I_V} \\mathrm{Subgoal}_{C_i}(\\partial C_i)\\right) \\rightarrow \\mathrm{Goal}^Q(\\vec{z}).$$together with $\\sigma_V$.\n\u003e \u003e \n\u003e \u003e Now for each $i \\in I_V$, $\\sigma_V \\upharpoonright (\\partial C_i)$ is a ground substitution exactly covering $\\partial C_i$, so by the Subquery-Subgoal Correspondence Lemma, $I \\wedge \\Sigma \\models (\\sigma_V \\upharpoonright (\\partial C_i))(\\overline{Q}_{C_i}) = \\sigma_V(\\overline{Q}_{C_i})$.\n\u003e \u003e \n\u003e \u003e Also for each $j \\in J_V$, $I \\wedge \\Sigma_\\mathrm{qrr} \\models \\sigma_V(A_j(\\vec{u}_j))$, but since $\\Sigma_\\mathrm{qrr}$ proves no new instance of existing predicates (i.e. predicates that are not $\\mathrm{Subgoal}$s and $\\mathrm{Goal}^Q$), $I \\wedge \\Sigma \\models \\sigma_V(A_j(\\vec{u}_j))$.\n\u003e \u003e \n\u003e \u003e Therefore, we have $$\n\\begin{align}\nI \\wedge \\Sigma\n  \u0026\\models \\left(\n    \\bigwedge_{j \\in J_V} \\sigma_V(A_j(\\vec{u}_j))\n  \\right) \\wedge \\left(\n    \\bigwedge_{i \\in I_V}\\sigma_V(\\overline{Q}_{C_i})\n  \\right).\n\\end{align}\n$$Now $$\n\\begin{align}\n  \\left(\n    \\bigwedge_{j \\in J_V} \\sigma_V(A_j(\\vec{u}_j))\n  \\right) \u0026\\wedge \\left(\n    \\bigwedge_{i \\in I_V}\\sigma_V(\\overline{Q}_{C_i})\n  \\right) \\\\\n    \u0026= \\sigma_V \\left(\n      \\left(\n        \\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\n      \\right) \\wedge \\left(\n        \\bigwedge_{i \\in I_V} \\overline{Q}_{C_i}\n      \\right)\n    \\right) \\\\\n    \u0026= \\sigma_V \\left(\n      \\left(\n        \\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\n      \\right) \\wedge \\left(\n        \\bigwedge_{i \\in I_V}\n          \\exists \\vec{C_i}. \\bigwedge_{j \\in J_\\overline{C_i}} A_j(\\vec{u}_j)\n      \\right)\n    \\right) \\\\\n    \u0026\\equiv \\sigma_V \\left(\n      \\left(\n        \\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\n      \\right) \\wedge \\left(\n        \\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}.\n        \\bigwedge_{i \\in I_V}\n          \\bigwedge_{j \\in J_\\overline{C_i}} A_j(\\vec{u}_j)\n      \\right)\n    \\right) \\\\\n    \u0026\\equiv \\sigma_V \\left(\n      \\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}.\n      \\left(\n        \\bigwedge_{j \\in J_V} A_j(\\vec{u}_j)\n      \\right) \\wedge \\left(\n        \\bigwedge_{i \\in I_V}\n          \\bigwedge_{j \\in J_\\overline{C_i}} A_j(\\vec{u}_j)\n      \\right)\n    \\right) \\\\\n    \u0026\\equiv \\sigma_V \\left(\n      \\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}.\n      \\bigwedge_{j \\in J} A_j(\\vec{u}_j)\n    \\right)\n\\end{align}\n$$where $J_\\overline{C_i} = \\set{ j \\in J \\mid \\vec{u}_j \\text{ only mentions variables from } \\overline{C_i}}$, and the last equivalence is justified by the fact that $J_V \\cup \\bigcup \\set{J_\\overline{C_i} \\mid i \\in I_V} = J$ (which is straightforward to check) and by the $\\wedge$-commutativity. Therefore $$I \\wedge \\Sigma\n  \\models \\sigma_V \\left(\n      \\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}.\n      \\bigwedge_{j \\in J} A_j(\\vec{u}_j)\n    \\right).\n  $$Now, restricting $\\sigma_V$ to $\\elems(\\vec{z})$ yields $\\sigma_\\mathrm{sol}$, and existentially quantifying all variables in $V \\setminus \\elems(\\vec{z})$ from the formula $\\exists \\vec{C_{i_1}}, \\ldots ,\\vec{C_{i_{|I_V|}}}. \\bigwedge_{j \\in J} A_j(\\vec{u}_j)$ yields the original query $Q$, since $\\set{\\elems(C_i) \\mid i \\in I_V}$ is a disjoint cover of $(\\elems(\\vec{q} \\concat \\vec{z})) \\setminus V$.\n\u003e \u003e\n\u003e \u003e We therefore conclude that $I \\wedge \\Sigma \\models \\sigma_\\mathrm{sol}(Q)$.\n","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/notes/Tentacle-Ejection-Templates":{"title":"Tentacle Ejection Templates","content":"\n## Preliminaries\n\n### In-place unifications\n\nWe shall first define what it means to identify (in-place) variables in a GTGD rule.\n\n\u003e **Definition**. Let $\\vec{x}$ be a set of variables. An *in-place unification on $\\vec{x}$* is a partition $\\sim_\\vec{x}$ of $\\elems(\\vec{x})$.\n\u003e \n\u003e \u003e **Example**. If $\\vec{x} = (x_0, x_1, x_2, x_3)$, then an equivalence relation given by a partition $\\set{\\set{x_0}, \\set{x_1, x_3}, \\set{x_2}}$ is an in-place unification on $\\vec{x}$.\n\n## Tentacle Ejection Templates\n\nWe first describe an object that abstractly describe a situation where a tentacle hangs from some saturation of some base instance:\n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs and $\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma$. A *$(\\tau, \\Sigma)$-export template* is a set $F$ of atomic formulae such that each $A \\in F$\n\u003e   1. only mentions constants from $\\Sigma$, and\n\u003e   2. only mentions variables in $\\elems(\\vec{x})$ that appear in some atom in $\\eta$.\n\u003e\n\u003e \u003e *Example*. Let $\\tau = \\forall x_1, x_2. R_1(x_1, x_2) \\wedge U(x_1) \\wedge P(c_0) \\rightarrow \\exists y. H(x_2, y, c_1)$ and $\\Sigma = \\set{\\tau}$. Then the following are all $(\\tau, \\Sigma)$-export templates:\n\u003e \u003e   - $\\set{R_1(x_2, c_1), R_1(x_2, x_2)}$\n\u003e \u003e   - $\\set{R_1(c_0, c_1), U(x_2)}$\n\u003e \u003e   - $\\set{H(x_2, x_2, x_2), P(x_2)}$\n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs. A *$\\Sigma$-tentacle ejection template* is a triple $(\\tau, \\sim_\\tau, F_\\tau)$ where $\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma$, $\\sim_\\tau$ is an in-place unification on $\\vec{x}$ and $F_\\tau$ is a $(\\tau, \\Sigma)$-export template.\n\nNext, we define what is means to \"instantiate\" $\\Sigma$-tentacle ejection templates.\n\n\u003e **Definition**. Let $\\vec{x}$ be a set of variables and $\\sim_\\vec{x}$ an in-place unification on $\\vec{x}$. A factual substitution $\\sigma: \\Vars \\rightharpoonup \\Consts$ is said to *conform to $\\sim_\\vec{x}$* if $\\sigma$ covers exactly $\\vec{x}$ and for each $x_1, x_2 \\in \\elems(\\vec{x})$, and $$\\sigma(x_1) = \\sigma(x_2) \\Longleftrightarrow x_1 \\sim_\\vec{x} x_2.$$ In other words, $\\sigma$ covering exactly $\\vec{x}$ conforms to $\\sim_\\vec{x}$ if and only if $\\mathrm{ker}(\\sigma) = \\sim_\\vec{x}$ where $\\mathrm{ker}(\\sigma)$ is the set-theoretic kernel of $\\sigma$.\n\u003e\n\u003e \u003e *Example*. If $\\vec{x} = (x_0, x_1, x_2, x_3)$ and $\\elems(\\vec{x}) / \\sim_\\vec{x} = \\set{\\set{x_0}, \\set{x_1, x_3}, \\set{x_2}}$ as in the previous example, then a substitution $\\sigma$ given by $$\n\\begin{array}{c c}\n  \\sigma: \u0026\\Vars \u0026\\rightharpoonup \u0026\\Consts \\\\\n          \u0026x_0 \u0026\\mapsto \u0026c_3 \\\\\n          \u0026x_1 \u0026\\mapsto \u0026c_6 \\\\\n          \u0026x_2 \u0026\\mapsto \u0026c_2 \\\\\n          \u0026x_3 \u0026\\mapsto \u0026c_6 \\\\\n\\end{array}\n$$ conforms to $\\sim_\\vec{x}$.\n\n\u003e **Definition** Let $\\Sigma$ be a finite set of GTGDs, and $T = (\\tau = \\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template. Given a ground substitution $\\sigma_{F_\\tau}$ that conforms to $\\sim_\\tau$, the *$\\Sigma$-instantiation $\\Tentacle_\\Sigma(T, \\sigma)$ of $T$ fired with $\\sigma$* is defined as the subtree of $\\SatTree_\\Sigma(\\sigma(F_\\tau \\cup \\beta))$ induced by the set of nodes in $\\SatTree_\\Sigma(\\sigma(F_\\tau \\cup \\beta))$ that either\n\u003e   1. is the root node, or\n\u003e   2. corresponds to a valid generative $\\Sigma$-chase-path on $\\sigma(F_\\tau)$ and starts with $(\\tau, \\sigma)$.\n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance, $T = (\\tau = \\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta, \\sim_\\tau, F_\\tau)$ a $\\Sigma$-tentacle ejection template and $\\sigma$ a factual substitution conforming to $\\sim_\\tau$. We say that *$T$ can be $\\Sigma$-instantiated on $I$ using $\\sigma$* if $\\sigma(F_\\tau \\cup \\beta) \\subseteq \\FullSat_\\Sigma(I)$.\n\nAn instantiation of a $\\Sigma$-tentacle ejection template on an instance embeds into the $\\SatTree$ of the instance, in the following sense:\n\n\u003e **Proposition (Ejection Embedding)**.\n\u003e Let $\\Sigma$ be a finite set of GTGDs, $I$ a base instance and $T = (\\tau, \\sim_\\tau, F_\\tau)$ a $\\Sigma$-tentacle ejection template that can be instantiated on $I$ using $\\sigma$. Then for each node $\\vec{d}$ in $\\Tentacle_\\Sigma(T, \\sigma)$,\n\u003e  1. $\\vec{d}$ is a valid generative $\\Sigma$-chase-path on $I$, i.e. is a node in $\\SatTree_\\Sigma(I)$, and moreover,\n\u003e  2. $\\Instance_{\\Tentacle_\\Sigma(T, \\sigma)}(\\vec{d}) \\subseteq \\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$\n\u003e \n\u003e \u003e *Proof*. Since $\\Tentacle_\\Sigma(T, \\sigma)$ is a subtree of $\\SatTree_\\Sigma(\\sigma(F_\\tau \\cup \\beta))$, the proposition is obvious from the SatTree monotonicity.\n\n### Tentacle Abstraction\n\nWe have just seen that the instantiation of a tentacle $(\\tau, \\sim_\\tau, F_\\tau)$ with a substitution $\\sigma$ is a way of turning a tentacle ejection template into a chase-like tree that can be actually embeded to a tentacle hanging from $(\\tau, \\sigma)$.\n\nWe now describe a way to \"abstract\" an actual tentacle to a tentacle ejection template that can be instantiated back exactly to the original tentacle.\n\n\u003e **Definition**. Let $(\\tau, \\sigma)$ be a valid generative $\\Sigma$-chase-path on $I$. We say that a $\\Sigma$-tentacle ejection template $T = (\\tau_T, \\sim_T, F_T)$ is an *abstraction of $(\\tau, \\sigma)$ over $I$* if\n\u003e   - $\\tau_T = \\tau$\n\u003e   - $\\sigma$ conforms to $\\sim_T$\n\u003e   - $\\sigma(F_T) = \\exports_\\Sigma(I, (\\tau, \\sigma))$\n\nThe next proposition shows that we can always abstract a valid generative $\\Sigma$-chase-path on a base instance.\n\n\u003e **Proposition (existence of abstraction)**. Let $(\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta), \\sigma)$ be a valid generative $\\Sigma$-chase-path on a base instance $I$. Then there exists an abstraction of $(\\tau, \\sigma)$ over $I$.\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e Let $E = \\exports_\\Sigma(I, (\\tau, \\sigma))$, $D = (\\operatorname{im} \\sigma \\cap \\consts(E)) \\setminus \\consts(\\Sigma)$ and $V \\subseteq \\elems(\\vec{x})$ be variables in $\\vec{x}$ that appear in some atom in $\\eta$ (these are the *exported variables of $\\tau$*).\n\u003e \u003e \n\u003e \u003e We first claim the following:\n\u003e \u003e \n\u003e \u003e \u003e **Claim 1**. $\\sigma \\upharpoonright V: V \\rightarrow D$ is a surjection onto $D$. In particular, there exists a right-inverse $\\sigma^{-1}: D \\rightarrow V$ of $\\sigma \\upharpoonright V$, so that $\\sigma \\circ \\sigma^{-1} = \\mathrm{id}_D$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e *Proof*. Take any constant $c \\in D$. Then $c$ occurs in $E$, so $c$ is $\\Sigma$-guarded by some fact $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](G(\\vec{t}))$ in $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta)$ (where $\\nu$ is some null-picking function). As $c \\in D$, $c$ does not occur in $\\Sigma$, hence the fact $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](G(\\vec{t}))$ must contain $c$. Moreover, as $c$ does not occur in $\\Sigma$, $G(\\vec{t})$ does not contain $c$, so $\\sigma$ must introduce $c$ to the fact $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](G(\\vec{t}))$. Hence there is variable $x$ occuring in $G(\\vec{t})$ such that $\\sigma(x) = c$, and we are done since $x \\in V$.\n\u003e \u003e \n\u003e \u003e Let $\\sigma^{-1}: D \\rightarrow V$ be the right-inverse of $\\sigma \\upharpoonright V$ constructed in Claim 1, and now let $F = \\sigma^{-1}(E)$ (assume that every constant not in $D$ is sent as-is by $\\sigma^{-1}$). Then by construction $\\sigma(F) = E$.\n\u003e \u003e \n\u003e \u003e Next, we make the following useful claim:\n\u003e \u003e \n\u003e \u003e \u003e **Claim 2**. For each atomic formula $A \\in F$, $(\\sigma^{-1} \\circ \\sigma)(A) = A$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e *Proof*. By construction of $F$, $A = \\sigma^{-1}(B)$ for some fact $B \\in E$. But since $\\sigma^{-1}$ is a right-inverse of $\\sigma \\upharpoonright V$, $$\n\\begin{align}\n(\\sigma^{-1} \\circ \\sigma)(A)\n  \u0026= (\\sigma^{-1} \\circ \\sigma \\circ \\sigma^{-1})(B) \\\\\n  \u0026= (\\sigma^{-1} \\circ (\\sigma \\upharpoonright V) \\circ \\sigma^{-1})(B) \\\\\n  \u0026= \\sigma^{-1}(B) \\\\\n  \u0026= A\n\\end{align}\n$$\n\u003e \u003e \n\u003e \u003e We now claim that $F$ is a $(\\tau, \\Sigma)$-export template. Since every atom $A$ in $F$ can be written as $A = \\sigma^{-1}(R(\\vec{c}))$ for some fact $R(\\vec{c}) \\in E$, we need to check that for each $R(\\vec{c}) \\in E$, the atom $\\sigma^{-1}(R(\\vec{c})) \\in F$\n\u003e \u003e   - *(only mentions constants from $\\Sigma$)*: Take a constant $a$ in $\\sigma^{-1}(R(\\vec{c}))$. Assume for contradiction that $a$ does not appear in $\\Sigma$.\n\u003e \u003e     \n\u003e \u003e     We must have $a \\not \\in D$; if $a \\in D$, then by Claim 2 the atom $\\sigma^{-1}(R(\\vec{c})) = (\\sigma^{-1} \\circ \\sigma \\circ \\sigma^{-1})(R(\\vec{c}))$ would not contain $a$, since the outer $\\sigma^{-1}$ would send $\\sigma(a) = a \\in D$ to a variable, contradicting the choice of $a$.\n\u003e \u003e     \n\u003e \u003e     Since $a \\not \\in D = (\\operatorname{im} \\sigma \\cap \\consts(E)) \\setminus \\consts(\\Sigma)$ while $a \\not \\in \\consts(\\Sigma)$, we must have either $a \\not \\in \\operatorname{im} \\sigma$ or $a \\not \\in \\consts(E)$. It is impossible that $a \\not \\in \\consts(E)$, since $F$ is obtained by replacing a constants in $E$ by variables. Hence $a \\not \\in \\operatorname{im} \\sigma$.\n\u003e \u003e     \n\u003e \u003e     As $R(\\vec{c}) \\in E$, $R(\\vec{c}) = \\sigma(\\sigma^{-1}(R(\\vec{c})))$ is $\\Sigma$-guarded by some fact in $\\chaseHead_\\nu(\\tau, \\sigma) = \\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta)$. In particular, $a = \\sigma(a)$ appears either in $\\Sigma$ or in some atom of $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta)$.\n\u003e \u003e     \n\u003e \u003e     If $a$ appears in some atom of $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta)$, then $a$ must appear in $\\eta$, since $a \\not \\in \\operatorname{im} \\sigma$. In any case $a$ appears in $\\Sigma$, hence a contradiction.\n\u003e \u003e\n\u003e \u003e   - *(only mentions variables from $\\elems(\\vec{x})$ that appear in some atom in $\\eta$)*: This is obvious from the construction of $F$, since $\\sigma^{-1}: D \\rightarrow V$.\n\u003e \u003e \n\u003e \u003e We now have that $(\\tau, \\operatorname{ker} \\sigma, F)$ is an abstraction of $(\\tau, \\sigma)$.\n\nAs expected, instantiation of an abstraction of chase-step direction $(\\tau, \\sigma)$ equals the tentacle hanging from $(\\tau, \\sigma)$, as formulated in the following lemma.\n\n\u003e **Lemma (abstraction-instantiation)**. Let $(\\tau, \\sigma)$ be a valid generative $\\Sigma$-chase-path on $I$, and $T = (\\tau, \\sim, F)$ be an abstraction of $(\\tau, \\sigma)$ over $I$.\n\u003e \n\u003e Then for all nonempty valid generative $\\Sigma$-chase-path $\\vec{d}$ on $I$, if $\\vec{d}$ starts with $(\\tau, \\sigma)$, then $\\Instance_{\\Tentacle_\\Sigma(T, \\sigma)}(\\vec{d}) = \\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$.\n\u003e \n\u003e \u003e *Proof*. Let $\\tau = \\forall \\vec{x}. \\beta \\rightarrow \\exists \\vec{y}. \\eta$. We proceed by induction on $\\vec{d}$. \n\u003e \u003e \n\u003e \u003e (base case $\\vec{d} = ((\\tau, \\sigma))$): We first make the following claim: \n\u003e \u003e \n\u003e \u003e \u003e **Claim**. $$\\exports_\\Sigma(I, (\\tau, \\sigma)) = \\exports_\\Sigma(\\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta), (\\tau, \\sigma))$$\n\u003e \u003e \u003e *Proof*.\n\u003e \u003e \u003e ($\\subseteq$): Take any $F \\in \\exports_\\Sigma(I, (\\tau, \\sigma))$. Then $F$ is guarded by $\\chaseHead_\\nu(\\tau, \\sigma)$, and $F \\in \\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta)$ so $F \\in \\exports_\\Sigma(\\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta), (\\tau, \\sigma))$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e ($\\supseteq$): Follows from the fact that $I \\supseteq \\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta)$.\n\u003e \u003e\n\u003e \u003e Now $$\n\\begin{align}\n\\Instance_{\\SatTree_{\\Sigma(I)}}(\\vec{d})\n  \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{SC}_{\\Sigma, ()}(I), (\\tau, \\sigma))) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(I, (\\tau, \\sigma))) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chaseHead_{\\widehat{\\#_{\\vec{d}}}}(\\tau, \\sigma) \\cup \\exports_\\Sigma(I, (\\tau, \\sigma))) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chaseHead_{\\widehat{\\#_{\\vec{d}}}}(\\tau, \\sigma) \\cup \\exports_\\Sigma(\\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta), (\\tau, \\sigma)) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\exports_\\Sigma(I, (\\tau, \\sigma)) \\cup \\sigma(\\beta), (\\tau, \\sigma))) \\\\\n  \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\sigma(F \\cup \\beta), (\\tau, \\sigma))) \\\\\n  \u0026= \\Instance_{\\SatTree_\\Sigma(\\sigma(F \\cup \\beta))}(\\vec{d}) \\\\\n  \u0026= \\Instance_{\\Tentacle_\\Sigma(T, \\sigma)}(\\vec{d})\n\\end{align}\n$$so we are done.\n\u003e \u003e\n\u003e \u003e (inductive part): Obvious.\n\n\n## Generic Proofs\n\nThroughout this section, whenever we take a generic $\\Sigma$-tentacle ejection template $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$ and a (not necessarily boolean) conjunctive query $Q = \\exists \\vec{z}. \\bigwedge_{i \\in I} A_i(\\vec{w_i})$, by renaming bound variables we shall assume that $\\vec{x}, \\vec{y}$, $\\vec{z}$ and $\\operatorname{FV}(Q)$ are all disjoint to each other.\n\n\u003e **Definition**. For a set $\\Sigma$ of finite GTGDs, a *$\\Sigma$-generic constant assignment* is a computable function $\\GenConst_\\Sigma: \\mathcal{P}_\\mathrm{fin}(\\Vars) \\rightarrow \\Consts$ such that $\\mathrm{im}(\\GenConst) \\cap \\consts(\\Sigma) = \\emptyset$.\n\nFrom now on, we shall assume that, for each $\\Sigma$, we have decided a choice on a $\\Sigma$-generic constant assignment $\\GenConst_\\Sigma$. We shall refer to this particular function as *the* $\\Sigma$-generic constant assignment.\n\n\u003e **Definition**. Let $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template. The *generic instance $\\GenInst_\\Sigma(T)$ associated with $T$* is the instance $$\n\\GenInst_\\Sigma(T) :=\n  (\\GenConst_\\Sigma \\circ \\mathrm{quotient})(F_\\tau \\cup \\beta)\n$$ where $\\mathrm{quotient}: \\elems(\\vec{x}) \\rightarrow {\\sim_\\tau}$ is the quotient map $x \\mapsto [x]_{\\sim_\\tau}$.\n\n\u003e **Definition**. Let $T = (\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template, and let $Q$ be a (*not necessarily boolean*) conjunctive query.  A *$T$-closing map on $Q$* is a map $\\sigma: \\operatorname{FV}(Q) \\rightarrow {\\sim}_\\tau$.\n\n\u003e **Definition**. Let $T = (\\tau, \\sim_\\tau, F_\\tau)$ be a $\\Sigma$-tentacle ejection template, $Q = \\exists \\vec{z}. \\bigwedge_{i \\in I} A_i(\\vec{w_i})$ a conjunctive query and $\\sigma: \\mathrm{FV}(Q) \\rightarrow {\\sim_\\tau}$ a $T$-closing map on $Q$. The *$T$-generic closure of $Q$ by $\\sigma$* is a boolean conjunctive query $\\mathrm{cl}_\\sigma(Q)$ given by $$\\mathrm{cl}_\\sigma(Q) = \\exists \\vec{z}. \\bigwedge_{i \\in I} A_i((\\GenConst_\\Sigma \\circ \\sigma)(\\vec{w_i}))$$\n\n\u003e **Definition**. Let $T$ be a $\\Sigma$-tentacle ejection template, $Q$ a conjunctive query and $\\sigma_Q: \\mathrm{FV}(Q) \\rightarrow {\\sim_\\tau}$ a $T$-closing map on $Q$. We say that $(T, \\sigma_Q)$ *generically proves* $Q$ when $\\GenInst_\\Sigma(T) \\wedge \\Sigma \\models \\mathrm{cl}_\\sigma(Q)$.\n\n(TODO: We probably need the following two results in order to prove the correctness of the rewrite algorithm:\n 1. If there is a generic proof of a subquery, then the instantiation of the template induces an actual witness on $\\SatTree$ of the subquery\n 2. If there is a witness of the subquery in a tentacle, then the abstraction of the tentacle, together with the induced $T$-expectation (we should make this precise), generically proves the subquery.\n)\n","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/notes/Witness-Fragmentation-and-Witness-Gluing":{"title":"Witness Fragmentation and Witness Gluing","content":"\n\u003e This note depends on [[Preliminary Results on Saturated Chase-Like Trees]].\n\nThis note explores the relationship between ordinary witnesses and \"fragmented witnesses\", which will be defined in the following sections. First, we begin with some preliminary definitions.\n\n\u003e **Definition**. For a boolean conjunctive query $Q$ and its witness $(\\sigma, \\mathcal{F})$, the *set of touchdowners* $\\touchDowners(\\sigma)$ of $\\sigma$ is the set $\\sigma^{-1}[\\consts(\\mathcal{F})]$ of variables that get sent to constants in $\\mathcal{F}$.\n\u003e \n\u003e **Examples**: ![[Pasted image 20221116200624.png]]![[Pasted image 20221116200657.png]] \n\n\u003e **Definition**. For a valid generative chase-path $((\\tau, \\sigma))$ on $I$, we define the *tentacle of $\\SatTree_\\Sigma(I)$ hanging from $(\\tau, \\sigma)$* to be the subtree of $\\SatTree_\\Sigma(I)$ induced by all descendants of the node $((\\tau, \\sigma))$. We call $(\\tau, \\sigma)$ the *wrist* of the tentacle that hangs from $(\\tau, \\sigma)$.\n\n\u003e **Definition**. For a binary conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_i Q_i(\\vec{x'}_i)$, the *query structure hypergraph $\\mathcal{H}(Q)$* of $Q$ is the labelled hypergraph defined with\n\u003e  - the vertex set $V_Q = \\elems(\\vec{x})$\n\u003e  - for each $i$, a hyperedge named $Q_i$ that spans $\\elems(\\vec{x'}_i) \\subseteq V_Q$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_i Q_i(\\vec{x'}_i)$ and a subset $X$ of $\\elems(\\vec{x})$, the *$X$-masked query structure hypergraph*, denoted $\\mathcal{H}(Q-X)$, is the hypergraph obtained by weak-deleting [^1] all vertices in $X$.\n\n## Witness Gluing\n\nWe can \"glue\" small witnesses together to form a $(\\Sigma, I)$-witness for a query. To make this precise, we start with some definitions.\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ is *a base-factual substitution* if $\\operatorname{im} \\sigma \\subseteq \\Consts$, and that it is a *null-factual substitution* if $\\operatorname{im} \\sigma \\subseteq \\Nulls$.\n\n\u003e **Definition**. Given a finite set $\\Sigma$ of GTGDs, a base instance $I$ and a boolean conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, a *Q-fragmented substitution* is a pair $(\\sigma_b, \\set{ \\sigma'_V }_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b))})$ such that\n\u003e  - $\\sigma_b$ is a base-factual substitution such that $\\domain(\\sigma_b) \\subseteq \\elems(\\vec{x})$\n\u003e  - for each $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$, $\\sigma'_V$ is a null-factual substitution with $\\domain(\\sigma'_V) = V$.\n\u003e\n\u003e \u003e *Notational convention*. We will often omit the indexing set of the family $\\set{\\sigma'_V}_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b))}$ and simply write it as $\\set{\\sigma'_V}_V$.\n\n\u003e **Remark**. By construction, a $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$ is a *collection of compatible factual substitutions*, in a sense that $\\sigma_b \\not\\in \\set{\\sigma'_V}_V$, and for each pair $\\sigma_1, \\sigma_2$ of factual substitutions in the set $\\set{ \\sigma_b } \\cup \\set{ \\sigma'_V }_V$, $\\domain(\\sigma_1) \\cup \\domain(\\sigma_2) \\neq \\emptyset \\Longrightarrow \\sigma_1 = \\sigma_2$.\n\n\u003e **Definition**. By the previous remark, for a $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$, the set-theoretic union $\\bigcup(\\set{ \\sigma_b } \\cup \\set{ \\sigma'_V }_V)$ is a well-defined factual substitution. We shall call this union the *gluing of $(\\sigma_b, \\set{\\sigma'_V}_V)$*, and denote it by $\\Glue_Q(\\sigma_b, \\set{\\sigma'_V}_V)$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, a $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_V)$ is said to be a *$Q$-fragmented $(\\Sigma, I)$-witness for $Q$* if\n\u003e  - for each $Q_j(\\vec{x'}_j)$ in $Q$ such that $\\elems(\\vec{x'}_j) \\subseteq \\domain(\\sigma_b)$, the fact $Q_j(\\sigma_b(\\vec{x'}_j))$ is an element of $\\Sat_\\Sigma(I)$, which is the instance assigned to the root of $\\SatTree_\\Sigma(I)$\n\u003e  - for each connected component $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$ and each predicate $Q_j(\\vec{x'}_j)$ corresponding to an edge $Q_j$ contained in $V$, the fact $Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j))$ is an element of $\\TreeFacts(\\SatTree_\\Sigma(I))$.\n\nThen almost by definition we obtain the following lemma:\n\n\u003e **Lemma (Witness Gluing)**. Suppose $(\\sigma_b, \\set{\\sigma'_V}_V)$ is a $Q$-fragmented $(\\Sigma, I)$-witness for $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$. Then $(\\Glue_Q(\\sigma_b, \\set{\\sigma'_V}_V), \\SatTree_\\Sigma(I))$ is a witness for $Q$.\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e Write $\\sigma$ for the factual substitution $\\Glue_Q(\\sigma_b, \\set{\\sigma'_V}_V)$. Clearly $\\sigma$ exactly covers $\\vec{x}$.\n\u003e \u003e \n\u003e \u003e Now pick $j \\in J$. We need to see that $Q_j(\\sigma(\\vec{x'}_j))$ is an element of $\\TreeFacts(\\SatTree_\\Sigma(I))$.\n\u003e \u003e \n\u003e \u003e If the edge $Q_j$ does not span any vertex in $\\mathcal{H}(Q - \\domain(\\sigma_b))$, then $Q_j$ does not mention any variable *not in* $\\domain(\\sigma_b)$. Hence $\\elems(\\vec{x'}_j) \\subseteq \\domain(\\sigma_b)$, so by the assumption on $(\\sigma_b, \\set{\\sigma'_V}_V)$, the fact $Q_j(\\sigma_b(\\vec{x'}_j))$ appears in $\\Sat_\\Sigma(I)$, hence in $\\TreeFacts(\\SatTree_\\Sigma(I))$.\n\u003e \u003e \n\u003e \u003e So suppose that $Q_j$ does span a vertex $x$ in $\\mathcal{H}(Q - \\domain(\\sigma_b))$. Then $x$ belongs to some connected component $V$ of $\\mathcal{H}(Q - \\domain(\\sigma_b))$, and by definition of being a connected component $Q_j$ spans vertices in $V$. So by assumption on $(\\sigma_b, \\set{\\sigma'_V}_V)$, $Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j))$ is an element of $\\TreeFacts(\\SatTree_\\Sigma(I))$. As $\\sigma \\supseteq \\sigma_V \\circ \\sigma_b$, $Q_j(\\sigma(\\vec{x'}_j)) = Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j)) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$.\n\n## Fragmentation and Gluing\n\nIn this section, we shall see that fragmented witnesses and witnesses are in a bijective relation via the gluging operation and its inverse operation, which we shall call \"fragmentation\".\n\nWe begin with the definition of the fragmentation operator $\\Frag_Q$.\n\n\u003e **Definition**. For a BCQ $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$ and a factual substitution $\\sigma$ covering $\\vec{x}$, define the *fragmentation $\\Frag_Q(\\sigma)$ of $\\sigma$* as the $Q$-fragmented substitution $(\\sigma_b, \\set{\\sigma'_V}_{V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))})$, where\n\u003e  - $\\sigma_b$ is a restriction of $\\sigma$ to $\\touchDowners(\\sigma)$\n\u003e  - for each $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$, $\\sigma'_V: V \\rightarrow \\Facts$ is a restriction of $\\sigma$ to $V$\n\nThen the following holds:\n\n\u003e **Lemma (Witness Fragmentation)**. If $\\sigma$ is a $(\\Sigma, I)$-witness for a BCQ $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} Q_j(\\vec{x'}_j)$, then $\\Frag_Q(\\sigma)$ is a $Q$-fragmented $(\\Sigma, I)$-witness for $Q$.\n\u003e \n\u003e \u003e *Proof*.\n\u003e \u003e Let $(\\sigma_b, \\set{\\sigma'_V}_V) = \\Frag_Q(\\sigma)$. We check that this is in fact a $Q$-fragmented $(\\Sigma, I)$-witness for $Q$ according to the definition of $Q$-fragmented witnesses.\n\u003e \u003e \n\u003e \u003e To check the first condition, take $j \\in J$ such that $\\elems(\\vec{x'}_j) \\subseteq \\domain(\\sigma_b)$. Then since $Q_j(\\sigma(\\vec{x'}_j)) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$, by a consequence of Fact Introduction lemma, $Q_j(\\sigma(\\vec{x'}_j)) \\in \\Sat_\\Sigma(I)$.\n\u003e \u003e \n\u003e \u003e To check the second condition, take $V \\in \\ConnComp(\\mathcal{H}(Q - \\domain(\\sigma_b)))$ and $j \\in J$ such that $Q_j$ lies entirely in $V$. Now $(\\sigma_V \\circ \\sigma_b)(x) = \\sigma(x)$ for each $x \\in V \\cup \\domain(\\sigma_b)$ by construction of $\\sigma_V$ and $\\sigma_b$, and as $\\vec{x'}_j$ only contains variables from $V \\cup \\domain(\\sigma_b)$, $Q_j((\\sigma_V \\circ \\sigma_b)(\\vec{x'}_j)) = Q_j(\\sigma(\\vec{x'}_j)) \\in \\TreeFacts(\\SatTree_\\Sigma(I))$.\n\nAs a corollary, we have the following propositions:\n\n\u003e **Proposition**. $\\Frag_Q$ defines a assignment of $Q$-fragmented $(\\Sigma, I)$-witnesses for $Q$ on the set of $(\\Sigma, I)$-witnesses for $Q$\n\n\u003e **Theorem (Fragmentation-Gluing Bijection)**. For a BCQ $Q$, $\\Frag_Q$ and $\\Glue_Q$ are mutual bijections between $(\\Sigma, I)$-witnesses for $Q$ and $Q$-fragmented $(\\Sigma, I)$-witnesses for $Q$.\n\u003e \n\u003e \u003e *Proof*. We only need to check that the two maps are mutual inverses. But this is the case by definition: $\\Frag_Q \\circ \\Glue_Q$ essentially unions fragmented substitutions and then restricts them to respective domains, while $\\Glue_Q \\circ \\Frag_Q$ unions all restricted substitutions, recovering the original substitution.\n\n\n[^1]: see Ch. 7, [[Books#^327283]] for details","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/notes/definitions/Chase-Like-Trees-and-Saturated-Chase-Like-Trees":{"title":"Chase-Like Trees and Saturated Chase-Like Trees","content":"\n\u003e This note builds on [[Saturations]]\n\nWe shall define a tree structure that \"stems from a base instance $I$ and witnesses every possible conclusion that can be $\\Sigma$-deduced from $I$\". To make this idea precise, we define a few concepts.\n\n## Some generic definitions \n\n\u003e **Definition**. Let $\\Sigma$ be a finite set of GTGDs. We say that _a set $G$ of factual terms is $\\Sigma$-guarded by a set of factual terms $\\vec{t}$_ when $G \\subseteq \\consts(\\Sigma) \\cup \\vec{t}$ .\n\n\u003e **Definition**. Injective functions of the form $\\nu: \\mathbb{N} \\rightarrow \\Nulls$ will be referred to as *null-picking functions*.\n\n\u003e **Definition**. For a null-picking function $\\nu$, a vector $\\vec{y} = (y_1, \\ldots, y_n)$ of variables and a factual substitution $\\sigma$ whose domain is disjoint from $\\vec{y}$, we define *the factual substitution $\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls]$* with domain $\\domain(\\sigma) + \\elems(\\vec{y})$ that substitutes each $y_i$ to distinct nulls (chosen by $\\nu$) and follows $\\sigma$ elsewhere: $$\n\\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](x)=\n\\begin{cases}\n    n_{\\nu(i)} \u0026 \\text{if $x = y_i$} \\\\\n    \\sigma(x) \u0026 \\text{if $x \\in \\domain(\\sigma)$}\n\\end{cases}$$\n\n\u003e **Definition**. For a TGD $\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$, an instance $I$ and a factual substitution $\\sigma$ that covers $\\vec{x}$, we say that *$I$ can be $\\tau$-chased with $\\sigma$* when $\\sigma(\\beta) \\subseteq I$.\n\nIntuitively, this means that the premise $\\beta$ is witnessed by some facts in $I$, and $\\sigma$ specifies which constant or null appearing in $I$ is witnessing each variable in $\\vec{x}$.\n\nWe shall describe how an instance can be \"extended\" by applying a GTGD.\n\n\u003e **Definition**. Given a null-picking function $\\nu$, a finite set $\\Sigma$ of GTGDs, an element $\\tau = \\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta) \\in \\Sigma$ and an instance $I$ that can be $\\tau$-chased with a factual substitution $\\sigma$, we define:\n\u003e  - *the $(\\tau, \\sigma)$-chase head $\\chaseHead_\\nu(\\tau, \\sigma)$ (through $\\nu$)* to be the set $$\\chaseHead_\\nu(\\tau, \\sigma) := \\sigma[\\vec{y} \\xrightarrow{\\nu} \\Nulls](\\eta).$$ of facts. \n\u003e    Intuitively, this is a set of new facts generated from $I$ by applying the rule $\\tau$ with $\\sigma$.\n\u003e  - *the $\\Sigma$-exports $\\exports_\\Sigma(I, (\\tau, \\sigma))$ from $I$ along $(\\tau, \\sigma)$* to be the set $$\\exports_\\Sigma(I, (\\tau, \\sigma)) := \\set{\\ F \\in I\\ |\\ F \\text{ is } \\Sigma \\text{-guarded by }\\chaseHead_\\nu(\\tau, \\sigma) \\ }.$$\n\u003e  - *the one-step $\\Sigma$-chase $\\chase_{\\Sigma, \\nu}(I, (\\tau, \\sigma))$ of $I$ with $(\\tau, \\sigma)$ (through $\\nu$)* to be an instance defined by  $$\\chase_{\\Sigma, \\nu}(I, (\\tau, \\sigma)) := \\chaseHead_\\nu(\\tau, \\sigma) \\cup \\exports_\\Sigma(I, (\\tau, \\sigma)).$$\n\n### Chase-Like Trees\n\n\u003e **Definition**. A *chase-like tree $T$* is a directed rooted tree $(T_0, v_r)$ together with the *instance assignment* $\\operatorname{Instance}_T: V(T_0) \\rightarrow \\Instances$ of instances to vertices.\n\n\u003e **Definition**. For a chase-like tree $T$ with the instance assignment $\\operatorname{Instance}_T$, we define the instance $\\TreeFacts(T)$ as the union $\\bigcup \\mathrm{im} \\operatorname{Instance}_T$ of images of the instance assignment.\n\n### The Canonical Global Null-Picking Function\n\n\u003e **Definition**. We write $\\ChaseStepDir$ for the set $\\GTGDFormulae \\times \\FactualSubstitutions$, and call a pair $(\\tau, \\sigma) \\in \\ChaseStepDir$ a *generic chase-step direction*. We call a finite (resp. infinite) sequence of generic chase-step directions a *finite (resp. infinite) generic chase-path*.\n\n\u003e**Definition**. We fix a coding function (hence a computable injection into $\\mathbb{N}$) $$\\#: \\ChaseStepDir^{\u003c \\omega} \\times \\mathbb{N} \\rightarrow \\mathbb{N}$$ on pairs of a finite generic chase-path and a natural.\n\nBy precomposing $\\#$ to the canonical null-picking function $\\nu_{\\mathrm{id}}(i \\in \\mathbb{N}) = n_i$ and currying, we obtain a $\\ChaseStepDir^{\u003c \\omega}$-indexed family $\\set{ \\widehat{\\#_\\vec{d}}}_{\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}}$ of null-picking functions. More explicitly, we have the following:\n\n\u003e**Definition**. For each $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, we define *the canonical null-picking function $\\widehat{\\#_{\\vec{d}}}$ at $\\vec{d}$* to be the function $$\n\\begin{align}\n\\widehat{\\#_{\\vec{d}}} : \\mathbb{N} \u0026 \\rightarrow \\Nulls\\\\\n                                   i \u0026 \\mapsto n_{\\#(\\vec{d}, i)}\n\\end{align}\n$$\n\nThis family of null-picking functions will be used in the following definition to formally ensure that no null introduced in one branch is brought to its sibling branches.\n\n## Saturated Chase-Like Trees\n\nThroughout this section, we shall fix some finite set $\\Sigma$ of head-normal GTGDs.\n\nFrom now on, we would like to work with specialized chase-step directions:\n\n\u003e **Definition**. We write $\\ChaseStepDir_\\Sigma$ for the set $\\Sigma \\times \\FactualSubstitutions$, and call a pair $(\\tau, \\sigma) \\in \\Sigma \\times \\FactualSubstitutions$ a *$\\Sigma$-chase-step direction*. We call a finite (resp. infinite) sequence of $\\Sigma$-chase-step directions a *finite (resp. infinite) $\\Sigma$-chase-path*.\n\n\u003e **Definition**. We say that a $\\Sigma$-chase-step direction $(\\tau, \\sigma)$ is *generative* if $\\tau$ is a non-full rule, and that a $\\Sigma$-chase-path $\\vec{d}$ is *generative* if each $(\\tau, \\sigma) \\in \\elems(\\vec{d})$ is generative.\n\n\u003e **Definition**. Given a base instance $I$, define, by induction on finite chase-paths $\\vec{d} \\in \\ChaseStepDir^{\u003c \\omega}$, the *shortcut $\\Sigma$-chase $\\operatorname{SC}_{\\Sigma, \\vec{d}}(I)$ of $I$ along $\\vec{d}$* by $$\n\\begin{align}\n  \\operatorname{SC}_{\\Sigma, ()}(I) \u0026= \\FullSat_\\Sigma(I) \\\\\n  \\operatorname{SC}_{\\Sigma, \\vec{d} \\concat (\\tau, \\sigma)}(I) \u0026=\n    \\begin{cases}\n      \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\operatorname{SC}_{\\Sigma, \\vec{d}}(I), (\\tau, \\sigma))) \u0026 \\text{if $\\operatorname{SC}_{\\Sigma, \\vec{d}}(I)$ can be $\\tau$-chased with $\\sigma$} \\\\\n      \\emptyset \u0026 \\text{otherwise}\n    \\end{cases}\n\\end{align}\n$$\n\n\u003e **Definition**. For a base instance $I$ and a finite chase-path $\\vec{d}$, we say that $\\vec{d}$ is *a valid $\\Sigma$-chase-path on $I$* if either $\\operatorname{SC}_{\\Sigma, \\vec{d}}(I) \\neq \\emptyset$ or both $I$ and $\\vec{d}$ are empty.\n\n\u003e **Definition**. The *$\\Sigma$-saturated chase-like tree $\\SatTree_\\Sigma(I)$ of a base instance $I$* is a chase-like tree with:\n\u003e  - the set $(\\ChaseStepDir^{\u003c \\omega})_{\\Sigma\\mathrm{, valid, gen}}$ of *all* valid generative $\\Sigma$-chase-paths on $I$ as the vertex set\n\u003e  - (labelled) edges of the form $\\vec{p} \\xrightarrow{d} \\vec{p} \\concat (d)$ for each pair of vertices (hence valid , generative $\\Sigma$-chase-paths) $\\vec{p}$ and $\\vec{p} \\concat (d)$\n\u003e  - the instance assignment function defined by $$\n\\begin{array}{c c}\n\\operatorname{Instance}_{\\SatTree_\\Sigma(I)}:\n  \u0026(\\ChaseStepDir^{\u003c \\omega})_{\\Sigma\\mathrm{, valid, gen}} \u0026 \\longrightarrow \u0026\\Instances \\\\\n  \u0026\\vec{d} \u0026\\longmapsto \u0026\\operatorname{SC}_{\\Sigma, \\vec{d}}(I)\n\\end{array}\n$$\n\n\u003e **Proposition (SatTree monotonicity)**. If $\\Sigma$ is a finite set of GTGDs and $I \\subseteq I'$ are base instances, then for each node $\\vec{d}$ in $\\SatTree_\\Sigma(I)$,\n\u003e   1. $\\vec{d}$ is also a node in $\\SatTree_\\Sigma(I')$, and moreover,\n\u003e   2. $\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d}) \\subseteq \\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d})$.\n\u003e\n\u003e \u003e *Proof*. We show both of (1) and (2) simultaneously by induction on $\\vec{d}$.\n\u003e \u003e \n\u003e \u003e (Base case):\n\u003e \u003e   1. Obvious.\n\u003e \u003e   2. By saturation monotonicity.\n\u003e \u003e (Inductive part):\n\u003e \u003e  Let $\\vec{d} \\concat (\\tau, \\sigma)$ be a node in $\\SatTree_\\Sigma(I)$, hence a valid generative $\\Sigma$-chase-path on $I$. Then $\\vec{d}$ is a node in $\\SatTree_\\Sigma(I)$, so by inductive hypothesis, $\\vec{d}$ is a valid generative $\\Sigma$-chase-path on $I'$, and $\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d}) \\subseteq \\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d}))$. Then we have:\n\u003e \u003e    1. Since $\\vec{d} \\concat (\\tau, \\sigma)$ is a valid $\\Sigma$-chase-path on $I$, by definition of $\\Instance_{\\SatTree_\\Sigma(I)}$, $\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$ can be $\\tau$-chased with $\\sigma$. So $\\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d}) \\supseteq \\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d})$ can also be $\\tau$-chased with $\\sigma$, and $\\vec{d} \\concat (\\tau, \\sigma)$ is a valid $\\Sigma$-chase-path on $I'$ as well. Moreover,\n\u003e \u003e    2. as $\\chase$ is clearly monotonic in its first argument, we have $$\n\\begin{align}\n\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d} \\concat (\\tau, \\sigma))\n \u0026= \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\Instance_{\\SatTree_\\Sigma(I)}(\\vec{d}), (\\tau, \\sigma))) \\\\\n \u0026\\subseteq \\FullSat_\\Sigma(\\chase_{\\widehat{\\#_{\\vec{d}}}}(\\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d}), (\\tau, \\sigma))) \\\\\n \u0026= \\Instance_{\\SatTree_\\Sigma(I')}(\\vec{d} \\concat (\\tau, \\sigma)).\n\\end{align}\n$$\n\nWe will often deal with witnesses of the form $(\\sigma, \\TreeFacts(\\SatTree_\\Sigma(I)))$. This motivates a distinguished name for such witnesses:\n\n\u003e **Definition**. For a BCQ $Q$, we say that a factual substitution $\\sigma$ is *a $(\\Sigma, I)$-witness for $Q$* when $(\\sigma, \\TreeFacts(\\SatTree_\\Sigma(I)))$ is a witness for $Q$.\n\n","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/notes/definitions/General-Notations":{"title":"General Notations","content":"\n\u003e This section defines general notations used throughout the notes.\n\nFor a formal finite sequence $(X_1, \\ldots, X_n)$ of same sorts, we abbriviate it as $\\vec{X}$. The set $\\set{\\ X_1, \\ldots, X_n\\ }$ will then be denoted as $\\elems(\\vec{X})$. We write $\\vec{X'} \\triangleleft \\vec{X}$ to mean that $\\vec{X'}$ is an initial segment of $\\vec{X}$, $\\vec{X'} \\leq \\vec{X}$ to mean that $\\vec{X'}$ is a subsequence of $\\vec{X}$ and $X' \\subseteq X$ to mean $\\elems(\\vec{X'}) \\subseteq \\elems(\\vec{X})$.\n\nFor two formal finite sequences $\\vec{X}$ and $\\vec{Y}$, we denote by $\\vec{X} \\concat \\vec{Y}$ the concatenation of $\\vec{X}$ and $\\vec{Y}$. For a nonempty (possibly infinite) sequence $(x) \\concat \\vec{X}$, we write $\\head((x) \\concat \\vec{X})$ to mean the first element $x$ of the sequence.\n\nA pair $(T, v_r)$ of a directed acyclic graph $T$ and a vertex $v_r \\in V(T)$ is called a *directed tree rooted at $v_r$* if the underlying undirected graph of $T$ is a tree and every $v \\in V(T) \\setminus \\set{v_r}$ has precisely one vertex $p_v \\in V(T)$ such that there is an edge $(p_v, v) \\in E(T)$. We shall often call $T$ a *rooted tree*.\n\nFor a directed tree $T$, we say that a node $u$ is a _descendant_ of $v$, written $u \u003c v$, when there is a (directed) path from $v$ to $u$.\n\nFor a hypergraph $\\mathcal{H} = (V, \\mathcal{E})$, we write $\\ConnComp(\\mathcal{H})$ for the set of connected components (i.e. the quotient of $V$ under the smallest equivalence relation $\\sim$ containing $x_1 \\sim x_2$ for each $x_1, x_2$ such that there is a hyperedge $E \\in \\mathcal{E}$ that spans both $x_1$ and $x_2$).\n\nWe write $f: A \\rightharpoonup B$ to mean that $f$ is a partial function from $A$ to $B$. We denote by $\\domain(f)$ to mean the domain of $f$, and write $\\isDefinedAt{f}{x}$ to mean that $x \\in \\domain(f) \\subseteq A$, i.e. $f$ is defined at $x \\in A$.","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/notes/definitions/Logic-Preliminaries":{"title":"Logic Preliminaries","content":"\n\u003e This note builds on [[General Notations]].\n\nThis note mainly pulls definitions from [Rewriting the Infinite Chase](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf), but with quite a lot of modifications.\n\nWe assume the countably infinite collection $\\Vars = \\set{x_0, x_1, \\ldots}$ of variables, the ordered set $\\Nulls = \\set{\\ n_i \\mid i \\in \\mathbb{N}\\ }$ of *labelled nulls*, some given fixed (at most countable) set $\\Consts = \\set{c_0, c_1, \\ldots}$ of constants. We also assume an infinite collection $\\Predicates = \\set{P_0, P_1, \\ldots}$ of predicate symbols, such that there is an associated *arity-function* $\\Arity: \\Predicates \\rightarrow \\mathbb{N}$ such that the preimage $\\Arity^{-1}[\\set{n}]$ of $n \\in \\mathbb{N}$ is always infinite.\n\nWe say that a tuple $\\mathcal{L} = (\\Vars_\\mathcal{L}, \\Nulls_\\mathcal{L}, \\Consts_\\mathcal{L}, \\Predicates_\\mathcal{L})$ where $\\Vars_\\mathcal{L} \\subseteq \\Vars$ and so on, is a *first-order language*. For a first order language $\\mathcal{L} = (\\Vars_\\mathcal{L}, \\Nulls_\\mathcal{L}, \\Consts_\\mathcal{L}, \\Predicates_\\mathcal{L})$, we define:\n - *the set $\\Terms_\\mathcal{L}$ of (non-null) terms* as $\\Vars_\\mathcal{L} \\cup \\Consts_\\mathcal{L}$\n - *the set $\\NullableTerms_\\mathcal{L}$ of nullable terms* as $\\Vars_\\mathcal{L} \\cup \\Consts_\\mathcal{L} \\cup \\Nulls_\\mathcal{L}$\n - _the set $\\FactualTerms_\\mathcal{L}$ of factual terms_ as $\\Nulls_\\mathcal{L} \\cup \\Consts_\\mathcal{L}$\n - _the set $\\Atoms_\\mathcal{L}$ of atomic formulae (resp. the set $\\Facts_\\mathcal{L}$ of facts)_ to be a set of formal expression $P(t_1, t_2, \\ldots, t_{\\Arity(P)})$ with $P \\in \\Predicates_\\mathcal{L}$, $t_i \\in \\Terms_\\mathcal{L}$ (resp. $\\FactualTerms_\\mathcal{L}$) for each $1 \\leq i \\leq \\Arity(P)$\n - *the set $\\Formulae_\\mathcal{L}$ of (first-order) formulas under the signature $(\\Predicates_\\mathcal{L}, \\Consts_\\mathcal{L})$* to be a set of formal expressions inductively built up from $\\Atoms_\\mathcal{L}$ using unary connective $\\neg$, binary connectives $\\wedge, \\vee, \\rightarrow$ and quantifiers $\\exists x.$ and $\\forall x.$ (where $x \\in \\Vars_\\mathcal{L}$)\n\nFor most of the following definitions, we will assume some fixed first-order language $\\mathcal{L}$ and omit the subscript $_\\mathcal{L}$ unless it becomes necessary to specify the language. \n\n\u003e **Notational remark**. By an abuse of notation, we may omit the subscript $_\\mathcal{L}$ to denote the \"unconstraint version\" of the inductive construction. For example, by $\\Atoms$ we may simply mean the set of formal expressions of the form $P(t_1, \\ldots, t_{\\Arity(P)})$ where $P \\in \\Predicates$ and $t_i \\in \\Terms = \\Vars \\cup \\Consts$ for each $1 \\leq i \\leq \\Arity(P)$.\n\nSemantics (interpretation, logical-consequence relation and truth) of formulae is defined using the standard terminology. We also follow standard conventions concerning variables being *bound* and *free*.\n\n\u003e *Remark*. We are allowing $0$-ary predicate symbols. Therefore, *an interpretation* must assign a truth value from the set $\\set{\\perp, \\top}$ to each of the given $0$-ary predicates.\n\nFor brevity, we adopt the following notational conventions:\n  - for a an atomic formula $P(t_1, \\ldots, t_{\\Arity(P)})$, we simply write it as $P(\\vec{t})$ with an intention that $\\vec{t} = (t_1, \\ldots, t_{\\Arity(P)})$.\n  - for a formula of a form $\\exists x_1. \\exists x_2. \\ldots \\exists x_n. \\phi$, we simply write it as $\\exists \\vec{x}. \\phi$ with an intention that $\\vec{x} = (x_1, \\ldots, x_n)$.\n\nFor conjunctions $F = \\bigwedge_{1 \\leq i \\leq n} F_i$ and $G = \\bigwedge_{1 \\leq j \\leq m} G_j$ of formulae, we write $F \\subseteq G$ when for each $1 \\leq i \\leq n$, $F_i$ appears in $G$. That is, for each $1 \\leq i \\leq n$, there exists $1 \\leq j \\leq m$ with $F_i = G_j$.\n\nWe now define subclasses of objects defined above:\n  - a fact $P(\\vec{t})$ is *a base fact* if $\\vec{t}$ contains only constants (hence no nulls). We write $\\BaseFacts$ for the set of base facts.\n  - *an instance* is a finite set of facts. We write $\\Instances$ for the set $\\mathcal{P}_{\u003c \\omega}(\\Facts)$.\n  - an instance $I$ is *a base instance* if each fact in $I$ is a base fact.\n  - a formula is *a rectified formula* if no variable is bound twice, and no variable occurs both bound and free. By a standard renaming argument, any first-order formula is equivalent to a rectified formula. Hence from now on we will assume all formulae to be rectified.\n  - a formula is closed when every occurence of variable is bound.\n  - a closed formula is a *Tuple-Generating Dependency (or TGD)* if it is of the form $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ where $\\beta$ and $\\eta$ are conjunctions of atoms with $\\eta$ nonempty. In such a formula, $\\beta$ is referred to as the *body* and $\\eta$ is referred to as the *head* of this TGD.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is *a full TGD* if $\\vec{y}$ is empty, i.e. it is of the form $\\forall \\vec{x}. \\beta \\rightarrow \\eta$.\n  - a full TGD is *a Datalog rule* if its head contains exactly one atom. A finite set of Datalog rules is is called *a Datalog program*.\n  - a TGD is in a head-normal form if it is either a *Datalog rule*, or each atom in the head contains at least one existentially quantified variable.\n  - a TGD $\\forall \\vec{x}. (\\beta \\rightarrow \\exists \\vec{y}. \\eta)$ is a *guarded-TGD (or GTGD)* if $\\beta$ contains an atom $P(\\vec{t})$ such that $\\vec{t} \\supseteq \\vec{x}$. We write $\\GTGDFormulae_\\mathcal{L}$ for the set of $\\mathcal{L}$-formulae that are GTGDs.\n  - a Conjunctive Query (CQ) is a formula of the form $\\exists \\vec{x}. \\bigwedge_i A_i$ where each $A_i$ is an atomic formula.\n\nWe say that a Datalog program $\\Sigma_\\rew$ is a *Datalog rewriting* of a finite collection $\\Sigma$ of GTGDs when for every base instance $I$ and a base fact $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_\\rew \\models F.$$\n\n## Notions of Substitutions\n\n### Factual subtitutions\n\n\u003e **Definition**. A *factual substitution* is a partial function $\\sigma: \\Vars \\rightharpoonup \\FactualTerms$ with a finite domain.\n\nA factual substitution canonically extends to a partial function $\\Atoms \\rightharpoonup \\Facts$ that is defined on atoms all of whose variables are in the domain of $\\sigma$. We identity this extension of $\\sigma$ with $\\sigma$ by an abuse of notation.\n\n\u003e **Definition**. We write $\\FactualSubstitutions = (\\Vars \\rightharpoonup \\FactualTerms)_{\u003c \\omega}$ for the countable set of all factual substitutions.\n\n\u003e **Definition**. A *ground substitution* is a factual substitution whose range is contained in $\\Consts$.\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ *covers* a set $\\vec{y}$ of variables when $\\elems(\\vec{y}) \\subseteq \\domain(\\sigma)$, and say that $\\sigma$ *exactly covers $\\vec{y}$* if $\\elems(\\vec{y}) = \\domain(\\sigma)$.\n\n#### BCQ Witnesses\n\n\u003e **Definition**. We say that a factual substitution $\\sigma$ together with a (potentially infinite) set $\\mathcal{F}$ of facts *witness a boolean conjunctive query $\\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$* if $\\sigma$ exactly covers $\\vec{x}$ and $$\\set{\\ \\sigma(A_i) \\mid 1 \\leq i \\leq n \\ } \\subseteq \\mathcal{F}.$$\n\n### Consts translations\n\n\u003e **Definition**. A *consts translation* is a function $\\sigma: \\Consts \\rightarrow \\Consts$.\n\nA consts translation $\\sigma$ then canonically extends to a function $\\tilde{\\sigma}: \\Facts \\rightarrow \\Facts$ that applies $\\sigma$ to each constant appearing in a fact (without modifying nulls). Then $\\tilde{\\sigma}$ further extends to a function $\\tilde{\\tilde{\\sigma}}: \\Instance \\rightarrow \\Instance$ that applies $\\tilde{\\sigma}$ to each fact in an instance. By an abuse of notation we shall identify all of $\\sigma, \\tilde{\\sigma}$ and $\\tilde{\\tilde{\\sigma}}$.\n","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/notes/definitions/Rewritings":{"title":"Rewritings","content":"\n\u003e This note builds on [[Logic Preliminaries]].\n\n## Conjunctive Query Answering\n\nThrough the language of substitutions, we define what it means to *answer* a conjunctive query.\n\n\u003e **Definition**. Given a set $\\Sigma$ of TGDs, a base instance $I$ and a rectified conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j(\\vec{y'}_j)$, an *answer to $Q$ on $I$ under $\\Sigma$* is a ground substitution $\\sigma$ covering exactly $\\mathrm{FV}(Q)$ such that $I \\wedge \\Sigma \\models \\sigma(Q)$. The set of all ansers to $Q$ on $I$ under $\\Sigma$ is denoted by $\\QueryAnswers(Q, I; \\Sigma)$.\n\n## Rule-Rewritings\n\n\u003e **Definition**. Given a set $\\Sigma$ of TGDs, a Datalog program $\\Sigma_{\\text{rew}}$ is *a rule-rewriting of $\\Sigma$* if, for every base instance $I$, $\\Sigma$ and $\\Sigma_{\\text{rew}}$ generate the same set of **base facts**, i.e. for every base fact $F$, $$I \\wedge \\Sigma \\models F \\Longleftrightarrow I \\wedge \\Sigma_{\\text{rew}} \\models F.$$\n\n\u003e **Fact**. If $\\Sigma$ is a finite set of GTGDs, then there exists a rule-rewriting of $\\Sigma$, and moreover it can be computed.\n\u003e \n\u003e \u003e *Proof*: See [[Papers#^a74196]], where three different competitive algorithms for computing rule-rewriting of GTGDs are presented.\n\n## Query-Rule-Rewritings\n\n\u003e **Definition**. Let $\\Sigma$ be a set of TGDs and $Q = \\exists \\vec{x}. \\bigwedge_{j \\in J} A_j(\\vec{y'}_j)$ a conjunctive query. Let $\\vec{z}$ be the sequence of free variables in $Q$. \n\u003e \n\u003e We say that a pair of a Datalog program $\\Sigma^Q_\\rew$ (with a suitably extended set of predicates) together with a (possibly fresh) *$|\\vec{z}|$-ary goal predicate* $\\mathrm{Goal^Q}(\\underbrace{-, \\ldots, -}_{|\\vec{z}|\\text{ arguments}})$ is a *query-rule-rewriting of $(\\Sigma, Q)$* if, for every base instance $I$, $$\\QueryAnswers(Q, I; \\Sigma) = \\QueryAnswers(\\mathrm{Goal}^Q(\\vec{z}), I; \\Sigma^Q_\\mathrm{rew}).$$ holds.\n\u003e \n\u003e \u003e *Remark*. This is equivalent to saying that, for all base instance $I$ and every ground substitution $\\sigma$ that exactly covers $\\elems(\\vec{z})$, $$I \\wedge \\Sigma \\models \\sigma(Q) \\Longleftrightarrow I \\wedge \\Sigma^Q_\\rew \\models \\sigma(\\mathrm{Goal^Q}(\\vec{z})) $$ holds.\n","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/notes/definitions/Saturations":{"title":"Saturations","content":"\n\u003e This note builds on [[Rewritings]]\n\nGiven an instance $I$ and a finite set $\\Sigma$ of Datalog rules, we can form *the smallest superinstance of $I$ satisfying $\\Sigma$*, which we shall call $\\Sat_\\Sigma(I)$. To make this precise, we begin with the following definition.\n\n## Datalog Saturations\n\n\u003e **Definition**. Given a Datalog program $\\Sigma$ and an instance $I$, we define the *$k$-th partial Datalog-saturation $\\Sat^k_\\Sigma(I)$ of $I$ by $\\Sigma$* by induction on $k \\in \\mathbb{N}$, by $$\\begin{align}\n  \\Sat^0_\\Sigma(I) \u0026= I \\\\\n  \\Sat^{k + 1}_\\Sigma(I) \u0026= \\Sat^k_\\Sigma(I) \\cup \\set{\\ \\sigma(\\eta) \\mid (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma, \\sigma \\text{ covers } \\vec{x}, \\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)\\ }\n\\end{align}$$\n\nHere are some basic properties of $\\Sat^k_\\Sigma(-)$.\n\n\u003e **Proposition**. If $I \\subseteq I'$ are instances and $\\Sigma$ is a finite set of GTGDs, then for each $k \\in \\mathbb{N}$, $\\Sat^k_\\Sigma(I) \\subseteq \\Sat^k_\\Sigma(I')$.\n\u003e \n\u003e \u003e *Proof*. By a simple induction on $k$.\n\n\u003e **Proposition**. Let $\\Sigma$ be a Datalog program and $I$ an instance. Then for each $k \\in \\mathbb{N}$ and for all base fact $F$, if $F \\in \\Sat_\\Sigma^k(I)$ then $I \\wedge \\Sigma \\vdash F$  (by $\\vdash$ we simply mean \"provable in natural deduction\"). ^7faefd\n\u003e \n\u003e \u003e *Proof*. By induction on $k$.\n\u003e \u003e \n\u003e \u003e The base case is obvious, since if $F \\in \\Sat^0_\\Sigma(I) = I$, $I \\vdash F$ and therefore $I \\wedge \\Sigma \\vdash F$. \n\u003e \u003e \n\u003e \u003e For the inductive part, suppose $F \\in \\Sat^{k+1}_\\Sigma(I)$. If $F \\in \\Sat^k_\\Sigma(I)$ then we are done by the inductive hypothesis. Otherwise, there must be some $(\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma$ and a factual substitution $\\sigma$ covering $\\vec{x}$ such that $\\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)$, and $F = \\sigma(\\eta)$. By inductive hypothesis, each atom $F \\in \\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)$ can be derived from $I \\wedge \\Sigma$, hence $I \\wedge \\Sigma \\vdash \\sigma(\\beta)$. Since $\\sigma(\\beta) \\rightarrow \\sigma(\\eta)$ can be deduced from $\\Sigma$ in one step, by modus ponens $I \\wedge \\Sigma \\vdash \\sigma(\\eta)$.\n\nNow, we define the desired instance.\n\n\u003e **Definition**. The *Datalog saturation $\\Sat_\\Sigma(I)$ of $I$ by a Datalog program $\\Sigma$* is defined as the instance $$\\Sat_\\Sigma(I) = \\bigcup_{k \\in \\mathbb{N}} \\Sat^k_\\Sigma(I).$$\n\n\u003e **Proposition (Saturation monotonicity)**. If $I \\subseteq I'$ are instances and $\\Sigma$ is a finite set of GTGDs, then $\\Sat_\\Sigma(I) \\subseteq \\Sat_\\Sigma(I')$.\n\u003e \n\u003e \u003e *Proof*. By monotonicity of $\\Sat^k_\\Sigma(-)$ for each $k \\in \\mathbb{N}$.\n\nOur requirement that the $\\Sat_\\Sigma(I)$ is \"*the smallest superinstance of $I$ satisfying $\\Sigma$*\" is captured in the following theorem.\n\n\u003e **Theorem (Base-fact completeness of Datalog saturations)**.\n\u003e Let $I$ be a base instance, $F$ a base fact and $\\Sigma$ be a Datalog program. Then $$F \\in \\Sat_\\Sigma(I) \\Longleftrightarrow I \\wedge \\Sigma \\models F.$$\n\u003e ^b7f0b5\n\u003e \u003e *Proof*.\n\u003e \u003e ($\\Longrightarrow$): By [[#^7faefd]] and soundness of natural deduction, $$\n\\begin{align}\nF \\in \\Sat_\\Sigma(I)\n  \u0026\\Longrightarrow F \\in \\Sat_\\Sigma^k(I) \\text{ for some } k \\in \\mathbb{N} \\\\\n  \u0026\\Longrightarrow I \\wedge \\Sigma \\vdash F \\\\\n  \u0026\\Longrightarrow I \\wedge \\Sigma \\models F \\\\\n\\end{align}$$\n\u003e \u003e ($\\Longleftarrow$):\n\u003e \u003e Let $\\mathcal{M}$ be a model that makes precisely the facts in $\\Sat_\\Sigma(I)$ true. We then have $\\mathcal{M} \\models I$, since $\\Sat_\\Sigma(I) \\supseteq \\Sat^0_\\Sigma(I) = I$.\n\u003e \u003e \n\u003e \u003e \u003e **Claim**. $\\mathcal{M} \\models \\Sigma$.\n\u003e \u003e \u003e *Proof of the claim*. Take any $\\tau = (\\forall \\vec{x}. \\beta \\rightarrow \\eta) \\in \\Sigma$. We show that $\\mathcal{M} \\models \\tau$.\n\u003e \u003e \u003e \n\u003e \u003e \u003e So take any factual substitution $\\sigma$ such that $\\mathcal{M} \\models \\sigma(\\beta)$. By construction of $\\mathcal{M}$, $\\sigma(\\beta) \\subseteq \\Sat_\\Sigma(I)$. Since $\\sigma(\\beta)$ is finite, $\\sigma(\\beta) \\subseteq \\Sat^k_\\Sigma(I)$ for some $k \\in \\mathbb{N}$. But then by definition of $\\Sat^{k+1}_\\Sigma(I)$, $\\sigma(\\eta) \\in \\Sat^{k+1}_\\Sigma(I) \\subseteq \\Sat_\\Sigma(I)$, so $\\mathcal{M} \\models \\sigma(\\eta)$.\n\u003e \u003e\n\u003e \u003e Therefore $\\mathcal{M} \\models I \\wedge \\Sigma$ and by assumption $\\mathcal{M} \\models F$. But then by construction of $\\mathcal{M}$, $F \\in \\Sat_\\Sigma(I)$.\n\n## Full Saturations\n\nThe previous section talked about saturating an instance using a finite set of *Datalog* rules.\n\nWe can try to do the similar thing with a finite set of *guarded TGDs*, but at the same time we want to collect facts that does not mention newly introduced nulls. This motivates the following definition.\n\n\u003e **Definition**. Let $\\Sigma$ be a finite collection of TGDs and $I$ an instance.\n\u003e \n\u003e If $\\Sigma$ has some rule-rewriting $\\Sigma_\\mathrm{rew}$, then we define *the full saturation $\\FullSat_\\Sigma(I)$ of $I$ by $\\Sigma$* as $$\\FullSat_\\Sigma(I) = \\Sat_{\\Sigma_\\rew}(I).$$ \n\u003e \u003e *Remark*. This definition is well-defined, i.e. does not depend on the choice of $\\Sigma_\\mathrm{rew}$, since any two Datalog rewritings produce the same Datalog saturation by the theorem [[#^b7f0b5]]. \n\nThe following proposition is a simple consequence of [[#^b7f0b5]] and the definition of $\\FullSat_\\Sigma(-)$:\n\n\u003e **Proposition**. Suppose that $\\Sigma$ is a set of TGDs that admit a rule-rewriting. Then for a base instance $I$ and a *base fact* $F$, $$F \\in \\FullSat_\\Sigma(I) \\Longleftrightarrow I \\wedge \\Sigma \\models F.$$\n\u003e \u003e *Proof*. $$\n\\begin{align}\n  F \\in \\FullSat_\\Sigma(I)\n    \u0026\\Longleftrightarrow F \\in \\Sat_{\\Sigma_\\mathrm{rew}}(I) \\\\\n    \u0026\\Longleftrightarrow I \\wedge \\Sigma_\\mathrm{rew} \\models F \\\\\n    \u0026\\Longleftrightarrow I \\wedge \\Sigma \\models F.\n\\end{align}\n$$\n","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/references/Books":{"title":"Books","content":"\n## `Introduction to Graph and Hypergraph Theory`\n\n^327283\n\n[SOLO permalink](https://solo.bodleian.ox.ac.uk/permalink/f/89vilt/oxfaleph000591771), EBook ISBN: `9781614701125`\n\nI used a few terminologies from this book to describe/define notions about hypergraphs.","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/references/Papers":{"title":"Papers","content":"\n## `Rewriting the Infinite Chase`\n\n^a74196\n\nLink: [latest version on GitHub pages](https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf)\n\nTODO: write down the ideas that are explored in this paper\n\n## `A general Datalog-based framework for tractable query answering over ontologies`\n\nLink: [ScienceDirect](https://www.sciencedirect.com/science/article/pii/S1570826812000388)\n\nTODO: write down the ideas that are explored in this paper\n","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/thoughts/2022-11-01-About-template-constraints":{"title":"2022-11-01 About template constraints","content":"\n## Constraints on Partitioning Imposed by the Query\n\nSuppose that the following query is given as $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$.\n\nThere are a few ways this query could be witnessed by nulls in an infinite branch of the tree-like chase (a.k.a. \"tentacles\") or by constants in the collection of input or saturated facts (a.k.a. \"squid head\"). The following is an exhaustive list of all possible combinations:\n - 0 variable in the squid head\n\t - all of $x, y, z$ get witnessed in the same tentacle\n - 1 variable in the squid head\n\t - $x$ gets witnessed in the head and $y, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in the same tentacle\n\t - $y$ gets witnessed in the head and $x, z$ get witnessed in different tentacles\n\t - $z$ gets witnessed in the head and $x, y$ get witnessed in the same tentacle\n - 2 variables in the squid head\n\t - $x$ and $y$ get witnessed in the head and $z$ gets witnessed in a tentacle\n\t - $x$ and $z$ get witnessed in the head and $y$ gets witnessed in a tentacle\n\t - $y$ and $z$ get witnessed in the head and $x$ gets witnessed in a tentacle\n - 3 variables in the squid head\n\t - All of $x, y, z$ get witnessed in the squid head\n\nThere are two impossible combinations, namely:\n\n - `x` gets witnessed in the head and $y$ and $z$ get witnessed in _different_ tentacles\n - `z` gets witnessed in the head and $y$ and $x$ get witnessed in _different_ tentacles\n\nTo see why, suppose $y$ and $z$ are instantiated as nulls $n_1$ and $n_2$ in _different tentacles_. Then there is nowhere in the infinite tree-like chase structure that proves $R(n_1, n_2)$, which uses $n_1$ and $n_2$ at the same time. So we conclude that: _if_ $y$ and $z$ are to be instantiated with nulls, _then_ that must be happen on the same tentacle.\n\nGeneralising the example above, we can see that: if the query contains an atom $P(\\vec{u})$ within the existential, then every vector witnessing $\\vec{u}$ in $P(\\vec{u})$ always have all the nulls appear in the single tentacle.\n\nSo we can deduce to a certain extent how the instantiation of variables may be distributed to different tentacles by just looking at the query.\n\n## Constraints Imposed by the Reasoning Rules\n\nIn this section, we shall write $\\Sigma$ for the generic set of rules.\n\nWhen a pseudoquery is proven in a tentacle of the infinite chase, one might imagine the following situation:\n\n![[Pasted image 20221101171150.png]]\n\nHowever, this diagram needs a slight modification: we will always get a set different from $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$ in the $i$-th step of this short-cut proof. This is because we cannot salvage atoms that are not facts (i.e. ones containing nulls) from branches steming from $I_i$. So on top of $I_i$, we are only going to add ***base facts*** that are derived from $I_i$ using $\\Sigma$ (my guess is that this is in general not even a subset of $\\operatorname{Sat}(\\operatorname{rew}(\\Sigma), I_i)$; is this true?). So we wrill write fact-saturated sets of $I_i$ with $\\Sigma$ as $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_i)$.\n\nAlso, by splitting the pseudoquery we can assume that a pseudoquery is realized in $I_n$ as oppsed to $\\operatorname{Sat}_{\\mathrm{facts}}(\\operatorname{rew}(\\Sigma), I_n)$, since if we are assuming all variables in an atom $F(\\vec{t})$ to be realized in the squid head, we may treat $F(\\vec{t})$ as a separate query (TODO: this is really hand-wavy!).\n\nIn fact we will have something like the following:\n\n![[Pasted image 20221101171906.png]]\n\n","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null},"/thoughts/2022-11-09-Head-Tentacle-Partitions-and-Pseudo-Witnesses":{"title":"2022-11-09 Head-Tentacle Partitions and Pseudo-Witnesses","content":"\nWe explorered before in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]] a few possibility on how the entire query can be witnessed by nulls in different tentacles.\n\nLet us be more precise and formal.\n\n**Definition**. For a vector $\\vec{x}$ of distinct variables, we say that a pair $(H, \\mathcal{T})$ is a _head-tentacle partition of $\\vec{x}$_ when\n - $H \\subseteq \\elems(\\vec{x})$ and $\\mathcal{T} \\subseteq \\mathcal{P}(\\elems(\\vec{x}))$\n - $H \\not\\in \\mathcal{T}$\n - Either\n\t - $H = \\emptyset$ and $\\mathcal{T}$ is a partition (i.e. a cover of disjoint nonempty sets) of $\\elems(\\vec{x})$\n\t - $\\set{H} \\cup \\mathcal{T}$ is a partition of $\\elems(\\vec{x})$\n\n**Definition**. For a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$, define the corresponding _compatible cover_ $(H, \\mathcal{T})_\\text{cover}$ as the set $\\set{ H \\cup T \\mid T \\in \\mathcal{T} }$.\n\n**Definition**. Given a boolean conjunctive query $$Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i(\\vec{v_i})$$ we say that a head-tentacle partition $(H, \\mathcal{T})$ of $\\vec{x}$ is _compatible with $Q$_ if, for every $1 \\leq i \\leq n$ and every $x_1, x_2 \\in \\elems(\\vec{v_i})$, there exists $C \\in (H, \\mathcal{T})_\\text{cover}$ such that $\\set{x_1, x_2} \\subseteq C$.\n\n**Definition**. For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$, the _witness pattern $\\mathrm{Pat}_\\sigma$ of $\\sigma$_ is the head-tentacle paritition $(H, \\mathcal{T})$ defined by $$\\begin{align}\nH \u0026= \\set{ x \\in \\elems(\\vec{x}) \\mid \\sigma(x) \\text{ is a constant}} \\\\\nT \u0026= (\\elems(\\vec{x}) \\setminus H) / \\sim\n\\end{align}$$ where $\\sim$ is the equivalence relation given by $x_1 \\sim x_2$ iff $\\sigma(x_1)$ and $\\sigma(x_2)$ appear in the same tentacle (TODO: define this precisely; it should be easy thanks to the explicit construction of $\\SatTree_\\Sigma(I)$).\n\n**Claim**:  For finite set $\\Sigma$ of GTGDs, a base instance $I$, a conjunctive query $Q = \\exists \\vec{x}. \\bigwedge_{1 \\leq i \\leq n} A_i$ and a factual subsitition $\\sigma$ such that $\\sigma(\\vec{A}) \\subseteq \\SatTree_\\Sigma(I)$ (TODO: define notions so that this statement can be shortened), $\\mathrm{Pat}_\\sigma$ is compatible with $Q$.\n\n---\nNow that we defined notions, we can say the same thing as in [[2022-11-01 About template constraints#Constraints on Partitioning Imposed by the Query]], but more concisely:\n\nFor a query $Q = \\exists xyz. R(x, y) \\wedge R(y, z)$, the following are the only head-tentacle partitions compatible with $Q$:\n - $(\\emptyset, \\set{\\set{x, y, z}})$\n - $(\\set{x}, \\set{\\set{y, z}})$\n - $(\\set{y}, \\set{\\set{x, z}})$\n - $(\\set{y}, \\set{\\set{x}, \\set{z}})$\n - $(\\set{z}, \\set{x, y})$\n - $(\\set{x, y}, \\set{\\set{z}})$\n - $(\\set{x, z}, \\set{\\set{y}})$\n - $(\\set{y, z}, \\set{\\set{x}})$\n - $(\\set{x, y, z}, \\emptyset)$\n\nLet us tinker with this example.\n\n**Question.** Given a finite set $\\Sigma$ of GTGDs, is $$\n\\left(\n\\Sigma \\cup \\left\\lbrace\n  \\begin{aligned}\n  \u0026 \\forall u, v. R(u, v) \\rightarrow \\mathrm{Subgoal}_\\mathrm{left}(v), \\\\\n  \u0026 \\forall v, w. R(v, w) \\rightarrow \\mathrm{Subgoal}_\\mathrm{right}(v), \\\\\n  \u0026 \\forall v. \\mathrm{Subgoal}_\\mathrm{left}(v) \\wedge \\mathrm{Subgoal}_\\mathrm{right}(v) \\rightarrow \\mathrm{Goal}^Q() \\\\\n\\end{aligned}\n\\right\\rbrace\n\\right)_\\mathrm{rew}\n$$ a query-rule-rewriting of $(\\Sigma, Q)$?\n\n**Answer**: For each possible head-tentacle partition, we can \"enrich\" the $\\SatTree$ by added rules and see if $\\mathrm{Goal}^Q()$ can be derived using chase steps.","lastmodified":"2022-12-15T19:18:20.596205135Z","tags":null}}