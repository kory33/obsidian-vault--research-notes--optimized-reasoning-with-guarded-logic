<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="We shall build on definitions given in [[Chase-Like Trees and Saturated Chase-Like Trees]]. We will also rely on the results in [[Preliminary Results on Saturated Chase-Like Trees]], and [[Witness Fragmentation and Witness Gluing]]."><title>Reducing Query-Rule-Rewriting Problem to BCQ Answerings</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic//icon.png><link href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/styles.9f7dae4c97607d27bafbfe52e36037c6.min.css rel=stylesheet><link href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/darkmode.bae5edc96f36c4f69e23354ae416a6c2.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/popover.c8d16a5ec626f5ddffabfe05fcc7dbd7.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/",fetchData=Promise.all([fetch("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/indices/linkIndex.5e4c7d1f257398184e3d9eeb0f3ca520.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/indices/contentIndex.04ba67eaa320a4ed005dce6e8547d5b2.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=()=>{addCopyButtons(),addTitleToCodeBlocks(),MathJax.typeset()}</script><script type=module>
    import { attachSPARouting } from "https:\/\/kory33.github.io\/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/>Optimized Reasoning with Guarded Logic</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Reducing Query-Rule-Rewriting Problem to BCQ Answerings</h1><p class=meta>Last updated
Jan 13, 2023
<a href=https://github.com/kory33/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/tree/master/content/notes/Reducing%20Query-Rule-Rewriting%20Problem%20to%20BCQ%20Answerings.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/tags/notes/>Notes</a></li><li><a href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/tags/idea/>Idea</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#preliminaries>Preliminaries</a></li><li><a href=#the-basic-rewriting-algorithm>The Basic Rewriting Algorithm</a></li></ol></nav></details></aside><div>$$
\newcommand\isDefinedAt[2]{{#1 \downarrow #2}}
\def\domain{{\operatorname{dom}}}
\def\elems{{\operatorname{elems}}}
\def\concat{{^\frown}}
\def\head{{\operatorname{head}}}
\def\ConnComp{{\operatorname{ConnComp}}}
\def\Vars{{\mathrm{Vars}}}
\def\Nulls{{\mathrm{Nulls}}}
\def\Consts{{\mathrm{Consts}}}
\def\Predicates{{\mathrm{Predicates}}}
\def\Arity{{\operatorname{Arity}}}
\def\FactualTerms{{\mathrm{FactualTerms}}}
\def\Terms{{\mathrm{Terms}}}
\def\NullableTerms{{\mathrm{NullableTerms}}}
\def\Atoms{{\mathrm{Atoms}}}
\def\Formulae{{\mathrm{Formulae}}}
\def\GTGDFormulae{{\mathrm{GTGDFormulae}}}
\def\FactualSubstitutions{{\mathrm{FactualSubstitutions}}}
\def\QueryAnswers{{\operatorname{QueryAnswers}}}
\def\Facts{{\mathrm{Facts}}}
\def\BaseFacts{{\mathrm{BaseFacts}}}
\def\Instances{{\mathrm{Instances}}}
\def\exlift{{\operatorname{Lift}_\exists}}
\def\Sat{{\operatorname{Sat}}}
\def\FullSat{{\operatorname{FullSat}}}
\def\TreeFacts{{\operatorname{TreeFacts}}}
\def\consts{{\operatorname{consts}}}
\def\vars{{\operatorname{vars}}}
\def\chase{{\operatorname{chase}}}
\def\chaseHead{{\operatorname{chaseHead}}}
\def\rew{{\operatorname{rew}}}
\def\Instance{{\operatorname{Instance}}}
\def\Intro{{\operatorname{Intro}}}
\def\exports{{\operatorname{exports}}}
\def\ChaseStepDir{{\operatorname{ChaseStepDir}}}
\def\SatTree{{\operatorname{SatTree}}}
\def\touchDowners{{\operatorname{touchDowners}}}
\def\Glue{{\operatorname{Glue}}}
\def\Frag{{\operatorname{Frag}}}
\def\Tentacle{{\operatorname{Tentacle}}}
\def\Abst{{\operatorname{Abst}}}
\def\GenConst{{\operatorname{GenConst}}}
\def\GenInst{{\operatorname{GenInst}}}
$$</div><blockquote><p>We shall build on definitions given in <a href=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/notes/definitions/Chase-Like-Trees-and-Saturated-Chase-Like-Trees rel=noopener class=internal-link data-src=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/notes/definitions/Chase-Like-Trees-and-Saturated-Chase-Like-Trees>Chase-Like Trees and Saturated Chase-Like Trees</a>. We will also rely on the results in <a href=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/notes/Preliminary-Results-on-Saturated-Chase-Like-Trees rel=noopener class=internal-link data-src=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/notes/Preliminary-Results-on-Saturated-Chase-Like-Trees>Preliminary Results on Saturated Chase-Like Trees</a>, and <a href=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/notes/Witness-Fragmentation-and-Witness-Gluing rel=noopener class=internal-link data-src=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/notes/Witness-Fragmentation-and-Witness-Gluing>Witness Fragmentation and Witness Gluing</a>.</p></blockquote><a href=#preliminaries><h2 id=preliminaries><span class=hanchor arialabel=Anchor># </span>Preliminaries</h2></a><p>We first make precise the terms that will be useful in describing the algorithm.</p><blockquote><p><strong>Definition</strong>. Given a boolean conjunctive query $\overline{Q} = \exists \vec{x}. \bigwedge_{j \in J} A_j(\vec{u}_j)$ and a subset $V$ of $\elems(\vec{x})$,</p><ul><li>the <em>closure $\overline{V}$ of $V$ in $\overline{Q}$</em> is the set of variables given by $$
\overline{V} = \Set{ x \in \elems(\vec{x})\\ \biggm\vert
\begin{array}{c}
\text{ there are } j \in J \text{ and } x&rsquo; \in V \text{ such that} \\
\vec{u_j} \text{ contains both $x$ and $x&rsquo;$}
\end{array}
}
$$</li><li>the <em>boundary $\partial V$ of $V$ in $\overline{Q}$</em> is the set of variables given by $$\partial V = \overline{V} \setminus V$$</li><li>the <em>subquery $\overline{Q}_V$ of $\overline{Q}$ induced by $V$</em> is the conjunctive query $$\exists \vec{V}. \bigwedge_{j \in J_\overline{V}} A_j(\vec{u}_j)$$ where<ul><li>$\vec{V}$ is $V$ ordered into a sequence by the order of appearance in $\vec{x}$</li><li>$J_\overline{V} = \set{ j \in J \mid \vec{u}_j \text{ only mentions variables from } \overline{V}}$</li></ul></li></ul><blockquote><p><em>Remark</em>. The subquery $\overline{Q}_V$ of $\overline{Q}$ induced by $V$ is typically not boolean anymore, since $\mathrm{FV}(\overline{Q}_V) = \partial V$.</p></blockquote></blockquote><a href=#the-basic-rewriting-algorithm><h2 id=the-basic-rewriting-algorithm><span class=hanchor arialabel=Anchor># </span>The Basic Rewriting Algorithm</h2></a><p>Now consider the following algorithm. Note that we make use of an oracle for BCQ answering over GTGD rules in Step <code>6-3-1-1</code>.</p><blockquote><p><strong>Definition</strong> Define the procedure $\mathrm{QueryRuleRewrite1}(\Sigma, Q)$ as follows:</p><p><em>Input</em>:</p><ul><li>$\Sigma$ a finite set of head-normal GTGDs</li><li>$Q = \exists \vec{x}. \bigwedge_{j \in J} A_j(\vec{u}_j)$ a conjunctive query</li></ul><p><em>Algorithm</em>:</p><ol><li>Let $\Sigma_\mathrm{rew}$ be a Datalog rewriting of $\Sigma$.</li><li>Let <code>mut</code> $\Sigma&rsquo; \leftarrow \emptyset$ be a variable holding new full TGD rules</li><li>Let $\vec{z} \leftarrow$ free variables of $Q$, in the order of quantification</li><li>Let $\overline{Q} = \exists \vec{z}. Q$</li><li>Let $\mathcal{H}(\overline{Q}) = (\mathcal{V}, \mathcal{E})$ be the query structure hypergraph of $\overline{Q}$</li><li>For each connected sub-hypergraph $C$ of vertices in $\mathcal{H}(\overline{Q})$, do:<ol><li>Let $\partial C$ be the boundary of $C$ in $\overline{Q}$, and let $\mathrm{Subgoal_C}$ be a fresh $|\partial C|$-ary predicate symbol associated with $C$</li><li>Let $\overline{Q}_C$ be the subquery of $\overline{Q}$ induced by $C$</li><li>For each $\Sigma$-tentacle ejection template $T = (\tau = \forall \vec{x}. (\beta \rightarrow \exists \vec{y}. \eta) \in \Sigma, \sim_\tau, F_\tau)$, do:<ol><li>For every possible $T$-closing map $\gamma: \partial C \rightarrow {\sim}_\tau \cup \consts(\Sigma)$ on $\overline{Q}_C$ do:<ol><li>If $(T, \gamma)$ generically $\Sigma$-proves $\overline{Q}_C$, then<ol><li>Let $\operatorname{remap}: {\sim_\tau} \rightarrow \Vars$ be any injection from $\sim_\tau$ to the set of variables (for instance, a choice function on $\sim_\tau$)</li><li>Let $\mathrm{quotient}: (\bigcup {\sim_\tau}) \rightarrow {\sim_\tau}$ be the quotient map sending an element in $\bigcup {\sim_\tau}$ to its equivalence class under $\sim_\tau$</li><li>Let $\vec{v}$ be the sequence of variables in $\operatorname{im} (\mathrm{remap} \circ \mathrm{quotient})$ (in some order)</li><li>Add a full TGD rule $$\forall \vec{v}. (\mathrm{remap} \circ \mathrm{quotient})(\beta \wedge F_\tau) \rightarrow (\mathrm{remap} \circ \gamma)(\mathrm{Subgoal}_C(\vec{\partial C}))$$ to $\Sigma'$</li></ol></li></ol></li></ol></li></ol></li><li>Let $\mathrm{Goal}$ be a fresh $|\vec{z}|$-ary goal predicate</li><li>For each subset $V \supseteq \elems(\vec{z})$ of $\mathcal{V}$, do the following:<ol><li>Let $\set{C_i}_{i \in I_V}$ be the set of connected components of $\mathcal{H}(\overline{Q}-V)$</li><li>Let $J_V = \set{ j \in J \mid \vec{u}_j \text{ only contains variables from } V}$</li><li>Add a full TGD rule $$\forall \vec{V}. \left(\bigwedge_{j \in J_V} A_j(\vec{u}_j)\right) \wedge \left(\bigwedge_{i \in I_V} \mathrm{Subgoal}_{C_i}(\partial C_i)\right) \rightarrow \mathrm{Goal}(\vec{z})$$ to $\Sigma'$</li></ol></li><li>Return $(\Sigma_\mathrm{rew} \cup \Sigma&rsquo;, \mathrm{Goal})$</li></ol></blockquote><p>The $\mathrm{Subgoal}_C$ predicate essentially captures the fulfilment of the subquery, with variables in $C$ being witnessed by nulls and variables in $\partial C$ being witnessed by constants in the base instance. To make this idea precise, we prove the following lemma, which also turns out to be useful for the correctness proof of the $\mathrm{QueryRuleRewrite1}$ algorithm.</p><blockquote><p><strong>Lemma (Subquery-Subgoal Correspondence)</strong>. Let $\Sigma$ be a finite set of GTDGs, $Q = \exists \vec{q}. \bigwedge_{j \in J} A_j(\vec{u}_j)$ a conjunctive query and $I$ a ground instance.</p><p>Write</p><ul><li>$(\Sigma_\mathrm{qrr}, \mathrm{Goal}^Q) = \mathrm{QueryRuleRewrite1}(\Sigma, Q)$,</li><li>$\vec{z} = \mathrm{FV}(Q)$ and $\overline{Q} = \exists \vec{z}. Q$, and</li><li>$\mathcal{H}(\overline{Q}) = (\mathcal{V}, \mathcal{E})$ for the query hypergraph of $\overline{Q}$.</li></ul><p>Take any connected sub-hypergraph $C$ of $\mathcal{H}(\overline{Q})$, and let $\overline{Q}_C = \exists \vec{C}. \bigwedge_{j \in J_\overline{C}} A_j(\vec{u}_j)$ be the subquery of $\overline{Q}$ induced by $C$. Then the following implications hold.</p><ol><li>If $\sigma_\overline{C}$ is a factual substitution that exactly covers $\overline{C}$ with $\touchDowners(\sigma_\overline{C}) = \partial C$, then $$
\sigma_\overline{C} \left(
\bigwedge_{j \in J_\overline{C}} A_j(\vec{u}_j)<br>\right) \in \TreeFacts(\SatTree_\Sigma(I))
\Longrightarrow
I \wedge \Sigma_\mathrm{qrr} \models \sigma_\overline{C}(\mathrm{Subgoal}_C(\vec{\partial C})).
$$</li><li>If $\sigma_{\partial C}$ is a ground substitution that covers exactly $\partial C$, then $$
I \wedge \Sigma_\mathrm{qrr}
\models
\sigma_{\partial C}(
\mathrm{Subgoal}_C(\vec{\partial C})
)
\Longrightarrow
I \wedge \Sigma
\models
\sigma_{\partial C}(\overline{Q}_C)
$$</li></ol><blockquote><p><em>Proof of (1)</em>. Suppose that $\sigma_\overline{C}$ is a factual substitution that exactly covers $\overline{C}$ with $\touchDowners(\sigma_\overline{C}) = \partial C$. Suppose further that $$
\sigma_\overline{C}\left(
\bigwedge_{j \in J_\overline{C}} A_j(\vec{u}_j)
\right) \in \TreeFacts(\SatTree_\Sigma(I))$$holds.</p><p>Then all of $\overline{C} \setminus \partial C = C$ are mapped to nulls by $\sigma_\overline{C}$ , and by connectedness of $C$ and the definition of $J_\overline{C}$ , there exists some valid generative path $(\tau = \forall \vec{x}. \beta \rightarrow \exists \vec{y}. \eta, \sigma)$ such that all nulls in $\sigma_\overline{C}[C]$ are introduced within the tentacle hanging from $(\tau, \sigma)$ (TODO: write this fact as a lemma somewhere: this follows from the witness decomposition).</p><p>For a variable $w \in \partial C$ such that $\sigma_\overline{C}(w) \in \consts(\Sigma)$, set $\gamma_\sigma(w) = \sigma_\overline{C}(w)$. Otherwise, if $w \in \partial C$ has $\sigma_\overline{C}(w) \not\in \consts(\Sigma)$, then as $\sigma_\overline{C}\left(\bigwedge_{j \in J_\overline{C}} A_j(\vec{u}_j)\right)$ contains a fact that mentions both $\sigma_\overline{C}(w)$ and a null occuring in $\Tentacle_\Sigma(T, \sigma)$, $\sigma$ must send some variable $\tilde{w} \in \vec{x}$ to $\sigma_\overline{C}(w)$ (TODO: We might want to make this argument a bit more precise. The reasoning is informally as follows: as there is no way $\sigma_\overline{C}(w)$ can be introduced during the chase process (since $\sigma_\overline{C}(w)$ does not appear in $\Sigma$), $\sigma_\overline{C}(w)$ must be mentioned in one of exported facts at the root of the tentacle). So choose such $\tilde{w}$ for each $w \in \partial C$ with $\sigma_\overline{C}(w) \not \in \consts(\Sigma)$, and set $\gamma_\sigma(w) = [\tilde{w}]_{\sim_T}$ for all such $w$.</p><p>We make the following claim:</p><blockquote><p><strong>Claim 1</strong>. $(T, \gamma_\sigma)$ generically proves $\overline{Q}_C$.</p><p><em>Proof</em>. We need to prove that $(\GenConst_\Sigma \circ \mathrm{quotient}_{\sim_T})(F_T \wedge \beta) \wedge \Sigma \models (\mathrm{GenConst}_\Sigma \circ \gamma_\sigma)(\overline{Q}_C)$.</p><p>By the assumption on $\sigma$ and $\sigma_\overline{C}$, we have $\sigma(F_T \wedge \beta) \wedge \Sigma \models \sigma_\overline{C}(\overline{Q}_C)$. As $\mathrm{ker}(\sigma) = {\sim}_T$, $\sigma$ factors through the quotient map and an injection, i.e. there is an injective map $\phi: {\sim}_T \rightarrow \Consts$ such that $\sigma = \phi \circ \mathrm{quotient}_{{\sim}_T}$.</p><p><strong>If $\consts(\Sigma)$ is empty,</strong> then for any $w \in \partial C$, $(\phi^{-1} \circ \sigma_\overline{C})(w) = \gamma_\sigma(w)$ by the construction of $\gamma_\sigma$.</p><p>(TODO: Unfortunately, we do not have $\phi^{-1} \circ \sigma_\overline{C} = \gamma_\sigma$ when $\Sigma$ contains constants. For such cases to work, we need to include the data of &ldquo;which equivalence classes are mapped to which elements in $\consts(\Sigma)$&rdquo;, likely in a form of partial function $\sigma_T \rightharpoonup \consts(\Sigma)$.)</p><p>So $\phi^{-1} \circ \sigma_\overline{C} = \gamma_\sigma$, and as $\mathrm{GenConst}_\Sigma \circ \phi^{-1}$ is a $\consts(\Sigma)$-fixing consts translation, $(\mathrm{GenConst}_\Sigma \circ \phi^{-1} \circ \sigma)(F_T \wedge \beta) \wedge \Sigma = (\GenConst_\Sigma \circ \mathrm{quotient}_{\sim_T})(F_T \wedge \beta) \wedge \Sigma$ entails $(\mathrm{GenConst}_\Sigma \circ \phi^{-1} \circ \sigma_\overline{C}) = (\mathrm{GenConst}_\Sigma \circ \gamma_\sigma)$.</p></blockquote><p>Now that Claim 1 has been established, $\Sigma_\mathrm{qrr}$ contains a rule $$\tau_\mathrm{Subgoal} = \forall \vec{v}. (\mathrm{remap} \circ \mathrm{quotient})(\beta \wedge F_T) \rightarrow (\mathrm{remap} \circ \gamma_\sigma)(\mathrm{Subgoal}_C(\vec{\partial C})).$$for some remapping function $\mathrm{remap}: {\sim_T} \rightarrow \Vars$ and some ordering $\vec{v}$ of variables in $(\mathrm{remap} \circ \mathrm{quotient})(\beta \wedge F_T)$.</p><p>We now wish to set up a substitution $\sigma_\vec{v}$ exactly covering $\vec{v}$ such that $\FullSat(I)$ can be $\tau_\mathrm{Subgoal}$-chased with $\sigma_\vec{v}$ and $\sigma_\vec{v}((\mathrm{remap} \circ \gamma_\sigma)(\mathrm{Subgoal}_C(\vec{\partial C}))) = \sigma_\overline{C}(\mathrm{Subgoal}_C(\vec{\partial C}))$. Pick a retraction $\mathrm{remap}^{-1}$ of $\mathrm{remap}$ and a section $\mathrm{quotient}^{-1}$ of $\mathrm{quotient}$. Now let $\sigma_\vec{v} = \sigma \circ \mathrm{quotient}^{-1} \circ \mathrm{remap}^{-1}$.</p><p>Then $\sigma_\vec{v}((\mathrm{remap} \circ \mathrm{quotient})(\beta \wedge F_T)) = \sigma(\beta \wedge F_T)$. Since $T$ is an abstraction of $(\tau, \sigma)$, we have $\sigma(\beta \wedge F_T) \in \FullSat(I)$, so $\FullSat(I)$ can be $\tau_\mathrm{Subgoal}$-chased with $\sigma_\vec{v}$.</p><p>To check the remaining equality, pick any $w \in \partial C$. If $\sigma_\overline{C}(w) \in \consts(\Sigma)$, then $$
\begin{align}
\sigma_\vec{v}(\mathrm{remap}(\gamma_\sigma(w)))
&= \sigma_\vec{v}(\mathrm{remap}(\sigma_\overline{C}(w))) \\
&= \sigma_\vec{v}(\sigma_\overline{C}(w)) \\
&= \sigma_\overline{C}(w) \\
\end{align}
$$ as $\sigma_\overline{C}(w)$ is just a constant. On the other hand, if $\sigma_\overline{C}(w) \not \in \consts(\Sigma)$, then $$
\begin{align}
\sigma_\vec{v}(\mathrm{remap}(\gamma_\sigma(w)))
&= \sigma_\vec{v}(\mathrm{remap}([\tilde{w}]_{\sim_T})) \\
&= (\sigma \circ \mathrm{quotient}^{-1} \circ \mathrm{remap}^{-1})(\mathrm{remap}([\tilde{w}]_{\sim_T})) \\
&= (\sigma \circ \mathrm{quotient}^{-1})([\tilde{w}]_{\sim_T}) \\
&= \sigma(\tilde{w}) \\
&= \sigma_\overline{C}(w),
\end{align}
$$where the second last equality is due to $\sigma$ conforming to $\sim_T$, and the last equality follows from the choice of $\tilde{w}$.</p><p>From these calculations we have $\sigma_\vec{v}((\mathrm{remap} \circ \gamma_\sigma)(\mathrm{Subgoal}_C(\vec{\partial C}))) = \sigma_\overline{C}(\mathrm{Subgoal}_C(\vec{\partial C}))$. Therefore $\tau_\mathrm{Subgoal}$-chasing $\FullSat(I)$ with $\sigma_\vec{v}$ indeed yields $\sigma_\overline{C}(\mathrm{Subgoal}_C(\vec{\partial C}))$. We conclude that $I \wedge \Sigma_\mathrm{qrr} \models \sigma_\overline{C}(\mathrm{Subgoal}_C(\vec{\partial C}))$.</p></blockquote><blockquote><p><em>Proof of (2)</em>. Suppose that $\sigma_{\partial C}$ is a ground substitution that covers exactly $\partial C$. Suppose further that $$
I \wedge \Sigma_\mathrm{qrr}
\models
\sigma_{\partial C}(
\mathrm{Subgoal}_C(\vec{\partial C})
)$$holds. By construction of $\Sigma_\mathrm{qrr}$, there must be some
- $\Sigma$-ejection template $T = (\tau_T = \forall \vec{x}. (\beta \rightarrow \exists \vec{y}. \eta) \in \Sigma, \sim_T, F_T)$,
- a $T$-closing map $\gamma_T: \partial C \rightarrow {\sim_T} \cup \consts(\Sigma)$,
- an injection $\mathrm{remap}: {\sim}_T \rightarrow \Vars$ and
- a substitution $\sigma_\vec{v}$ that exactly covers $\vec{v} = \operatorname{im} (\mathrm{remap} \circ \mathrm{quotient})$</p><p>such that $(T, \gamma_T)$ generically proves $\overline{Q}_C$ and $$
\begin{align}
(
\sigma_\vec{v}
\circ \mathrm{remap}
\circ \mathrm{quotient}
)(\beta \wedge F_T)
&\subseteq
\FullSat_{\Sigma_\mathrm{qrr}}(I), \\
(
\sigma_\vec{v}
\circ \mathrm{remap}
\circ \gamma_T
)(\mathrm{Subgoal}_C(\vec{\partial C}))
&=
\sigma_{\partial C}(\mathrm{Subgoal}_C(\vec{\partial C})).
\end{align}
$$</p><p>Let $\phi: {\sim}_T \rightarrow \Consts$ be the map defined by $\sigma_\vec{v} \circ \mathrm{remap}$. Since $(\phi \circ \mathrm{quotient})(\beta \wedge F_T) \subseteq \FullSat_{\Sigma_\mathrm{qrr}}(I)$, and as $\Sigma_\mathrm{qrr}$ is a conservative extenstion of $\Sigma$ (where we consider $\mathrm{Subgoal}_C$-s and $\mathrm{Goal}$ as newly introduced predicate symbols) by construction of $\Sigma_\mathrm{qrr}$, $(\phi \circ \mathrm{quotient})(\beta \wedge F_T) \subseteq \FullSat_{\Sigma}(I)$. As $(\phi \circ \mathrm{quotient})(\beta)$ is a set of base facts, $I \wedge \Sigma \models (\phi \circ \mathrm{quotient})(\beta \wedge F_T)$.</p><p>Now, by the application of Genericity of Generic Proofs to $(T, \gamma_T)$ and $\phi$, $(\phi \circ \mathrm{quotient})(\beta \wedge F_T) \models (\phi \circ \gamma_T)(\overline{Q}_C)$. As $(\sigma_\vec{v} \circ \mathrm{remap} \circ \gamma_T)(\mathrm{Subgoal}_C(\vec{\partial C})) = \sigma_{\partial C}(\mathrm{Subgoal}_C(\vec{\partial C}))$, we have $(\sigma_\vec{v} \circ \mathrm{remap} \circ \gamma_T) = \sigma_{\partial C}$. Therefore $$
\begin{align}
(\phi \circ \gamma_T)(\overline{Q}_C)
&= (\sigma_\vec{v} \circ \mathrm{remap} \circ \gamma_T)(\overline{Q}_C) \\
&= \sigma_{\partial C}(\overline{Q}_C),
\end{align}
$$and hence $(\phi \circ \mathrm{quotient})(\beta \wedge F_T) \models \sigma_{\partial C}(\overline{Q}_C)$.</p><p>By transitivity of the $\models$ relation, we conclude that $I \wedge \Sigma \models \sigma_{\partial C}(\overline{Q}_C)$.</p></blockquote></blockquote><blockquote><p><strong>Theorem</strong>. $\mathrm{QueryRuleRewrite1}(\Sigma, Q)$ is a query-rule-rewriting of $(\Sigma, Q)$.</p><blockquote><p><em>Proof</em>. Fix $\Sigma$ and $Q = \exists \vec{q}. \bigwedge_{j \in J} A_j(\vec{u}_j)$ and let</p><ul><li>$(\Sigma_\mathrm{qrr}, \mathrm{Goal}^Q) = \mathrm{QueryRuleRewrite1}(\Sigma, Q)$</li><li>$\vec{z} = \mathrm{FV}(Q)$</li><li>$\mathcal{H}(\overline{Q}) = (\mathcal{V}, \mathcal{E})$ be the query hypergraph of $\overline{Q} = \exists \vec{z}. Q$</li></ul><p>Take any base instance $I$ and a ground substitution $\sigma_\mathrm{sol}$ that covers exactly $\vec{z}$. We wish to see that $$I \wedge \Sigma \models \sigma_\mathrm{sol}(Q) \Longleftrightarrow I \wedge \Sigma_\mathrm{qrr} \models \sigma_\mathrm{sol}(\mathrm{Goal^Q}(\vec{z})) $$holds.</p><p>($\Longrightarrow$, the &ldquo;completeness&rdquo; of the rewrite):
Suppose that $I \wedge \Sigma \models \sigma_\mathrm{sol}(Q)$. Then by the universality of $\SatTree_\Sigma$, the ground substitution $\sigma_\mathrm{sol}$ extends to the factual substitution $\sigma$ exactly covering $\vec{z} \concat \vec{q}$ such that $\set{\sigma(A_j(\vec{u}_j)) \mid j \in J} \subseteq \TreeFacts(\SatTree_\Sigma(I))$.</p><p>Let $V = \touchDowners(\sigma)$ be the touchdowners of $\sigma$. Since $\sigma \supseteq \sigma_\mathrm{sol}$, and $\touchDowners(\sigma_\mathrm{sol}) = \elems(z)$, $V \supseteq \elems(\vec{z})$. Now let $\set{C_i}_{i \in I_V}$ be the set of connected components of $\mathcal{H}(\overline{Q}-V)$, and let $J_V = \set{ j \in J \mid \vec{u}_j \text{ only contains variables from } V}$. By the base-fact completeness of Datalog saturations, it suffices see that the rule $$\forall \vec{V}. \left(\bigwedge_{j \in J_V} A_j(\vec{u}_j)\right) \wedge \left(\bigwedge_{i \in I_V} \mathrm{Subgoal}_{C_i}(\partial C_i)\right) \rightarrow \mathrm{Goal}^Q(\vec{z})$$is applicable to $\FullSat_{\Sigma_\mathrm{qrr}}(I)$ with the ground substitution $\sigma \upharpoonright V$.</p><p>For each $j \in J_V$, $\vec{u}_j$ only contains variables from $V$, so $\sigma(A_j(\vec{u}_j)))$ is a ground fact. Since $\sigma(A_j(\vec{u}_j))) \in \TreeFacts(\SatTree_\Sigma(I))$ and $\Sigma_\mathrm{qrr}$ contains a Datalog rewriting of $\Sigma$, we have $\sigma(A_j(\vec{u}_j))) \in \TreeFacts(\SatTree_{\Sigma_\mathrm{qrr}}(I))$. As $\sigma(A_j(\vec{u}_j)))$ is a ground fact, $\sigma(A_j(\vec{u}_j))) \in \FullSat_{\Sigma_\mathrm{qrr}}(I)$.</p><p>Take $i \in I_V$. It remains to see that $\sigma(\mathrm{Subgoal}_{C_i}(\partial C_i)) \in \FullSat_{\Sigma_\mathrm{qrr}}(I)$. Since $V \cap \overline{C_i} = \partial C_i$, $(\sigma \upharpoonright \overline{C_i})$ exactly covers $\overline{C_i}$ while $\touchDowners(\sigma \upharpoonright \overline{C_i}) = \partial C_i$. Since $$
\sigma\left(\bigwedge_{j \in J} A_j(\vec{u}_j) \right)
\in \TreeFacts(\SatTree_\Sigma(I)),
$$and $J_\overline{C_i} \subseteq J$, <em>a fortiori</em> $$
(\sigma \upharpoonright \overline{C_i})\left(\bigwedge_{j \in J_\overline{C_i}} A_j(\vec{u}_j) \right)
\in \TreeFacts(\SatTree_\Sigma(I)).
$$Therefore by (1) of the Subquery-Subgoal Correspondence Lemma, $$
\begin{align}
I \wedge \Sigma_\mathrm{qrr}
&\models (\sigma \upharpoonright \overline{C_i})(\mathrm{Subgoal}_{C_i}(\vec{\partial C_i})) \\
&= \sigma(\mathrm{Subgoal}_{C_i}(\vec{\partial C_i})).
\end{align}
$$Since $\sigma(\mathrm{Subgoal}_{C_i}(\partial C_i))$ is a ground fact, we conclude that $\sigma(\mathrm{Subgoal}_{C_i}(\partial C_i)) \in \FullSat_{\Sigma_\mathrm{qrr}}(I)$.</p><p>($\Longleftarrow$, the &ldquo;soundness&rdquo; of the rewrite):
Suppose $I \wedge \Sigma_\mathrm{qrr} \models \sigma_\mathrm{sol}(\mathrm{Goal^Q}(\vec{z}))$. By construction of $\Sigma_\mathrm{qrr}$, there must be some subset $V \supseteq \elems(\vec{z})$ of $\mathcal{V}$ such that if we write</p><ul><li>$\set{C_i}_{i \in I_V}$ for the set of connected components of $\mathcal{H}(\overline{Q}-V)$, and</li><li>$J_V$ for the set $\set{ j \in J \mid \vec{u}_j \text{ only contains variables from } V}$,</li></ul><p>then the ground substitution $\sigma_\mathrm{sol}$ can be extended to a ground substitution $\sigma_V$ that exactly covers $\vec{V}$ such that $$
\sigma_V \left(
\set{A_j(\vec{u}_j) \mid j \in J_V} \cup \set{\mathrm{Subgoal}_{C_i}(\partial C_i) \mid i \in I_V}
\right) \subseteq \FullSat_{\Sigma_\mathrm{qrr}}(I)
$$holds, so that the base fact $\sigma_\mathrm{sol}(\mathrm{Goal^Q}(\vec{z}))$ is $\Sigma_\mathrm{qrr}$-derived through the rule $$\forall \vec{V}. \left(\bigwedge_{j \in J_V} A_j(\vec{u}_j)\right) \wedge \left(\bigwedge_{i \in I_V} \mathrm{Subgoal}_{C_i}(\partial C_i)\right) \rightarrow \mathrm{Goal}^Q(\vec{z}).$$together with $\sigma_V$.</p><p>Now for each $i \in I_V$, $\sigma_V \upharpoonright (\partial C_i)$ is a ground substitution exactly covering $\partial C_i$, so by (2) of the Subquery-Subgoal Correspondence Lemma, $I \wedge \Sigma \models (\sigma_V \upharpoonright (\partial C_i))(\overline{Q}_{C_i}) = \sigma_V(\overline{Q}_{C_i})$.</p><p>Also for each $j \in J_V$, $I \wedge \Sigma_\mathrm{qrr} \models \sigma_V(A_j(\vec{u}_j))$, but since $\Sigma_\mathrm{qrr}$ proves no new instance of existing predicates (i.e. predicates that are not $\mathrm{Subgoal}$s and $\mathrm{Goal}^Q$), $I \wedge \Sigma \models \sigma_V(A_j(\vec{u}_j))$.</p><p>Therefore, we have $$
\begin{align}
I \wedge \Sigma
&\models \left(
\bigwedge_{j \in J_V} \sigma_V(A_j(\vec{u}_j))
\right) \wedge \left(
\bigwedge_{i \in I_V}\sigma_V(\overline{Q}_{C_i})
\right).
\end{align}
$$Now $$
\begin{align}
\left(
\bigwedge_{j \in J_V} \sigma_V(A_j(\vec{u}_j))
\right) &\wedge \left(
\bigwedge_{i \in I_V}\sigma_V(\overline{Q}_{C_i})
\right) \\
&= \sigma_V \left(
\left(
\bigwedge_{j \in J_V} A_j(\vec{u}_j)
\right) \wedge \left(
\bigwedge_{i \in I_V} \overline{Q}_{C_i}
\right)
\right) \\
&= \sigma_V \left(
\left(
\bigwedge_{j \in J_V} A_j(\vec{u}_j)
\right) \wedge \left(
\bigwedge_{i \in I_V}
\exists \vec{C_i}. \bigwedge_{j \in J_\overline{C_i}} A_j(\vec{u}_j)
\right)
\right) \\
&\equiv \sigma_V \left(
\left(
\bigwedge_{j \in J_V} A_j(\vec{u}_j)
\right) \wedge \left(
\exists \vec{C_{i_1}}, \ldots ,\vec{C_{i_{|I_V|}}}.
\bigwedge_{i \in I_V}
\bigwedge_{j \in J_\overline{C_i}} A_j(\vec{u}_j)
\right)
\right) \\
&\equiv \sigma_V \left(
\exists \vec{C_{i_1}}, \ldots ,\vec{C_{i_{|I_V|}}}.
\left(
\bigwedge_{j \in J_V} A_j(\vec{u}_j)
\right) \wedge \left(
\bigwedge_{i \in I_V}
\bigwedge_{j \in J_\overline{C_i}} A_j(\vec{u}_j)
\right)
\right) \\
&\equiv \sigma_V \left(
\exists \vec{C_{i_1}}, \ldots ,\vec{C_{i_{|I_V|}}}.
\bigwedge_{j \in J} A_j(\vec{u}_j)
\right)
\end{align}
$$where $J_\overline{C_i} = \set{ j \in J \mid \vec{u}_j \text{ only mentions variables from } \overline{C_i}}$, and the last equivalence is justified by the fact that $J_V \cup \bigcup \set{J_\overline{C_i} \mid i \in I_V} = J$ (which is straightforward to check) and by the $\wedge$-commutativity. Therefore $$I \wedge \Sigma
\models \sigma_V \left(
\exists \vec{C_{i_1}}, \ldots ,\vec{C_{i_{|I_V|}}}.
\bigwedge_{j \in J} A_j(\vec{u}_j)
\right).
$$Now, restricting $\sigma_V$ to $\elems(\vec{z})$ yields $\sigma_\mathrm{sol}$, and existentially quantifying all variables in $V \setminus \elems(\vec{z})$ from the formula $\exists \vec{C_{i_1}}, \ldots ,\vec{C_{i_{|I_V|}}}. \bigwedge_{j \in J} A_j(\vec{u}_j)$ yields the original query $Q$, since $\set{\elems(C_i) \mid i \in I_V}$ is a disjoint cover of $(\elems(\vec{q} \concat \vec{z})) \setminus V$.</p><p>We therefore conclude that $I \wedge \Sigma \models \sigma_\mathrm{sol}(Q)$.</p></blockquote></blockquote></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Ryosuke Kondo using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/>Home</a></li><li><a href=https://twitter.com/Kory__3>Twitter</a></li><li><a href=https://github.com/kory33>Github</a></li></ul></footer></div></div></body></html>