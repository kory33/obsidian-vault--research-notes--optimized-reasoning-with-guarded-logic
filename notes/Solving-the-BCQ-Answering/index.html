<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="In [[Reducing Query-Rule-Rewriting Problem to BCQ Answerings]], we saw how to reduce the query-rewriting problem to exponentially many, mostly independent subproblems of BCQ answerings."><title>Optimized Reasoning with Guarded Logic</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic//icon.png><link href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/styles.9f7dae4c97607d27bafbfe52e36037c6.min.css rel=stylesheet><link href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/darkmode.bae5edc96f36c4f69e23354ae416a6c2.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/popover.c8d16a5ec626f5ddffabfe05fcc7dbd7.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/",fetchData=Promise.all([fetch("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/indices/linkIndex.edd208bbbbbd7e90fd5a634d7bcfc6bd.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/indices/contentIndex.48daffd62098eb8fc571c00098e6b8fe.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=()=>{addCopyButtons(),addTitleToCodeBlocks(),MathJax.typeset()}</script><script type=module>
    import { attachSPARouting } from "https:\/\/kory33.github.io\/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/>Optimized Reasoning with Guarded Logic</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Feb 7, 2023
<a href=https://github.com/kory33/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/tree/master/content/notes/Solving%20the%20BCQ%20Answering.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#problem-framing>Problem Framing</a></li><li><a href=#the-strategy>The Strategy</a><ol><li><a href=#the-data-structure-describing-chase-like-trees-with-bounded-width>The Data Structure Describing Chase-Like Trees With Bounded Width</a></li><li><a href=#finite-witnesses-to-the-problem>Finite Witnesses to the Problem</a></li><li><a href=#the-high-level-algorithm>The High-Level Algorithm</a></li></ol></li><li><a href=#construction-of-the-chase-automaton>Construction of the Chase Automaton</a></li><li><a href=#construction-of-the-query-automaton>Construction of the Query Automaton</a></li></ol></nav></details></aside><div>$$
\newcommand\isDefinedAt[2]{{#1 \downarrow #2}}
\def\domain{{\operatorname{dom}}}
\def\elems{{\operatorname{elems}}}
\def\concat{{^\frown}}
\def\head{{\operatorname{head}}}
\def\ConnComp{{\operatorname{ConnComp}}}
\def\Vars{{\mathrm{Vars}}}
\def\Nulls{{\mathrm{Nulls}}}
\def\Consts{{\mathrm{Consts}}}
\def\Predicates{{\mathrm{Predicates}}}
\def\Arity{{\operatorname{Arity}}}
\def\FactualTerms{{\mathrm{FactualTerms}}}
\def\Terms{{\mathrm{Terms}}}
\def\NullableTerms{{\mathrm{NullableTerms}}}
\def\Atoms{{\mathrm{Atoms}}}
\def\Formulae{{\mathrm{Formulae}}}
\def\GTGDFormulae{{\mathrm{GTGDFormulae}}}
\def\FactualSubstitutions{{\mathrm{FactualSubstitutions}}}
\def\QueryAnswers{{\operatorname{QueryAnswers}}}
\def\Facts{{\mathrm{Facts}}}
\def\BaseFacts{{\mathrm{BaseFacts}}}
\def\Instances{{\mathrm{Instances}}}
\def\exlift{{\operatorname{Lift}_\exists}}
\def\Sat{{\operatorname{Sat}}}
\def\FullSat{{\operatorname{FullSat}}}
\def\TreeFacts{{\operatorname{TreeFacts}}}
\def\consts{{\operatorname{consts}}}
\def\vars{{\operatorname{vars}}}
\def\chase{{\operatorname{chase}}}
\def\chaseHead{{\operatorname{chaseHead}}}
\def\rew{{\operatorname{rew}}}
\def\Instance{{\operatorname{Instance}}}
\def\Intro{{\operatorname{Intro}}}
\def\exports{{\operatorname{exports}}}
\def\ChaseStepDir{{\operatorname{ChaseStepDir}}}
\def\SatTree{{\operatorname{SatTree}}}
\def\touchDowners{{\operatorname{touchDowners}}}
\def\Glue{{\operatorname{Glue}}}
\def\Frag{{\operatorname{Frag}}}
\def\Tentacle{{\operatorname{Tentacle}}}
\def\Abst{{\operatorname{Abst}}}
\def\GenConst{{\operatorname{GenConst}}}
\def\GenInst{{\operatorname{GenInst}}}
$$</div><p>In <a href=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/notes/Reducing-Query-Rule-Rewriting-Problem-to-BCQ-Answerings rel=noopener class=internal-link data-src=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/notes/Reducing-Query-Rule-Rewriting-Problem-to-BCQ-Answerings>Reducing Query-Rule-Rewriting Problem to BCQ Answerings</a>, we saw how to reduce the query-rewriting problem to exponentially many, mostly independent subproblems of BCQ answerings. While the independence allows easy parallelization of the rewrite algorithm, solving these subproblems is not at all trivial.</p><p>After the reduction, we had to solve BCQ answering problems on &ldquo;small&rdquo; base instances. These instances only contain generic constants, constants in rules and constants in the query, and the number of constants appearing in such instances is bounded by the sum of $|\consts(\Sigma)|$ and the maximum arity $\mathrm{maxArity}_\mathcal{L}$ of predicates in the relation schema $\mathcal{L}$ (because they are $\Sigma$-guarded by a single guard in the single rule that is supposed to fire a tentacle witnessing a subquery).</p><p>In this note, we aim to describe the basic algorithm for deciding BCQ queries over those &ldquo;generic base instances&rdquo;.</p><a href=#problem-framing><h2 id=problem-framing><span class=hanchor arialabel=Anchor># </span>Problem Framing</h2></a><blockquote><p><strong>Definition</strong>. Suppose $\Sigma$ is a finite set of $\mathcal{L}$-GTGDs. An instance $I$ is $(\mathcal{L}, \Sigma)$-small if $|\consts(I) \setminus \consts(\Sigma)| + |\mathrm{nulls}(I)| \leq \mathrm{maxArity}_\mathcal{L}$. We say that a chase-like tree $(T, \Instance_T)$ is $(\mathcal{L}, \Sigma)$-small if $\Instance_T(v)$ is $(\mathcal{L}, \Sigma)$-small for every $v \in T$.</p></blockquote><blockquote><p><em>Remark</em>. If an instance $I$ is $(\mathcal{L}, \Sigma)$-small, then $$|\consts(I) \cup \mathrm{nulls}(I)| \leq \mathrm{maxArity}_\mathcal{L} + |\consts(\Sigma)|.$$</p></blockquote><p>The following is the problem we need to decide.</p><blockquote><p><strong>Definition</strong>. Let $\Sigma$ be a finite set of $\mathcal{L}$-GTGDs <strong>whose existential rules are single-headed</strong>, and $Q = \bigwedge_{j \in J} A_j(\vec{u}_j)$ a boolean conjunctive query over $\mathcal{L}$.</p><p>The problem $\mathrm{GuardedBCQOverSmallInsts}_{\Sigma, Q}$ is the set of all $(\mathcal{L}, \Sigma)$-small base instances $I$ such that $I \wedge \Sigma \models Q$.</p></blockquote><p>The assumption that existential rules in $\Sigma$ must be single-headed is not a loss of generality, because given any GTGD $\tau = \forall \vec{x}. \beta \rightarrow \exists \vec{y}. \eta$ that is not necessarily single-headed, by introducing an intermediate predicate $P_\tau$ of arity $|\vec{x}| + |\vec{y}|$, we can &ldquo;split&rdquo; $\tau$ into two rules $\forall \vec{x}. \beta \rightarrow \exists \vec{y}. P_\tau(\vec{x}, \vec{y})$ and $\forall \vec{x}, \vec{y}. P_\tau(\vec{x}, \vec{y}) \rightarrow \eta$.</p><blockquote><p><em>Note</em>: We can do a bit better than $|\vec{x}| + |\vec{y}|$ for arity of $P_\tau$; in fact, $|\vars(\eta)|$ is enough (so that variables &ldquo;discarded&rdquo; by the rule $\tau$ do not carry over to the rule $\forall \vec{z}. P_\tau \rightarrow \eta$).</p></blockquote><blockquote><p><em>Question</em>: This splitting process unavoidably increases maximum arity in the signature, which we would like to keep as small as possible. How much can we do better if we drop this assumption and begin with the original $\Sigma$? Put more precisely, if $\Sigma$ is the original set of rules and $\Sigma&rsquo;$ is the single-headed variant of $\Sigma$, does the chase of $I \wedge \Sigma$ ever have a smaller treewidth compared to the chase of $I \wedge \Sigma&rsquo;$ ?</p></blockquote><a href=#the-strategy><h2 id=the-strategy><span class=hanchor arialabel=Anchor># </span>The Strategy</h2></a><p>To decide $\mathrm{GuardedBCQOverSmallInsts}_{\Sigma, Q}$, we shall explicitly define the class of tree structures that act as possible witnesses to instances of $\mathrm{GuardedBCQOverSmallInsts}_{\Sigma, Q}$.</p><p>Notice first the following:</p><blockquote><p><strong>Proposition</strong>. If $\Sigma$ is a finite set of $\mathcal{L}$-GTGDs whose existential rules are single-headed and $I$ is a $(\mathcal{L}, \Sigma)$-small base instance, then $\SatTree_\Sigma(I)$ is $(\mathcal{L}, \Sigma)$-small.</p><blockquote><p><em>Proof</em>. We show, by induction on $\vec{d}$, that $\Instance_{\SatTree_\Sigma(I)}(\vec{d})$ is $(\mathcal{L}, \Sigma)$-small for every node $\vec{d}$ in $\SatTree_\Sigma(I)$.</p><p>To see the base case, $I$ is $(\mathcal{L}, \Sigma)$-small, so $\FullSat(I) = \Instance_{\SatTree_\Sigma(I)}(())$ is also $(\mathcal{L}, \Sigma)$-small, since $\FullSat$ cannot introduce new non-$\Sigma$-constant factual terms into the instance.</p><p>For the inductive part, suppose $\vec{d} \concat (\tau = \forall \vec{x}. \beta \rightarrow \exists \vec{y}. H(\vec{u}), \sigma)$ is a valid generative $\Sigma$-chase path. Notice that $\tau$ is generative and single-headed, so it has a single atom $H$ in its head. By definition, $\Instance_{\SatTree_\Sigma(I)}(\vec{d} \concat (\tau, \sigma))$ is a $\FullSat$ of an instance $\Sigma$-guarded by $\chaseHead_\nu(\tau, \sigma) = H(\sigma
[\vec{y} \xrightarrow{\nu} \Nulls](\vec{u}))$ for some null-picking function $\nu$. Since $H(\sigma
[\vec{y} \xrightarrow{\nu} \Nulls](\vec{u}))$ contains at most $|\Arity(H)|$ factual terms, $\Instance_{\SatTree_\Sigma(I)}(\vec{d} \concat (\tau, \sigma))$ can contain at most $|\Arity(H)| \leq \mathrm{maxArity}_\mathcal{L}$ non-$\Sigma$-constant factual terms, so $\Instance_{\SatTree_\Sigma(I)}(\vec{d} \concat (\tau, \sigma))$ is $(\mathcal{L}, \Sigma)$-small.</p></blockquote></blockquote><p>Together with the universality of $\SatTree$s, this proposition implies that a chase-like tree with a treewidth of at most $\mathrm{maxArity}_\mathcal{L} + |\consts(\Sigma)|$, that is also a &ldquo;finite prefix&rdquo; of $\SatTree_\Sigma(I)$ and witnesses $Q$, is the witness of an instance of $\mathrm{GuardedBCQOverSmallInsts}_{\Sigma, Q}$, and conversely there is such a chase-like tree whenever $I \in \mathrm{GuardedBCQOverSmallInsts}_{\Sigma, Q}$.</p><a href=#the-data-structure-describing-chase-like-trees-with-bounded-width><h3 id=the-data-structure-describing-chase-like-trees-with-bounded-width><span class=hanchor arialabel=Anchor># </span>The Data Structure Describing Chase-Like Trees With Bounded Width</h3></a><p>We shall temporarily move away from considering models of $I \wedge \Sigma$, and work with more general structures of (a sublanguage of) $\mathcal{L}$. We will describe a data structure, which we shall call <em>finite $(\mathcal{L}, k)$-tree codes</em>, that is able encode finite chase-like trees over (a sublanguage of) $\mathcal{L}$ with a specified maximum treewidth $k$.</p><p>We begin with the formal description of the structure. These definitions are adopted from <a href=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/references/Papers#codedecidable-logics-via-automata/code rel=noopener class=internal-link data-src=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/references/Papers>Papers</a>.</p><blockquote><p><strong>Definition</strong>. The first order language $\mathcal{L}^-$ is defined to be the language with no constants and the same predicate set as $\mathcal{L}$.</p></blockquote><blockquote><p><strong>Definition</strong>. Let $X$ be a set. The set $\mathrm{PStructuresOver}_\mathcal{L}(X)$ of <em>predicate structures over the set $X$</em> is defined to be the set of all $\mathcal{L}^-$-structures having the universe as $X$. For $\mathcal{S} \in \mathrm{StructuresOver}_\mathcal{L}(X)$, the subset $\mathrm{ActiveValues}(\mathcal{S})$ of $X$ is the set given by $$\mathrm{ActiveValues}(\mathcal{S}) = \set{ x \in X \mid (\vec{y}_1, x, \vec{y}_2) \in P_\mathcal{S} \text { for some predicate } P \text{ and } \vec{y}_1, \vec{y}_2 \subseteq X }.$$</p></blockquote><blockquote><p><strong>Definition</strong>. Let $k \geq 1$. A <em>finite $(\mathcal{L}, k)$-tree code</em> is a pair of a rooted tree $(T, v_0)$ and a <em>labelling function</em> $\lambda: V_T \rightarrow \mathrm{PStructuresOver}_\mathcal{L}(\overline{2k})$ where $V_T$ is the vertex tree of $T$ and $\overline{2k}$ is the set $\set{0, 1, \ldots, 2k-1}$, such that $$|\mathrm{ActiveValues}(\lambda(v))| \leq k.$$</p></blockquote><p>Each finite $(\mathcal{L}, k)$-tree code encodes a finite $\mathcal{L}^-$-structure having a treewidth at most $k$, in the following sense.</p><blockquote><p><strong>Definition</strong>. Let $\mathcal{C} = ((T, v_0), \lambda: V_T \rightarrow \mathrm{PStructuresOver}_\mathcal{L}(\overline{2k}))$ be a finite $(\mathcal{L}, k)$-tree code.</p><p>The set $\mathrm{GNames}(\mathcal{C})$ of <em>global names in $\mathcal{C}$</em> is the subset of $V_T \times \overline{2k}$ defined by $$
\mathrm{GNames}(\mathcal{C}) =
\set{\\ (v, n) \in V_T \times \overline{2k} \mid n \in \mathrm{ActiveValues}(\lambda(v))\\ }.
$$
We say that two global names $(v_1, n_1)$ and $(v_2, n_2)$ are <em>linked in $\mathcal{C}$</em> if $n_1 = n_2$ and $v_1$ is adjacent to $v_2$ in $T$.</p><p>Let $\sim_\mathcal{C}$ be the reflexive transitive closure of the relation &ldquo;linked in $\mathcal{C}$&rdquo; on $\mathrm{GNames}(\mathcal{C}) \times \mathrm{GNames}(\mathcal{C})$. The <em>$\mathcal{L}^-$-structure $\mathrm{Decode}(\mathcal{C})$ coded by $\mathcal{C}$</em> is the quotient $\mathcal{L}^-$-structure $$
\mathrm{Decode}(\mathcal{C}) := \left(
\coprod_{v \in V_T} \lambda(v)
\right) \Bigg/ \sim_\mathcal{C}.
$$</p></blockquote><blockquote><p><em>Remark</em>. Elements in the numeral $\overline{2k}$ are often referred to as &ldquo;local names&rdquo;, for instance in <a href=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/references/Papers#codedecidable-logics-via-automata/code rel=noopener class=internal-link data-src=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/references/Papers>Papers</a>. This is because the same local name $n \in \overline{2k}$ at two different nodes $v_1, v_2$ correspond to different global names $(v_1, n)$ and $(v_2, n)$, which in turn <em>may</em> represent distinct elements in $\mathrm{Decode}(\mathcal{C})$ when $v_1$ and $v_2$ are not adjacent in $T$.</p></blockquote><blockquote><p><em>Remark</em>. The variant used here encodes &ldquo;equality between local names&rdquo; (this is an abuse of notation; what we really mean is the equality of the elements in the structure encoded by the local names) in adjacent nodes <em>implicitly</em>, by asserting that two equal local names in adjacent nodes encode the same element in the original chase-like structure.</p><p>We could also demand that there are only $k$ local names, and equality between local names to be encoded by explicit <em>equality predicates</em>. This is referred to as the <em>explicit equality coding</em> in <a href=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/references/Papers#codedecidable-logics-via-automata/code rel=noopener class=internal-link data-src=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/references/Papers>Papers</a>.</p></blockquote><blockquote><p><em>Example</em>. Let $\Predicates_\mathcal{L} = \set{ U, Edge }$ with arities $\Arity(U) = 1$ and $\Arity(Edge) = 2$.</p><p>Consider the following $(\mathcal{L}, k)$-tree code $\mathcal{C}$, with $k = 3$:</p><p><img src=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/images/drawio/tree-codes-example-code.drawio.svg width=auto></p><p>For $i \in \set{1, 2}$, the global names $(v_0, i)$ and $(v_1, i)$ are linked, so in $\mathrm{Decode}(\mathcal{C})$ will have these global names identified. Moreover, these are the only global names that form nontrivial equivalence classes of $\sim_\mathcal{C}$ (where $\sim_\mathcal{C}$ is as in the defintion of the coded structure). Therefore $\mathrm{Decode}(\mathcal{C})$ has a structure as in the following picture:</p><p><img src=/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/images/drawio/tree-codes-example-decoded.drawio.svg width=auto></p></blockquote><a href=#finite-witnesses-to-the-problem><h3 id=finite-witnesses-to-the-problem><span class=hanchor arialabel=Anchor># </span>Finite Witnesses to the Problem</h3></a><p>We now describe the condition of finite tree codes being a witness to the problem $\mathrm{GuardedBCQOverSmallInsts}_{\Sigma, Q}$.</p><p>(TODO)</p><a href=#the-high-level-algorithm><h3 id=the-high-level-algorithm><span class=hanchor arialabel=Anchor># </span>The High-Level Algorithm</h3></a><p>(TODO: we should make clear how a certain class of finite $\mathcal{L}^-$-structure can be &ldquo;reinterpreted&rdquo; as a finite prefix of $\SatTree_\Sigma(I)$, which are Herbrand $\mathcal{L}^+$-structures.)</p><p>The preceding arguments motivate the following basic algorithm for deciding $\mathrm{GuardedBCQOverSmallInsts}_{\Sigma, Q}$:</p><ol><li>Build a finite tree automaton $\mathcal{A}_{\Sigma\text{-chase}}$ (the <em>chase automaton</em>) over $(\mathcal{L}, \mathrm{maxArity}_\mathcal{L} + |\consts(\Sigma)|)$-tree codes that recognizes all tree codes which encode finite prefixes of $\SatTree_\Sigma(I)$.</li><li>Build another finite tree automaton $\mathcal{A}_Q$ (the <em>query automaton</em>) over $(\mathcal{L}, \mathrm{maxArity}_\mathcal{L} + |\consts(\Sigma)|)$-tree-codes that recognizes all tree codes which encode finite chase-like trees satisfying $Q$.</li><li>Formally intersect $\mathcal{A}_{\Sigma\text{-chase}}$ and $\mathcal{A}_Q$ to form the product automaton $\mathcal{A}$, so that $L(\mathcal{A}) = \mathcal{A}_{\Sigma\text{-chase}} \cap \mathcal{A}_Q$.</li><li>Return $L(\mathcal{A}) \neq \emptyset$.</li></ol><a href=#construction-of-the-chase-automaton><h2 id=construction-of-the-chase-automaton><span class=hanchor arialabel=Anchor># </span>Construction of the Chase Automaton</h2></a><a href=#construction-of-the-query-automaton><h2 id=construction-of-the-query-automaton><span class=hanchor arialabel=Anchor># </span>Construction of the Query Automaton</h2></a></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Ryosuke Kondo using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://kory33.github.io/obsidian-vault--research-notes--optimized-reasoning-with-guarded-logic/>Home</a></li><li><a href=https://twitter.com/Kory__3>Twitter</a></li><li><a href=https://github.com/kory33>Github</a></li></ul></footer></div></div></body></html>